
%% bare_jrnl_compsoc.tex
%% V1.4a
%% 2014/09/17
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8a or later) with an IEEE
%% Computer Society journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE!
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_conf_compsoc.tex,
%%                    bare_jrnl_compsoc.tex, bare_jrnl_transmag.tex
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices and paper sizes can       ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/


\documentclass[10pt,journal, compsoc]{IEEEtran}
\usepackage{savesym}
\usepackage{amsmath}
\savesymbol{iint}
\usepackage{txfonts}
\usepackage{graphicx}
%\usepackage{amssymb}
%\usepackage{verbatim}
\usepackage{algorithm} %format of the algorithm
% \usepackage{algorithmic}
\usepackage{algcompatible}
%\usepackage{algorithmic2e}
\usepackage{color}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{makecell}
\usepackage[capitalize]{cleveref}
%\usepackage[numbers,sort&compress]{natbib}
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[10pt,journal,compsoc]{../sty/IEEEtran}
\usepackage{xcolor}
\usepackage{ulem}

\newtheorem{definition}{\textbf{Definition}}
\newtheorem{lemma}{\textbf{Lemma}}
\newtheorem{property}{\textbf{Property}}
\newtheorem{proof}{Proof}
\newtheorem{problem}{\textbf{Problem}}



\hyphenpenalty=7000


% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
%  \usepackage[nocompress]{cite}
%\else
  % normal IEEE
%  \usepackage{cite}
%\fi
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.
%
% Note that some packages require special options to format as the Computer
% Society requires. In particular, Computer Society  papers do not use
% compressed citation ranges as is done in typical IEEE papers
% (e.g., [1]-[4]). Instead, they list every citation separately in order
% (e.g., [1], [2], [3], [4]). To get the latter we need to load the cite
% package with the nocompress option which is supported by cite.sty v4.0
% and later. Note also the use of a CLASSOPTION conditional provided by
% IEEEtran.cls V1.7 and later.





% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/tex-archive/info/epslatex/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex






% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=footnotesize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a sans serif font rather
% than the serif font used in traditional IEEE formatting and thus the need
% to invoke different subfig.sty package options depending on whether
% compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Do not use the stfloats baselinefloat ability as IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/dblfloatfix/




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and
% Axel Sommerfeldt. This package may be useful when used in conjunction with
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/endfloat/
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/url/
% Basically, \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Security-Driven Task Scheduling under \textcolor{purple}{Deadline Constraints} for MPSoCs with Untrusted 3PIP Cores}
%\title{Security-Aware Task Scheduling for MPSoCs with Performance and Area Optimization}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%
%
%\IEEEcompsocitemizethanks is a special \thanks that produces the bulleted
% lists the Computer Society journals use for "first footnote" author
% affiliations. Use \IEEEcompsocthanksitem which works much like \item
% for each affiliation group. When not in compsoc mode,
% \IEEEcompsocitemizethanks becomes like \thanks and
% \IEEEcompsocthanksitem becomes a line break with idention. This
% facilitates dual compilation, although admittedly the differences in the
% desired content of \author between the different types of papers makes a
% one-size-fits-all approach a daunting prospect. For instance, compsoc
% journal papers have the author affiliations above the "Manuscript
% received ..."  text while in non-compsoc journals this is reversed. Sigh.

\author{Nan~Wang,~\IEEEmembership{Member,~IEEE,}
        ~Lijun~Lu,%~\IEEEmembership{Member,~IEEE,}
        ~Songping~Liu,%~\IEEEmembership{Member,~IEEE,}
%        ~Song~Chen,~\IEEEmembership{Member,~IEEE,}
        ~Hongqing~Zhu, ~\IEEEmembership{Member,~IEEE,}
        and~Yu~Zhu,~\IEEEmembership{Member,~IEEE,}

\thanks{This work was supported by the National Key R\&D Program of China under Grant 2022YFD2000400.}
\thanks{Nan Wang, Lijun Lu, Songping Liu, Hongqing~Zhu and Yu Zhu are with the School of Information Science and Engineering, East China University of Science and Technology, Shanghai, 200237, China.}% <-this % stops a space
%\thanks{Song Chen is with the School of Information Science and Technology, University of Science and Technology of China, Hefei, 230026, China.}
%\thanks{Cong Hao and Takeshi Yoshimura are with the Graduate School of Information, Production and Systems, Waseda University, 808-0135, Japan.}% <-this % stops a space
}

% note the % following the last \IEEEmembership and also \thanks -
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
%
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
\markboth{Journal of \LaTeX\ Class Files,~Vol.~13, No.~9, September~2014}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Computer Society Journals}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
%
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.



% The publisher's ID mark at the bottom of the page is less important with
% Computer Society journal papers as those publications place the marks
% outside of the main text columns and, therefore, unlike regular IEEE
% journals, the available text space is not reduced by their presence.
% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2014 IEEE}
% or like this to get the Computer Society new two part style.
%\IEEEpubid{\makebox[\columnwidth]{\hfill 0000--0000/00/\$00.00~\copyright~2014 IEEE}%
%\hspace{\columnsep}\makebox[\columnwidth]{Published by the IEEE Computer Society\hfill}}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark (Computer Society jorunal
% papers don't need this extra clearance.)



% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}



% for Computer Society papers, we must declare the abstract and index terms
% PRIOR to the title within the \IEEEtitleabstractindextext IEEEtran
% command as these need to go into the title area created by \maketitle.
% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\IEEEtitleabstractindextext{%
\begin{abstract}
The high penetration of third-party intellectual property in MPSoCs gives rise to security concerns, and a set of security-driven constraints is imposed into task scheduling step of the design process to protect MPSoCs against hardware Trojan attacks. Due to the significant performance and area overheads incurred, designers start to selectively apply security-driven constraints to achieve the design targets, but they often ignore that parts of a design may be more vulnerable to hardware Trojan attacks. In this study, the differences in vulnerability to hardware Trojan attacks are also considered in the MPSoC design process, and a security-driven task scheduling method is proposed to minimize both the design vulnerability and chip area under \textcolor{purple}{deadline constraints}. First, the schedule length is iteratively optimized by a maximum weight independent set-based method that minimizes the vulnerability increment. Second, tasks are assigned to IP vendors with a minimized number of cores required by maximizing the core sharing of tasks. Finally, tasks are scheduled to time periods using the force-directed scheduling method. Experimental results demonstrate the effectiveness of the proposed method in reducing the number of cores while maintaining system security under \textcolor{purple}{deadline constraints}.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
MPSoC, third-party IP core, hardware Trojan, task scheduling, security.
\end{IEEEkeywords}}


% make the title area
\maketitle


% To allow for easy dual compilation without having to reenter the
% abstract/keywords data, the \IEEEtitleabstractindextext text will
% not be used in maketitle, but will appear (i.e., to be "transported")
% here as \IEEEdisplaynontitleabstractindextext when the compsoc
% or transmag modes are not selected <OR> if conference mode is selected
% - because all conference papers position the abstract like regular
% papers do.
\IEEEdisplaynontitleabstractindextext
% \IEEEdisplaynontitleabstractindextext has no effect when using
% compsoc or transmag under a non-conference mode.



% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}

The increased design productivity requirements for heterogeneous multiprocessor System-on-Chip (MPSoC) require the industry to procure and use the latest commercial-off-the-shelf electronic components to track the most cutting edge technology while reducing manufacturing costs \cite{article:KX}. This has given rise to the trend of outsourcing the design and fabrication of third-party intellectual property (3PIP) components, which may not be trustworthy, and the hardware Trojans (HTs) in these 3PIP components present high risks of malicious inclusions and data leakage in products \cite{conference:XW}. This raises security concerns \cite{article:SB} because a small hardware modification by an adversary in the 3PIP cores can compromise the whole chip \cite{conference:MH}. If such chips run safety-critical applications (e.g., autonomous vehicles), the HT attacks may lead to catastrophic or life-threatening consequences \cite{conference:AM1}. Similarly, if these chips are used in information-critical systems (e.g., banking), the confidentiality and integrity of the user's data can be compromised \cite{conference:FK}.

%In particular, the growing number of mission-critical applications (e.g., finance and military) that use MPSoCs means that security is the highest priority issue \cite{article:CL, article:DM}, whereas the increasing integration of third-party Intellectual Property (3PIP) and the outsourcing of fabrication indicate that most MPSoCs are not 100\% trustworthy.



Emerging security problems bring an urgent need to detect possible HT attacks or mitigate their effects. Methods for detecting HTs can primarily be classified into the following groups: physical inspection \cite{network:SS}, functional testing \cite{conference:BB}, built-in tests \cite{article:DD}, and side-channel analyses \cite{article:YH1}. However, it is impossible to detect advanced HTs, such as A2, due to its insertion stage and software triggered mechanism \cite{conference:YH}.% To safeguard against potentially undetected Trojans, runtime validation approaches provide a last line of defense against Trojan attacks and attempt to contain the effect of an activated Trojan \cite{article:SB}.


%Runtime monitoring techniques insert hardware sensors in circuits to check abnormal runtime behaviors by monitoring side channel signals or circuit operations \cite{conference:JH, article:YH}. The main challenge in runtime monitoring is that many extra circuit overheads must be added to ensure the monitoring effectiveness and accuracy even though many studies have been proposed to reduce these overheads \cite{ article:JZ, conference:MH}. Besides, hardware Trojans may still escape these runtime monitoring techniques because too few gates are used, and hardware Trojans will not cause any thermal or power fluctuations.

Modular redunancy is an HT-tolerance technique that provides comprehensive protections to circuits and verify the correctness of system functionality at runtime \cite{article:BM,article:TR,conference:MB,conference:MS}. Incorporating security constraints in the MPSoC design process is one of the most popular design-for-trust techniques, which can mitigate the effects of the HTs and enable trustworthy computations using untrusted 3PIP cores \cite{article:JR3,conference:XC,article:SR}. This is achieved by duplicating tasks and mapping them on 3PIP cores from different vendors to detect HTs that alter task outputs or mute potential HT effects by preventing collusion between malicious 3PIP cores from the same vendor. But these security constraints in the design stage incur significant overheads (e.g., approximately 200\% area and 50\% performance overheads \cite{article:XC}). As each task needs to be conducted duplicately to ensure the correctness of the outputs, and this brings significant redundant computation cost; all data-dependent tasks must be computed by the cores from different vendors to establish trustworthy communications, and all these communications are inter-core communications with long delays. Therefore, researchers have developed a number of solutions and created trusted designs with minimum resource overheads, performance degradation and energy consumption \cite{conference:AS, article:YS, article:XC}.

Some researchers have also started to consider security constraints as loose constraints (security constraints are not applied to all tasks and communications) to satisfy the design targets \cite{article:CL, article:NW, conference:NW}. However, their studies ignore that parts of a design are much more vulnerable to HT attacks \cite{conference:HS}, and removing security constraints from the parts of a circuit that are more susceptible to Trojan insertion may yield significant security losses \cite{article:XC}. Furthermore, these studies only optimize the system performance in the context of security constraints, and might incur a significant area overhead, which is also one of the critical issues towards trusted design. Therefore, performance and security along with chip area should be jointly considered for MPSoC design, especially for heterogeneous MPSoCs built from untrusted 3PIPs.

%Existing studies focused on area optimization primarily address the problem in the task scheduling stage \cite{article:SR} because the number of cores required can only be evaluated after vendor assignment. However, vendor assignment is a prior stage of task scheduling, whose results strongly affect area optimization results of task scheduling, and ignoring the area optimization during vendor assignments limits the area optimization results. Also, researchers have treated each communication equally when optimizing the system performance \cite{article:CL, article:NW, conference:NW}, but the vulnerability analysis at the behavioral level reveals parts of a circuit that are much more vulnerable to hardware Trojan attacks \cite{conference:HS}, and removing security constraints from different tasks or communications yields different security losses \cite{article:XC}. Therefore,
% indicating that the vulnerability of .


%In this study, we focus on the design of MPSoCs through security-driven task scheduling under performance constraints, and the goal is to minimize the design vulnerability against HT attacks and the number of cores required


\textcolor{cyan}{This study extends our prior work \cite{conference:NW} which considered only performance constraints in security-aware task scheduling, by co-optimizing design vulnerability against HTs and the number of required cores.} A three-step design method that consists of task clustering, vendor assignment and task scheduling is proposed to enable MPSoC designers to achieve a high-security design with the desired performance and optimized chip area. The contributions of the paper are summarized as follows:

%Firstly, a maximum weight independent set-based method iteratively selects inter-core communications and assigns the connected tasks to the same core to reduce the performance with minimized security risks. Secondly, the numbers of cores are estimated and optimized during vendor assignment by the cluster merging-based method. Finally, tasks from the same IP vendor are scheduled together using the force-directed scheduling method \cite{article:PP}. The experimental results demonstrate the high quality of the task scheduling results in reducing both system security risks and the number of cores under performance constraints. The contributions of the paper are summarized as follows:
%\begin{enumerate}

%\item We propose a design methodology that enables MPSoC designers to make trade-offs between system security and performance. The designers can achieve the desired performance by setting it as a constraint, and obtain a high-security design with a small number of cores.

%\item To satisfy the performance constraints, a maximum weight independent set-based method is proposed to minimize the induced system security risk by iteratively assigning edges to intra-core communications. In addition, some intra-core communications will be reassigned with security constraints after the exact core speeds are determined to further reduce the system security risk.

%\item The numbers of cores are optimized in both vendor assignment and task scheduling stages, by iteratively assigning tasks that share the most common cores to the same vendor and scheduling these tasks evenly in each time period, and this enlarges the optimization space of reducing cores.

%\end{enumerate}



%The earlier conference version of this paper appeared at \cite{conference:NW}. Compared with \cite{conference:NW}, this paper has the following new contributions.

\begin{enumerate}

\item This study treats the communications between tasks with different vulnerabilities against HT attacks, and a maximum weight independent set-based method is proposed to minimize the design vulnerability under the \textcolor{purple}{deadline constraint}, by iteratively selecting a set of maximum weighted inter-core communications and assigning them to intra-core communications with much smaller delays.

\item The numbers of cores are optimized in both the vendor assignment and task scheduling stages, by iteratively assigning tasks that share the most common cores to the same vendor and scheduling these tasks evenly in each time period. Furthermore, the proposed vendor assignment method evaluates the number of cores saved when clustering tasks rather than estimating the number of cores required, which speeds up the processing and provides better results.

\item This study considers core speed variation in the task scheduling process. All tasks are first assumed to be performed with the slowest speed, and after the exact core speeds are determined, the vendor assignment will be adjusted to assign the unprotected communications with security constraints in descending order of vulnerability, which further reduces the total vulnerability of the design.

\end{enumerate}



The remainder of this paper is organized as follows. Section II describes the related literature, and Section III demonstrates the motivations and describes the optimization problem. Section IV presents the details of the proposed task scheduling method. Section V illustrates the experimental results, and Section VI provides the conclusions.







\section{Related Work}




In general, the IPs procured from third-party vendors are usually not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert Trojan logic in 3PIPs coming out of the IP house. The outsourced design and test services, as well as electronic design automation software tools supplied by different vendors, also make circuits vulnerable to malicious implants.%\cite{article:SB}.


%\begin{figure}[!t]
%\centering
%\hspace*{-0.8em}
%\includegraphics[width=7.8cm]{figure/HT_insert.pdf}
%\caption{Hardware Trojans inserted at different stages \cite{article:SB}.}
%\label{fig:3PIP_threats}
%\end{figure}


%\begin{table*}[!t]
%\renewcommand{\arraystretch}{1.0}
%\caption{Comparison with Related Work}
%\centering
%\begin{tabular}{c|c|c|c|c|c|c}
%\hline
%\hline

%\multicolumn{1}{c|}{\multirow{2}{*}{Technique}}    & Security          &Vulnerability  &\multicolumn{1}{c|}{\multirow{2}{*}{Recovery}}     &\multicolumn{1}{c|}{\multirow{2}{*}{Optimize area}}  & \multicolumn{1}{c|}{\multirow{2}{*}{Optimize delay}}  & Optimize power    \\
%    &constraints    &variation  &   &  &   &or energy   \\
%\hline
%\hline




%\cite{article:JR3}        &Yes      &No   &No     &No   &No    &Yes    \\

%\cite{conference:XC}      &Yes       &No   &Yes    &No   &No    &No    \\

%\cite{article:SR}        &Yes       &No   &No     &Yes   &Loose delay constraints    &Loose power constraints    \\

%\cite{conference:AS}      &Yes      &No   &No     &No   &No    &Yes   \\

%\cite{article:YS}        &Yes       &No   &No     &No   &Loose delay constraints    &Yes   \\



%\cite{article:CL}        &Yes       &No   &No     &No   &Tight delay constraints    &No     \\

%\cite{article:XC}        &Yes       &No   &Yes     &Loose area constraints   &Loose delay constraints    &No     \\


%This study                &Yes       &Yes   &No     &Yes   &Tight delay constraints    &No     \\

%\hline
%\hline
%\end{tabular}
%\label{table:comparison_related_works}
%\end{table*}

%\subsection{Runtime Monitoring}

%Runtime monitoring detects hardware trojans by continuously checking and verifying the behavior of side-channel signals or circuit operations, and recent researchers have focused on improving runtime hardware trojan detection accuracy. He \textit{et al.} \cite{conference:JH} developed a runtime trust evaluation framework based on on-chip electron magnetic sensors and achieved a high hardware trojan detection accuracy. Hou \textit{et al.} \cite{article:YH} guarded the concerned signals and initiated a hardware interrupt request when abnormal toggling events occurred. Kulkarni \textit{et al.} \cite{conference:AK, article:AK} proposed real-time anomaly detection frameworks based on support vector machines and K-nearest neighbors for many-core architecture. Zhao \textit{et al.} \cite{article:HZ} proposed a runtime trojan detection model that applied chaos theory to characterize side-channel parameters. Malekpour \textit{et al.} \cite{conference:AM} focused on mitigating hardware trojans with a permanent impact on the system and successfully detected hardware trojans with a slightly higher area and performance overheads.

%Researchers also observed the significant increment of resources, power and performance caused by runtime monitoring, and many solutions have been proposed to reduce these increments while maintaining high accuracy of trojan detection. Mohd \textit{et al.} \cite{article:BM} developed a low-power, low-energy and trusted design based on a smart runtime monitoring algorithm. Bao \textit{et al.} \cite{article:CB} demonstrated approaches with low hardware resource overhead for runtime trojan detection with thermal sensors. Zhu \textit{et al.} \cite{article:JZ} obtained a high effectiveness in detecting pervasive hardware security issues with little performance loss. Khalid \textit{et al.} \cite{article:FK} proposed a single power-port current acquisition block using current sensors in time-division multiplexing, which increases detection accuracy with a reduced area overhead.% Hussain \textit{et al.} \cite{conference:MH} demonstrated a runtime energy-efficient hardware trojan localization design for network-on-chips, where the authentication was activated only when the hardware trojans were triggered.

%The main advantage of security monitors is the reconfigurability to various checks without the ``golden model", but these checks are simple, and do not cover the entire circuit \cite{article:SB}. Therefore, finding all hidden trojans using security monitors still cannot be guaranteed although many studies have been proposed to improve the detection efficiency.



\subsection{Security Countermeasures}


%hardware security threats can results from unintentional design flaws [1-3], system side effects [4-7], and intended malicious design modifications [8]-[10]. They usually target security assets, such as cryptographic functions, secure architecture,


%It is extremely difficult to detect all hardware trojans in 3PIPs since there is no known golden model for 3PIPs. IP vendors usually provide source code, which may contain trojans, and a trojan can be very well hidden during normal functional operations. Besides, an attacker may distribute few codes to reduce the trojan footprint, and a large industrial-strength IP can include thousands of lines of code.



Numerous and various functional and parametric tests are required to verify whether a 3PIP contains HTs. However, testing a black-box component is difficult and time-consuming, and it is impractical to perform such an exhaustive test for a large and complex design. Therefore, a number of countermeasures have been developed against HTs at the design stage \cite{article:WH}. Hardware security primitives provide built-in self-authentication against various threats and vulnerabilities arising at different phases \cite{article:DM}. System and architectural protection techniques prevent information leakage through hardware isolation and build trusted execution environments \cite{article:NH}. Side-channel protection techniques introduce noise or randomization in the software implementation to eliminate side-channel leakage \cite{conference:HK}. IP protection techniques use hardware watermarking or steganography to protect an IP against threats \cite{article:AS1}. Machine learning-assisted designs provide defenses against security threats or enhance robustness \cite{article:SY1}.

Although HT detection methods are implemented in different design stages, finding all HTs cannot be guaranteed even with the most cutting-edge technologies. However, many applications, such as banking and military systems, have high security requirements \cite{conference:XZ}. Therefore, Trojan-tolerant design methodologies are another way to protect designs from HT attacks \cite{article:KX}.


\color{purple}
\subsection{Modular Redundancy for Trojan-tolerant Design}

The modular redundancy is an HT-tolerance strategy used in hardware design to mitigate the effects of hardware Trojan attacks during runtime \cite{article:BM}. The modular redundancy instantiates copies of the design along with voter or comparator logic, and in the case of a different output, the voting or comparator circuit determines the correct output. Researchers have implement modular redundant designs in different structures with different constraints.
Reece \textit{et al.} \cite{article:TR} identified HTs through comparisons of two similar untrusted designs by testing functional differences for all possible input combinations.
Beaumont \textit{et al.} \cite{conference:MB} developed an online HT detection architecture that implements fragmentation, replication and voting.
Shatta \textit{et al.} \cite{conference:MS} presented methodologies that detect the errors caused by HTs in 3PIPs using voters, and recover the system by replacing the errors.
Unfortunately, modular redundancy suffers from performance degradation and the overhead of extra logic, which results in increase in power, area and energy \cite{article:BM}.

\color{blue}

\subsection{\textcolor{blue}{Security-Driven Task schedules for MPSoC}}




With the modular redundant techniques, many studies have attempted to detect malicious outputs by duplicating tasks and to avoid HT collusion between IP cores from the same vendor. Incorporating the above design constraints (i.e., security constraints) in the tasks scheduling process for MPSoC that uses untrusted 3PIPs has attracted the attention of researchers.
Rajendran \textit{et al.} \cite{article:JR3} identified design constraints for HT detection to achieving detection, collusion prevention, and isolating the HT-infected 3PIP, and incorporated them during high-level synthesis.
Cui \textit{et al.} \cite{conference:XC} implemented both HT detection and error recovery at runtime for mission-critical applications, using recomputation with IP cores from different vendors.
Rajmohan \textit{et al.} \cite{article:SR} proposed an HT detection and activation prevention mechanism for high level synthesis, using a particle swarm optimization-based design space exploration method.


However, fulfilling the security constraints in task scheduling may result significant overheads in system performance, chip area, and power consumption. As every task is computed duplicately, and all communications become inter-core communications with long delays. Therefore, researchers have started to reduce these overheads along with optimizing the system security.
Cui \textit{et al.} \cite{article:XC} solved the online HT detection and recovery problem with graph-theory models that minimize the implementation cost of the design budget and area overhead.
Sengupta \textit{et al.} \cite{conference:AS} proposed a bacterial foraging optimization-based design space exploration method to find a task schedule with higher security and less hardware overhead. Sun \textit{et al.} \cite{article:YS} minimized the energy consumption while simultaneously protecting the MPSoC against the effects of HTs with security constraints.  Liu \textit{et al.}\cite{article:CL} proposed a set of task scheduling methods to reduce the increments of performance and hardware due to security constraints. Wang \textit{et al.} \cite{article:NW, conference:NW} optimized the design budget and system performance with a minimized number of unprotected communications.

\color{black}

%\textcolor{red}{Security constraints, including duplication and vendor diversity, have been recently proposed for HT protection, and high-level synthesis is the ideal level for incorporating security constraints \cite{conference:JR2}.}


%The above techniques were developed to optimize design overheads when adopting security constraints, but the optimization space is limited \cite{article:SR, conference:AS, article:YS, article:XC}.

To further optimize the design targets, some researchers also treat security constraints as loose constraints (constraints are not applied to some tasks or communications) during task scheduling, but they forget to minimize the induced design's security losses \cite{article:CL, article:NW, conference:NW}. In the chip design, HT implanters intend to attack the parts of circuits with higher vulnerabilities to create larger damages to the systems or leakage the confidential information, and the vulnerabilities of tasks or communications can differ by $10^3$ times in the same benchmark \cite{conference:HS}. This indicates that the design's performance and area can be further reduced with a small penalty of vulnerability increment by removing some ``proper'' security constraints from tasks and communications.% Therefore, we try to minimize both the circuit vulnerability against HT attacks and the chip area under the performance constraints in this study.




\section{Preliminaries and Problem Description}

%In this section, we present preliminaries and describe the problem considered in this study.

Designers may need to use untrusted 3PIP cores to build trustworthy system, where the application is partitioned into a series of tasks and these tasks are scheduled to time periods and bound to IP cores. Task scheduling mechanisms are designed to provide high security and low cost of the system, and the task scheduling problem we considered is presented in this section.

\subsection{Threat Model}



HT attacks are intended to affect normal circuit operation, potentially with catastrophic consequences in critical applications in the domains of banking, space and military \cite{article:SB1}. They can also aim to leak secret information from inside a chip through secret channels or affect the reliability of a circuit through undesired process changes \cite{article:RC}. From the perspective of the activation methods, HTs can be classified as either \textit{always-on} or \textit{conditionally triggered}. An always-on Trojan may be inserted in rarely accessed places and its footprint is kept small. Conditionally triggered Trojans hibernate initially, and are activated either by the Trojan implanter or by on-chip triggers \cite{article:CL}.

In this study, we adopt the same threat model in \cite{article:CL, article:YS}, which primarily focuses on detecting or mitigating malicious modifications. The HT may cause the task running on the malicious 3PIP to either produce incorrect output or collude with Trojans in another 3PIP core from the same vendor. As a result, the following two cases can occur at runtime: 1) \textit{Malfunction:} due to the insertion of the malicious logic into a 3PIP core, the outputs of the infected cores will be altered at some unexpected points; 2) \textit{Trojan collusion and Trojan triggering between Cores:} Trojans that are distributed on multiple cores to reduce the chance of being detected, and some malicious communication paths can also be established between cores by writing illegal values to certain secret memory space. Therefore, with these secret communication paths, a malicious logic in one core can trigger the Trojans in another core, and the active HTs in different cores can collude to cause catastrophic consequences to the systems.% Examples of the vulnerabilities caused by HTs in 3PIPs could be: information leakage, control flow violation, fault injection, side-channel leakage, and so on.}

In this study, we target embedded platforms which execute application-specific tasks and have high security requirements, and such platforms are widely-used in auto-motive, safety-critical systems, etc \cite{article:YS}. The SoC used in these systems are vulnerable to various HT attacks when the untrusted 3PIPs get integrated into this SoC. Because the HTs in 3PIPs could be passed down the design cycle to post-silicon and all the fabricated chips contain such HTs \cite{article:NP}. In such security-critical systems, designers always have prior knowledge of the application and its runtime constraints, and they can perform security-aware design to meet performance requirements and reduce the chip area. In addition, designers also have the ability to purchase 3PIPs from different vendors and implement design techniques to improve security.

\subsection{Security Constraints}

%Runtime validation approaches provide a last line of defense against potentially undetected Trojans \cite{article:SB}, and integrating security constraints in the task scheduling process enables the runtime validation using untrusted 3PIPs. The effectiveness of the security constraints in detecting the deliberate faults caused by Trojans and isolating the triggered Trojans are explained in \cite{article:JR3}. The two types of security constraints which are also introduced in \cite{conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW} handle two major types of Trojans: Those tampering program outputs and those leaking information through undesired communications. These security constraints are described as follows.% tasks are scheduled under the following two types of security constraints. %\cite{conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}.%: \textit{task duplication} and \textit{vendor diversity}.
Runtime validation approaches provide a last line of defense against potentially undetected HTs \cite{article:SB}, and integrating security constraints in the task scheduling process enables the runtime validation using untrusted 3PIPs. Two types of security constraints, which are also introduced in \cite{article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}, are used in task scheduling for runtime detection and mitigation of HT attacks: 1) \textit{duplication-with-diversity} constraints are used to detect Trojans that tamper with program outputs; 2) \textit{isolation-with-diversity} constraints are employed to prevent HT collusion between 3PIP cores such as leaking information via secret communication paths. The effectiveness of the security constraints in detecting the deliberate faults caused by HTs and isolating the active HTs are explained in \cite{article:JR3}. %These security constraints are described in the following subsections.

\subsubsection{Duplication-With-Diversity}

To detect HTs that alter the task outputs at unexpected time, each task is executed in duplicate on the cores from different vendors, and the outputs of these cores are compared by a trusted component (not designed by the third party). This type of security constraints ensures the trustworthiness of task outputs \cite{conference:DG}.

Duplication-with-diversity is set based on the fact that the probability of Trojans implanted by different attackers having the same trigger is quite low, and it is virtually impossible that two cores from different IP vendors will output the same tampered results after the same trigger input \cite{article:NV}. Therefore, the cores will not produce the same incorrect output under the same input if the malicious HT is activated, and the presence of the implanted HT is detected when there is a mismatch in the outputs.

\begin{figure}[!t]
\centering
%\hspace*{-0.8em}
%\includegraphics[width=8cm]{figure/sample_code.pdf}
\includegraphics[width=7.4cm]{figure/sample_code_analysis.pdf}
\caption{Example of vulnerability analysis.}
\label{fig:sample_code_analysis}
\end{figure}

\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.4cm]{figure/tg.png}\label{subfig:tg4}
} &\hspace*{1.0em}
\subfigure [] {
\includegraphics[width=5.0cm]{figure/constraint_example1_1.pdf}\label{subfig:asap_schedule_security}
%\includegraphics[width=5.45cm]{figure/constraint_example1.pdf}\label{subfig:asap_schedule_security}
} & \hspace*{1.0em}
\subfigure [] {
\includegraphics[width=5.3cm]{figure/performance-motivation1.pdf}\label{subfig:performance-motivation}
%\includegraphics[width=5.75cm]{figure/performance-motivation1.pdf}\label{subfig:performance-motivation}
}
\end{tabular}
\caption{Example of a task graph and its schedules. \subref{subfig:tg4} Task graph. \subref{subfig:asap_schedule_security} ASAP schedule with security constraints. \subref{subfig:performance-motivation} Schedule length optimization results.}
\label{fig:security}
\end{figure*}


\subsubsection{Isolation-With-Diversity}

To hide Trojan footprints, attackers may distribute Trojans in multiple IP cores and construct secret communication paths between IP cores to leak information or to trigger the hibernating Trojans. These secret communication paths between IP cores from the same vendor cannot be acquired by other vendors \cite{article:JR3}. Although redundant execution approaches, including voting architecture \cite{conference:MB}, dual/triple modular redundancy \cite{conference:DG}, and duplication-with-diversity, can detect HTs by comparing the outputs of cores from different vendors with the same input, they cannot cut off secret communications between multiple IP cores.


To mute undesired and potentially malicious communication paths and at the same time isolate an active Trojan from the rest of the system, data-dependent tasks must be computed by the cores fabricated from different IP vendors. This type of security constraint ensures that all the valid communications are between 3PIPs from different vendors.

%This type of security constraint can be used to isolate the triggered hardware Trojans. Because attackers always distribute Trojans in multiple IP cores and construct secret communications between IP cores to leak information or to trigger the hibernating Trojans, and these secret communications between IP cores from the same vendor cannot be acquired by other vendors \cite{article:JR3}.




\subsection{Vulnerability Analysis}



Analyzing a circuit's vulnerability against HT attacks is a key step toward trusted design, because sections of a circuit with low controllability and observability are considered potential areas for HT insertions \cite{article:JC,article:YD}. Adopted from the work presented in \cite{conference:HS}, the vulnerability analysis involves statement analysis, observability analysis and detectability analysis.

%an example of vulnerability analysis of a small behavior code is presented in Fig. \ref{fig:sample_code}.


%The notation $W[L,U]$ is developed for each signal where

The \textit{statement analysis} first measures the statement execution conditions of signals. Let $T_W(sig, l)$ be the \textit{statement weight} of signal $sig$ in line $l$, which is defined as $\frac{U-L+1}{U_O-L_O+1}$, where $L$ and $U$ are the lower and upper limits of the value range, respectively, and where $U_O$ and $L_O$ are the declared upper and lower limits of the controlling signals, respectively. Fig.\ref{fig:sample_code_analysis} shows the statement weights of signals $X$ and $Z$ with the sample codes given on the left column. For example, the range of $X$ in line 8 is from 0 to 10, which means that $L = 0$, $U = 10$, $L_O = 0$ and $U_O = 15$. Thus, the statement weight of $X$ in line 8  is $T_W(X,8)$ = $\frac{10-0+1}{15-0+1} = 0.6875$.

The \textit{observability analysis} evaluates the \textit{observability} of signals through the circuit's primary output, and it is computed by summing the statement weights of the signal that influences the target signal. The observability from signal $sig$ to its target signal $sig_t$ is denoted as $T_O(sig, sig_t)$, and the method of evaluating $T_O(sig, sig_t)$ is demonstrated via an example of calculating $T_O(X, Z)$. The $X$ and $Z$ signals both appear in lines 8 and 10, meaning that $T_O(X, Z)=0.1875 + 0.3125 = 0.5$, where 0.1875 and 0.3125 are the statement weights of $X$ in lines 8 and 10, respectively.

The \textit{detectability analysis} defines the detectability of a signal based on its statement weight and observability. The detectability of signal $sig$ in line $l$ is defined as $T_D(sig,l) = T_W(sig,l) \times T_O(sig,sig_t)$, and an example of computing $T_D(X,8)$ is given as follows. With $T_W(X,8)=0.1875$ and $T_O(X,Z)=0.5$, the detectability is calculated as $T_D(X,8) = 0.1875 \times 0.5 = 0.09375$. Similarly, the detectability of $X$ in line 10 is $T_D(X,10) = 0.3125 \times 0.5 = 0.15625$. A lower $T_D$ indicates a higher vulnerability to Trojan insertion, and the signal $X$ at line 8 has a higher vulnerability to Trojan attacks in this example. Therefore, the vulnerability of a signal (also referred to as \textit{communication})  between tasks is set as $1/T_D$ in this study.



\subsection{Motivations}







Fulfilling security constraints may incur significant overheads of performance and area, and Fig. \ref{fig:security} shows an example, where 10 tasks are sorted into 4 different types. All intra-core communication delays are ignored, and the computational times of all tasks are assumed to be 1 unit of time (\textit{ut}), which also equals their inter-core communication delays. Fig. \ref{subfig:tg4} and Fig. \ref{subfig:asap_schedule_security} show the task graph and its as-soon-as-possible (ASAP) task schedule with security constraints, where tasks colored white, gray, and pink are assigned to the 1st, 2nd and 3rd vendors, respectively. The duplicated task of $v_i$ is denoted as $v_{i'}$. Satisfying all security constraints makes the schedule length 7 \textit{ut}, and 6 cores from 3 IP vendors are required.

%Researchers have started to explore the possibility of grouping data-dependent tasks into a cluster to reduce the number of IP vendors required \cite{article:XC, article:CL, article:NW} or the system performance \cite{article:CL, article:NW, conference:NW}, which violates the vender diversity constraints. However, a pre-defined maximum permissible security loss is allowed to reduce the overheads of power, area, energy, and performance \cite{article:SR}, so designers also seek the solutions to minimize system security loss with the desired targets.


\subsubsection{Vulnerability Increment in Performance Optimization}

%To reduce the performance overhead, researchers have imposed loose security constraints during task scheduling and explored the possibility of assigning data-dependent tasks into a single core to hide the inter-core communication delay \cite{article:CL, article:NW, conference:NW}. In this study, clustering the connected data-dependent tasks into one core is denoted as \textbf{edge contraction}, and the edge that represents an intra-core communication is a \textbf{contracted edge}.
%
%Edge contraction leaves the corresponding communication without protection, and this communication is vulnerable to hardware Trojans. Traditional methods that optimize system performance either ignore the consequence security loss \cite{article:CL} or treat every communication with the same security importance \cite{article:NW, conference:NW}. However, communications have different vulnerabilities against hardware Trojan attacks, and the vulnerabilities can differ by $\times10^3$ times in the same benchmark \cite{conference:HS}.
Security constraints in design process may cause significant performance overheads (e.g., approximately 50\% performance overheads \cite{article:XC}), because all communications between tasks are inter-core communications. However, many security-critical applications also have high performance requirements, such as autonomous vehicles. To reduce the performance overheads, researchers have selectively removed isolation-with-diversity constraints from some communications, and these unprotected communications can be assigned as intra-core communications with much smaller delays \cite{article:CL, article:NW, conference:NW}. But this increases the systems' vulnerabilities because these unprotected communications are vulnerable to HT attacks. In this study, we refer to the practice of clustering the data-dependent tasks into one core as \textbf{edge contraction}, and these tasks are connected by the \textbf{contracted edge}, which can be set as intra-core communication. All the inter-core communications are assigned with isolation-with-diversity constraints to maximize the security, while the intra-core communications cannot be protected by these constraints.


Traditional methods for system performance optimization either ignore the consequent security loss \cite{article:CL} or treat every communication with the same security importance \cite{article:NW, conference:NW}. In fact, different communications have varying vulnerabilities to HT attacks, and these vulnerabilities can differ by up to $10^3$ times within the same benchmark \cite{conference:HS}. Therefore, optimizing the performance with the awareness of vulnerability variations helps to design the system with maximized security. The reasons are shown in Fig. \ref{subfig:performance-motivation}, where the vulnerabilities of communications are indicated next to the edges, and the performance optimization target is to reduce the schedule length in Fig. \ref{subfig:asap_schedule_security} by 1 \textit{ut}. Traditional methods \cite{article:NW, conference:NW} contract the fewest edges, which are $e_{1,4}$ and $e_{2,5}$ (see the 1st schedule length optimization result in Fig. \ref{subfig:performance-motivation}). However, $e_{5,8}$, $e_{6,9}$, and $e_{7,10}$ might be less vulnerable to HT attacks if compared to $e_{1,4}$ and $e_{2,5}$, and contracting these edges causes less vulnerability (see the 2nd schedule length optimization result in Fig. \ref{subfig:performance-motivation}), even though this contracts more edges.





\begin{figure}[!t]
\centering
\begin{tabular}{c}
%\hspace{-1em}
\subfigure [] {
\includegraphics[width=7.4cm]{figure/security1_1.pdf}\label{subfig:resource_req1}
%\includegraphics[width=7.4cm]{figure/security1.pdf}\label{subfig:resource_req1}
} \\
%\hspace{-1em}
\subfigure [] {
\includegraphics[width=7.4cm]{figure/security2_1.pdf}\label{subfig:resource_req2}
%\includegraphics[width=7.4cm]{figure/security2.pdf}\label{subfig:resource_req2}
}
\end{tabular}
\caption{Example of vendor assignments. \subref{subfig:resource_req1} Vendor assignment and its ASAP schedule, which requires 6 cores. \subref{subfig:resource_req2} Vendor assignment and its ASAP schedule, which requires 7 cores.}
\label{fig:resource_req_motivation}
\end{figure}





\subsubsection{Core Optimization in Vendor Assignment}

In the vendor assignment stage, all tasks are partitioned into many groups such that all tasks in a group are executed by the cores from the same vendor. Traditional methods start to optimize the number of cores after the vendor assignment stage when the number of cores required can be evaluated \cite{article:YS, article:XC, article:CL, article:NW}. However, the vendor assignment results also determine the number of cores required, and the example in Fig. \ref{fig:resource_req_motivation} explains the reason. In this example, the \textcolor{purple}{deadline constraint} is assumed to be 7 $ut$, and all security constraints are satisfied, which are represented by the blue (\textit{duplication-with-diversity}) and black (\textit{isolation-with-diversity}) lines between tasks. Fig. \ref{subfig:resource_req1} and Fig. \ref{subfig:resource_req2} give two different vendor assignments and their ASAP schedules. With the vendor assignment given in Fig. \ref{subfig:resource_req1}, the scheduling result requires 6 cores, but 7 cores are required with the vendor assignment shown in Fig. \ref{subfig:resource_req2}.






\subsection{Problem Description}

Although incorporating security constraints in the design process cannot guarantee full protection from all HT attacks, the vulnerability against HT attacks can be significantly reduced. Clustering data-dependent tasks to reduce the schedule length leaves the corresponding intra-core communications unprotected and makes these communications more vulnerable to HT attacks. In this study, the vulnerability of a communication is regarded as the reduced vulnerability after applying security constraints to this communication, and vulnerability analysis \cite{conference:HS} can be performed before our method is used to first determine the vulnerabilities of communications. Let the application task graph be $TG=(V,E)$, where $V$ and $E$ are the sets of tasks and communications, respectively; the problem of this work can be described as follows.

\begin{problem}
The inputs of this problem are the application task graph $TG$, vendor constraints $vc$, \textcolor{purple}{tight deadline of this application $t^d$}, core speeds of vendors, and vulnerability of each communication. The objective is to find a schedule with the lowest design vulnerability against HT attacks, and the number of cores required is also optimized.
\end{problem}


The design vulnerability $vul_s$ is regarded as the accumulated vulnerabilities of all unprotected communications, which can be calculated as follows:
\begin{equation}
vul_s=\sum \limits_{e\in E_c}vul(e)
\end{equation}

\noindent where $E_c$ is the set of all unprotected communications, and $vul(e)$ is the vulnerability of $e$. The following constraints must also be satisfied.





(1) For any task, its finish time must not be earlier than its start time plus the execution time, which is:
\begin{equation}
	t^f_i \geq t^s_i + exec(v_i), ~~~\forall v_i \in V
\end{equation}
where $t^s_i$, $t^f_i$ and $exec(v_i)$ are the start time and finish time and execution time of $v_i$, respectively.

\color{purple}
(2) For any task, its finish time must not exceed the tight deadline of the application, which is:
\begin{equation}
t^f_i \leq t^d,~~~ \forall v_i \in V
\end{equation}

\color{black}

(3) For any communication $e_{ij}=(v_i, v_j)$, the start time of $v_j$ should not be earlier than the finish time of $v_i$ plus the communication delay of $e_{ij}$, which is:
\begin{equation}
	t^s_j \geq t^f_i + dly(e_{ij}), ~~~\forall e_{ij} \in E
\end{equation}
where $dly(e_{ij})$ is the communication delay of $e_{ij}$.



%\begin{table}[!h]
%\renewcommand{\arraystretch}{1.06}
%\caption{Descriptions of Notations}
%\centering
%\begin{tabular}{l|p{6cm}}
%\hline
%\hline

%Notation    &Description     \\
%\hline
%\hline

%$v_i$   &The $i$-th task, and its duplicated task is $v_{i'}$.\\

%$c$   &The cluster, which consists of a set of tasks.\\

%$e_{ij}$  &The communication from task $v_i$ to task $v_j$. \\

%$vul(e)$   &The vulnerability of $e$.\\

%$vul_s$   &The design's vulnerability of a schedule.     \\

%$dly(e)$   &Inter-core communication delay of $e$.  \\

%$w(e)$   &Evaluated weight of contracting $e$.   \\

%$prob(v_i,t_j)$   &The probability that task $v_i$ is executed in time $t_j$.   \\

%$DG(c,t_j)$   &The number of tasks in cluster $c$ that are executed in time period $t_j$.   \\

%$DG_{max}(c)$   &The maximum of all $DG(c,t_j)$, which estimates the number of cores required for cluster $c$. \\

%$Merge(c_i,c_j)$   &The number of cores reduced after merging clusters $c_i$ and $c_j$.   \\

%\hline
%\hline
%\end{tabular}
%\label{table:notation}
%\end{table}




%In this work, the calculation of $risk(e)$ is determined by system designers. All possible reasons for the Trojan attack via $e$ should be considered, such as the types of connected tasks, the importance of information transmitted, and the difficulty of leaking information.

%To simplify the experiments, the core speeds of all vendors are assumed to be the same. If the core speeds of different vendors vary, this proposed method can easily be extended to fit.





\section{Security-Driven Task Scheduling Methods}

In this section, a three-step task scheduling method is proposed, and both the design vulnerability and the number of cores are optimized under \textcolor{purple}{deadline constraints}. The three steps of the proposed method are deadline-constrained task clustering, vendor assignment with \textcolor{purple}{core usage minimization}, and task scheduling. \textcolor{blue}{\cref{table:notation} gives the descriptions of the notations and acronyms used in this paper.}



\begin{table}[!h]
%\vspace{-3em}
\renewcommand{\arraystretch}{1.1}
\let\oldtablename\tablename
\let\oldthetable\thetable
\renewcommand{\tablename}{\textcolor{blue}{\oldtablename}}
\renewcommand{\thetable}{\textcolor{blue}{\oldthetable}}
\caption{Variables and acronyms used in this paper.}
\centering
\begin{tabular}{p{1.3cm}|*{8}{p{6.6cm}}}
\hline
\hline

\hspace{-0.4em}\textbf{Notation}         & \textbf{Description}    \\
\hline

\hspace{-0.4em}\textbf{Variables} & \\
$vul(e)$   & Vulnerability of edge $e$.\\

$dly(e)$      & Communication delay of edge $e$; $dly_{inter}(e)$ and $dly_{intra}(e)$ are the inter-core and intra-core communication delays of $e$, respectively.\\


$dly_{rd}(e)$         & Reduced communication delay of $e$ after contracting $e$.\\

$w_{dly}(e)$         & Total reduced delay after contracting edge $e$.\\

$w(e)$               & Weight of $e$ that evaluates both delay reduction and vulnerability increment.\\

$prob(v_i,T_j)$      & The probability that $v_i$ is executed in time $T_j$.\\

$DG(c, T_j)$      & The probabilities of all tasks in cluster $c$ in time $T_j$.\\

$DG_{max}(c)$     & The maximum of all $DG(c, T_j)$, and it estimates the required number of cores for all tasks in cluster $c$.\\

$Merge(c_i, c_j)$ & Number of cores reduced by merging clusters $c_i$ and $c_j$.\\

\hline

\hspace{-0.4em}\textbf{Acronyms} & \\
$TG/TG'$  & Task graph and its duplicate;\\
$TVG$    & Timing violated graph, consisting of all paths that violate the timing constraints;\\
$ECCG$   & Edge contraction conflict graph, representing every pair of edges in $TVG$ can be contracted simultaneously.\\
$MWIS$   & Maximum weight independent set;\\
$VCFG$   & Vendor conflict graph, representing whether two clusters must be assigned to different vendors; \\
$VCPG$   & Vendor compatible graph, representing whether two clusters can be assigned to the same vendor; \\

\hline
\hline
\end{tabular}
\label{table:notation}
\vspace{-0.5em}
\end{table}




\subsection{Deadline-Constrained Task Clustering}
%System performance is one of the key considerations for designers, and they always put several timing-critical tasks into the same core to change the inter-core communication delays into a much smaller intra-core communication delay to reduce the schedule length \cite{article:CL, article:NW, conference:NW}. However, this brings consequence security loss to the system, which must be optimized under performance constraints.

In this stage, we first apply security constraints to all tasks and communications, and then iteratively assign data-dependent tasks into the same core to meet the \textcolor{purple}{tight deadline constraints} with the vulnerability of the circuit design optimized. Typically, the cores produced by different vendors have different speeds, and the exact speed of each core is not yet determined; thus, we assume that tasks are performed with the slowest speed when optimizing the schedule length. In addition, we discuss only the method of contracting edges in $TG$, and schedule length optimization of the duplicated task graph $TG'$ can be performed in the same manner.

Source and sink nodes $s$ and $t$ are added to $TG$, and directed edges that point from $s$ to 0-indegree nodes and from 0-outdegree nodes to $t$ are also added. An example of the task graph from Fig. \ref{subfig:tg4} with $s$ and $t$ added is given in Fig. \ref{subfig:TG1}. Let $slack(v)$ be the slack time of $v$ under the deadline constraint, which is calculated as follows:
\begin{equation}
slack(v) = T_{alap}(v)-T_{asap}(v)-exec(v)
\end{equation}

\noindent where $T_{asap}(v)$ and $T_{alap}(v)$ are the ASAP and as-late-as-possible (ALAP) schedules, respectively.


The \textbf{timing violated graph} ($TVG=(V_T, E_T)$) is then constructed by all tasks with negative slacks, and it is an induced subgraph of $TG$. $V_T$ consists of $s$, $t$ and all tasks with negative slacks, and $E_T=\{(v_i,v_j)\in E, v_i\in V_T \textrm{~and~} v_j\in V_T\}$. Fig. \ref{subfig:tvg1-1} shows an example of $TVG$, where the deadline constraint is 5 $ut$ and the delay is 1 $ut$ for each edge.




%For application-specific IPs, data-dependent tasks might have to be executed by different IP cores, resulting in the corresponding edge being unable to be contracted. Therefore, we only focus on the edges that can be contracted to reduce the schedule length. In the following discussion, we assume that all edges can be contracted for simplicity.

Edge contraction is then performed to optimize the schedule length, but some data-dependent tasks have to be executed by different types of IP cores, making the corresponding edge unable to be contracted. For the edge $e_{ij}$ that can be contracted, $dly_{inter}(e_{ij})$ and $dly_{intra}(e_{ij})$ are its inter-core communication delay and intra-core communication delay, respectively. After contracting $e_{ij}$, the reduced communication delay of $e_{ij}$ is $dly_{rd}(e_{ij})$, which equals $dly_{inter}(e_{ij})-dly_{intra}(e_{ij})$, and the lengths of all paths that pass through $e_{ij}$ are also reduced by $dly_{rd}(e_{ij})$. Let the sum of the reduced schedule lengths of all paths (from $s$ to $t$) in $TVG$ be $w_{dly}(e_{ij})$, and it is calculated as follows:



\begin{eqnarray*}
%	\centering
	\begin{split}
		w_{dly}(e_{ij})=
		\begin{cases}
			path_{tvg}(e_{ij})*dly_{rd}(e_{ij}),  ~~~if~~v_i.type==v_j.type; \\[0.5em]
			 -1, ~~~$otherwise$; \\
		\end{cases}
	\end{split}
	\label{pro1}
\end{eqnarray*}

\noindent where $path_{tvg}(e_{ij})$ is the number of paths in $TVG$ that pass through $e_{ij}$. If task $v_i$ and $v_j$ are of the same type, the weight of $e_{ij}$ is $path_{tvg}(e_{ij})*dly_{rd}(e_{ij})$; otherwise, $w_{dly}(e_{ij})$ is set to -1, meaning that such edge will not be selected for edge contraction.

\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1em}
\subfigure [] {
\includegraphics[width=2.3cm]{figure/TG1.pdf}\label{subfig:TG1}
}&\hspace*{-1.2em}
\subfigure [] {
\includegraphics[width=3.03cm]{figure/tvg.pdf}\label{subfig:tvg1-1}
} &\hspace*{-1.2em}
\subfigure [] {
\includegraphics[width=2.77cm]{figure/tvg1.pdf}\label{subfig:tvg1-2}
}
\end{tabular}
\caption{Example of evaluating the timing violated graph. \subref{subfig:TG1} Task graph with $s$ and $t$. \subref{subfig:tvg1-1} $TVG$ with a timing constraint of 5 $ut$. \subref{subfig:tvg1-2} The evaluation of $w_{dly}(e)$.}
\label{fig:weight_e}
\end{figure}


Fig. \ref{subfig:tvg1-2} illustrates the $w_{dly}(e_{ij})$ and $vul(e_{ij})$ of all edges in $TVG$, which are indicated next to the edges, and all tasks are assumed to be the same type. The target in the schedule length optimization stage is to contract the edges with larger schedule length reduction $w_{dly}(e_{ij})$ and smaller vulnerability increment $vul(e_{ij})$. Therefore, the total weight that evaluates an edge $e_{ij}$ contraction, denoted as $w(e_{ij})$, can be calculated as follows:
\begin{equation}
w(e_{ij}) = \frac{w_{dly}(e_{ij})}{vul(e_{ij})}
\label{equ:weight_e}
\end{equation}

%Fig. \ref{subfig:tvg1-2} illustrates the $w_{dly}(e_{ij})$ and $risk(e_{ij})$ in $TVG$, which are indicated next to the edges.%, and the $dly(e)$ of all edges is 1 $u.t.$.% Choosing the edges with larger $w(e_{ij})$ indicates that less edges will be contracted until the performance constraint is reached.


However, not all edges can be contracted with respect to multicore parallel execution. Let $in\_edge(v)$ be the set of edges that end with $v$, and let $out\_edge(v)$ be the set of edges that start from $v$. Edges in $TG$ that belong to the same $in\_edge(v)$ or $out\_edge(v)$ are called \textbf{brother edges}. If an edge is contracted during performance optimization, all its brother edges can no longer be contracted. The reason is that contracting brother edges means the tasks that once could be executed parallel in different cores now must be executed sequentially in the same core, and this may result in an increased schedule length. For example, contracting brother edges $e_{4,6}$ and $e_{4,7}$ in Fig. \ref{subfig:tvg1-1} makes $v_6$ and $v_7$ need to be conducted sequentially in the same core, but they can be computed once concurrently in different cores.

In addition, two edges belonging to the same path in the $TVG$ should not be contracted simultaneously, and this avoids the over-optimization of the path length, which causes additional vulnerability against HT attacks. Suppose that contracting either $e_{1,4}$ or $e_{4,7}$ in Fig. \ref{subfig:tvg1-1} will make the path length smaller than the deadline constraint, and contracting $e_{1,4}$ and $e_{4,7}$ at the same time causes additional vulnerability.

Then, \textbf{edge contraction conflict graph} ($ECCG=(V_E,E_E)$) is constructed to represent whether every pair of edges in $TVG$ can be contracted simultaneously. Each vertex in $V_E$ represents an edge in $TVG$ that can be contracted, and the weight of a vertex in $V_E$ equals the weight of the corresponding edge in $TVG$. Two vertices in $V_E$ are connected when their corresponding edges cannot be contracted simultaneously, under one of the following two situations:
\begin{enumerate}
\item These two edges are brother edges (with respect to the multicore parallel execution);
\item These two edges belong to the same path in $TVG$ (to prevent the over-optimization of the path length).
\end{enumerate}






\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1.0em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG1.pdf}\label{subfig:EVG1}
} &\hspace*{-1.6em}
\subfigure [] {
\includegraphics[width=2.83cm]{figure/EVG2.pdf}\label{subfig:EVG2}
} &\hspace*{-1.6em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG3.pdf}\label{subfig:EVG3}
}
\end{tabular}
\caption{Example of deadline-constrained task clustering procedure. \subref{subfig:EVG1} $TVG$ and its corresponding $ECCG$ before task clustering. \subref{subfig:EVG2} $TVG$ and its corresponding $ECCG$ after 1st iteration of task clustering. \subref{subfig:EVG3} $TVG$ and corresponding $VCG$ after 2nd iteration of task clustering.}
\label{fig:TC}
\end{figure}


The maximum weight independent set (MWIS) of $ECCG$ is calculated by the method proposed in \cite{conference:LC}, and the target is to find a set of edges with maximum weight that can be contracted simultaneously. Algorithm \ref{alg:PCTC} shows the deadline-constrained task clustering algorithm with the goal of minimizing the design vulnerability. In the first step (\textit{Lines 2-5}), $TVG$ is constructed from $TG$, and the weights of all edges in $TVG$ are evaluated. In the second step (\textit{Lines 6-10}), the weighted $ECCG$ is built, and its MWIS is calculated. In the third step (\textit{Lines 11-13}), the MWIS-selected edges in $TG$ are contracted. These steps are iteratively repeated until the deadline constraint is met.


\begin{algorithm}[!t]
\caption{\textcolor{purple}{Deadline-constrained} task clustering.}
\label{alg:PCTC}
\begin{flushleft}
{\textbf{Input:}}
application task graph, $TG$;\\
\hspace*{2.8em}deadline of the application, $t^d$.\\
{\textbf{Output:}} deadline-constrained clustering results.
\end{flushleft}
\begin{algorithmic}[1]
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 1: Construct TVG and calculate edge weights. */}}
\WHILE{$TG.schedule\_length > t^d$}
\STATE Construct $TVG$ from $TG$.
\FOR{each $e$ in $TVG$}
\STATE Calculate $w(e)$;
\ENDFOR
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 2: Construct ECCG and find the MWIS. */}}
\STATE Construct $ECCG$ from $TVG$;
\FOR{Each node $e$ in $ECCG$}
\STATE $ECCG.node\_weight(e)=w(e)$;
\ENDFOR
\STATE Calculate $MWIS$ in $ECCG$;
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 3: Contract edges based on the MWIS. */}}
\FOR{each node $e$ in $MWIS$}
    \STATE Contract the corresponding edge $e$ in $TG$;
\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}






With the vulnerabilities of communications given in Fig. \ref{subfig:tvg1-2}, an example of deadline-constrained task clustering is shown in Fig. \ref{fig:TC}, where we are about to optimize the schedule length by 2 $ut$. The $TVG$ consists of the nodes and edges with black color, and dashed lines are the contracted edges. $ECCG$ is given beneath the corresponding $TVG$, and the weight of contracting an edge is marked next to the node in $ECCG$. $TVG$ and $ECCG$ are first constructed (see Fig. \ref{subfig:EVG1}), and its MWIS is $\{e_{5,8}, e_{6,9}, e_{7,10}\}$ which is contracted in the first iteration. Then, both $TVG$ and $ECCG$ are updated as shown in Fig. \ref{subfig:EVG2}, where $e_{5,7}$ and $e_{8,10}$ are not in $ECCG$ because their brother edges $e_{5,8}$ and $e_{7,10}$ are already contracted. The MWIS of the current $ECCG$ is $\{e_{1,4}, e_{2,5}\}$, and after contracting these edges, Fig. \ref{subfig:EVG3} yields the final clustering results, with the deadline constraint satisfied.% and the corresponding $ECCG$, and $e_{5,8}$ is contracted in the final iteration.



\begin{figure*}[!t]
\centering
\begin{tabular}{cc}
\hspace*{-0.5em}
\subfigure [] {
\includegraphics[width=7.5cm,height=4.3cm]{figure/vcg_c_1.pdf}\label{subfig:vcg_c_1}
} &
\subfigure [] {
\includegraphics[width=8.0cm,height=4.5cm]{figure/vcg_c_2.pdf}\label{subfig:vcg_c_2}
} \\
\hspace*{0.6em}
\subfigure [] {
\includegraphics[width=7.8cm,height=4.3cm]{figure/vcg_c_3.pdf}\label{subfig:vcg_c_3}
} & \hspace*{-0.8em}
\subfigure [] {
\includegraphics[width=7.8cm,height=4.5cm]{figure/vcg_result.pdf}\label{subfig:vcg_c_4}
}
\end{tabular}
\caption{Example of vendor assignment. \subref{subfig:vcg_c_1} $VCFG$ and $VCPG$ derived from task clustering results. \subref{subfig:vcg_c_2} Distributions of clusters. \subref{subfig:vcg_c_3} $VCFG$ and $VCPG$ in 2nd iteration of cluster merging. \subref{subfig:vcg_c_4} Cluster merging results under vendor constraint.}
\label{fig:vc_c}
\end{figure*}




\subsection{Vendor Assignment with \textcolor{purple}{Core Usage Minimization}}

%With performance-constrained task clustering results, tasks are then assigned to IP vendors.
%This study focus on designs of MPSoCs which execute application-specific tasks, and only the tasks with the same type can be computed on the same type of cores.

For each type of 3PIP cores, the principle of vendor assignment is to iteratively cluster tasks into a number of $v^t_c$ (vendor constraint for the IP cores with type $t$) clusters, and assign each cluster with an IP vendor according to its core speed. Different from task clustering in the deadline-constrained task clustering stage that violates isolation-with-diversity, clustering (also named as \textbf{cluster merging}) in vendor assignment follows security constraints.

The \textbf{vendor conflict graph} of type $t$ ($VCFG^t=(V^t_c, E^t_{cf})$) is constructed from the deadline-constrained clustering results, and it represents whether two clusters must be assigned to different vendors. $V^t_c$ is the set of all clusters from $TG$ and $TG'$ with type $t$. A cluster is determined by the following two situations: 1) a task that is not connected by any contracted edge is regarded as a cluster; and 2) tasks that are connected to each other by contracted edges are in the same cluster, and the index of this cluster is decided by the minimum index of the tasks in this cluster. $E^t_{cf}$ is the edge set in $VCFG^t$, and if two tasks are connected by the inter-core communication under the protection of security constraints, the two clusters that contain these two tasks will be connected in $VCFG^t$. The \textbf{vendor compatible graph} ($VCPG^t=(V^t_c, E^t_{cp})$) is the complement graph of $VCFG^t$, and an edge in $E^t_{cp}$ indicates that the connected clusters can be assigned to the same vendor.


For different types of tasks, their corresponding vendor assignments are performed independently, and we assume that all tasks are with the same type in the following discussion for simplicity. The examples of vendor conflict graph and vendor compatible graph, denoted as $VCFG$ and $VCPG$, are presented in Fig. \ref{subfig:vcg_c_1}, and they are constructed from the deadline-constrained clustering results shown in Fig. \ref{subfig:EVG3}. Because the edges in $VCPG$ are too many to demonstrate, we use dashed lines to represent the remaining edges that are connected to this cluster.



The main challenge in optimizing the number of cores in the vendor assignment stage is that the vendors of tasks have not yet been determined, and therefore, the accurate number of cores from each vendor can hardly be evaluated. Inspired by the probabilistic approach in \cite{article:PP}, we also assume that the probabilities of a task on all its possible scheduling results are the same, and employ a probability-based method to analyze the number of cores required. Let $prob(v_i,T_j)$ be the probability that $v_i$ is executed in time $T_j$, and the accumulated probability of task concurrency is calculated and denoted as the \textit{distribution graph} (DG). The summation of the probabilities of all tasks in a cluster $c$ for the time period $T_j$ is denoted as $DG(c, T_j)$ and calculated as follows:
\begin{equation}
DG(c, T_j) = \sum \limits_{v_i\in c} prob(v_i, T_j)
\end{equation}



The maximum of all $DG(c, T_j), ~\forall T_j\in[1, t_d]$ is denoted as $DG_{max}(c)$, which estimates the required number of cores for all tasks in cluster $c$. Fig. \ref{subfig:vcg_c_2} presents the distribution graphs of all clusters, where the width of a task means the probability that this task will be computed at the corresponding time period. The number of cores required may be reduced by merging two clusters $c_i$ and $c_j$, which is denoted as $Merge(c_i, c_j)$, and it can be calculated as follows:
\begin{equation}
Merge(c_i, c_j) = DG_{max}(c_i) + DG_{max}(c_j) - DG_{max}(c_i+c_j)
\label{equ:weight_e2}
\end{equation}

A larger $Merge(c_i, c_j)$ indicates a higher probability that tasks in $c_i$ and $c_j$ can share the same cores, and therefore, assigning these tasks to the same IP vendor reduces the number of cores. Examples of calculating $Merge(c_2, c_3)$ and $Merge(c_2, c_7)$ are shown in Fig. \ref{subfig:vcg_c_2}. $Merge(c_2, c_3)=1+0.5-1.5=0$, which means that core reduction cannot be achieved by merging $c_2$ and $c_3$. $Merge(c_2, c_7)=1+1-1=1$, indicating that merging $c_2$ and $c_7$ may reduce one IP core.





$Merge(c_i, c_j)$ is then set as the weight of edge $(c_i, c_j)$ in $VCPG$. The edge with maximum weight is chosen, and the connected clusters are merged into one; this procedure continues until the number of clusters equals the number of vendors available. Because $VCPG$ with $O(n)$ nodes has nearly $O(n^2)$ edges, the maximum weight independent set of $VCPG$ is not used to determine the clusters to be merged due to its large time complexity.



Fig. \ref{fig:vc_c} shows an example of cluster merging procedure, where the initial $VCFG$ and $VCPG$ are shown in Fig. \ref{subfig:vcg_c_1}, and the vendor constraint is 3. The maximum weight of all edges in $VCPG$ is 1, and $c_2$ and $c_6$ in Fig. \ref{subfig:vcg_c_1} are merged into one cluster, named $c_2$. All edges that once connected to $c_2$ and $c_6$ in $VCFG$ now connect to $c_2$ in the updated $VCFG$, and the weights of edges that connect to $c_2$ are also updated. Fig. \ref{subfig:vcg_c_3} shows $VCFG$ and $VCPG$ after the 1st iteration of cluster merging. This procedure terminates when the number of clusters equals the vendor constraint, and Fig. \ref{subfig:vcg_c_4} gives the final cluster merging results, where the total estimated number of cores is 5.5.





%\begin{figure}[!t]
%\centering
%\hspace*{-0.8em}
%\includegraphics[width=8.8cm]{figure/vcg_result.pdf}
%\caption{Cluster merging results under vendor constraint.}
%\label{fig:assign_result}
%\end{figure}

\begin{algorithm}[!h]
\caption{Vendor assignment with \textcolor{purple}{core usage minimization}.}
\label{alg:VA}
{\textbf{Input:}}
deadline-constrained clustering results.\\
\hspace*{2.4em} deadline and vendor constraints, $t^d$, $vc$.\\
{\textbf{Output:}} vendor assignment.
\begin{algorithmic}[1]
\FOR{Each type of cores, whose vendor constraint is $vc^t$}
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 1: Weight VCPG edges by the potential core reduction.*/}}
\STATE Calculate $DG_{max}(c)$ for each cluster $c$ with type $t$.
\STATE Construct $VCFG^t$ and weighted $VCPG^t$;
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 2: Cluster merging for core usage minimization. */}}
\WHILE{$VCPG^t.node\_num > vc^t$}
\STATE Find the edge $e_{max}=(c_i,c_j)$ with the maximum weight in $VCPG^t$, and merge $c_i$ and $c_j$ into one cluster.
\STATE Update $VCFG^t$ and weighted $VCPG^t$,
\ENDWHILE
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 3: Assign clusters to vendors. */}}
\WHILE {Not all clusters are assigned with IP vendors}
    \STATE Assign $c_i$ to vendor $vendor_j$, where $c_i$ is an unassigned cluster with the most timing critical tasks and $vendor_j$ is the available vendor with the fastest core speed.
\ENDWHILE
\ENDFOR
\STATEx \hspace*{-\algorithmicindent}\textit{\textcolor{blue}{/* Step 4: Adjust vendor assignment considering core speed. */}}
\STATE Update $DGs$ with the determined task execution times;
\STATE $E_{cv}$ is the set consists of all intra-core communications;
\WHILE {$E_{cv}\neq \emptyset$}
\STATE Find $e\in E_{cv}$ with the largest $vul(e)$;
\IF{Setting $e$ as inter-core communication still meets $t^d$}
\STATE Assign either $source(e)$ or $target(e)$ with another vendor;
\STATE Update $DGs$;
\ENDIF
\STATE Remove $e$ from $E_{cv}$;
\ENDWHILE
\end{algorithmic}
\end{algorithm}

Then, the number of timing-critical tasks in each cluster is counted, and the clusters containing more timing-critical tasks are assigned to the vendor with faster core speeds. Some timing-critical paths may be over-optimized because all tasks are treated with the lowest core speed in the deadline-constrained task clustering stage, and we need to adjust the vendor assignment to meet more security constraints. The slacks of tasks are updated with the assigned core speeds, and every intra-core communication is checked in descending order of vulnerability $vul(e)$ to determine whether this communication can be reassigned with security constraints. An intra-core communication ($e$) can be reassigned to inter-core communication to satisfy security constraints only when all tasks in the paths that pass through $e$ have slack times no smaller than $dly_{rd}(e)$, and one of its connected tasks will be assigned to the IP vendor with the least core increment.% This procedure is named as vendor assignment adjustment in the following discussion.


\color{blue}
Algorithm \ref{alg:VA} describes the proposed vendor assignment algorithm which consists of vendor assignment and vendor adjustment stages. In the first step (\textit{Lines 2-3}), the potential core usage reduction obtained from clustering tasks is evaluated, and the corresponding weighted $VCPG$ is constructed. In the second step (\textit{Lines 4-7}), for each type $t$, tasks are merged into $vc$ clusters with consideration of core usage minimization. In the third step (\textit{Lines 8-10}), each cluster is assigned to IP vendors according to the core speed. In the fourth step (\textit{Lines 12-21}), unprotected edges are examined in descending order of vulnerability, and vendor assignments are adjusted under deadline constraints to further reduce the overall design vulnerability, accounting for variations in core speed across vendors after initial assignment.

\color{black}


\subsection{Procedure of the Proposed Task Scheduling Method}

With all security constraints satisfied, the number of IP vendors is always equal to the number of nodes in the maximum clique (denoted as \textit{maximum clique size}) of $VCFG$. However, deadline-constrained task clustering and vendor assignment may potentially increase the number of vendors required, and we must check every contracted edge if the resulting maximum clique size exceeds the vendor constraint. Computing the maximum clique size of a graph is NP-complete, and an efficient heuristic approach \cite{article:CL} is introduced. Each time after determining a contracted edge, the impact on the maximum clique size of the corresponding $VCFG$ is evaluated, and the edge is not contracted if the vendor constraint is violated. Instead, the algorithm chooses the second-best solutions.




% \begin{algorithm}[!h]
% \caption{Security-aware task scheduling with performance constraints, $task\_schedule(TG, pc, vc)$.}
% \label{alg:PCTS}
% {\textbf{Input:}} task graph, $TG$\\
% \hspace*{2.4em} performance and vendor constraints, $pc$, $vc$.\\
% %\hspace*{2.4em}  core speeds of vendors.\\
% {\textbf{Output:}} scheduling results, $TS$.
% \begin{algorithmic}[1]
% \STATE $TC=task\_cluster(TG,pc)$;
% %\STATE $TC'=task\_cluster(TG',pc)$, where $TG'$ is the duplicate of $TG$;
% \STATE $VA=vendor\_assign(TC, vc, pc)$;
% %\STATE $VA=vendor\_adjust(VA)$;
% \FOR{each vendor $vendor_i$}
%     \STATE $V_{vendor_i}$ is the set of all tasks assigned to $vendor_i$;
% %    \STATE Calculate the mobilities of tasks in $V_{vendor_i}$;
%     \STATE $FDS(V_{vendor_i}, pc)$;% using Force-directed scheduling;
% \ENDFOR
% \end{algorithmic}
% \end{algorithm}

\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{figure/overall_flow.pdf}
\caption{The overall flowchart of the proposed security-driven task scheduling.}
\label{fig:overall_flow}
\end{figure}

%After vendor assignment, tasks with the same IP vendor are scheduled together using the force-directed scheduling (FDS) method \cite{article:PP}.

\color{blue}

\cref{fig:overall_flow} gives the whole procedure of our proposed security-driven task scheduling method. First, task clustering method (refer to Algorithm 1) iteratively contracts edges to meet the deadlines with a minimized vulnerability increment; Then, vendor assignment method (refer to Algorithm 2) assigns tasks to IP vendors with core usage minimization, and the vendor assignment is further adjusted considering core speed variation. Finally, tasks from the same IP vendor are scheduled together using the force-directed scheduling method \cite{article:PP}, because it schedules tasks evenly across each time period, requiring only a small number of cores.

% first clustered to meet the performance constraint and assigned to IP vendors with a minimized number of cores required (\textit{Lines 1-2}). Then, tasks with the same IP vendor are scheduled together using the force-directed scheduling (FDS) method \cite{article:PP} (\textit{Lines 3-6}), because FDS schedules tasks evenly across each time period, requiring only a small number of cores. % In this study, two types of security constraints are considered, and when more types of security constraints are introduced, our proposed method can be easily adopted and applied.

\color{black}

Our proposed methods can also be easily adopted in the following scenario, where the number of vendors available might be less than the maximum clique size of the corresponding $VCFG$. In this situation, a vendor-constrained task clustering \cite{article:NW} is conducted before vendor assignment, so that the vendor constraint can be satisfied with a minimized number of contracted edges.% In the second scenario, application-specific IPs might not be able to support every task. For each type of IP, we first build its $VCFG$ and $VCPG$ according to the clustering results of tasks that belong to this type, and then perform the vendor assignment along with task scheduling individually.




\begin{table*}[!t]
\renewcommand{\arraystretch}{1.1}
\caption{Deadline-Constrained Task Scheduling Results.}
\centering
\begin{tabular}{c|c|c|c|c|ccccc|ccccc}
\hline
\hline
task                        &\multicolumn{1}{c|}{\multirow{2}{*}{nodes}}              &\multicolumn{1}{c|}{\multirow{2}{*}{$CCR$}}     &SL       &$t^d$      &\multicolumn{5}{c|}{$vul_s$}        &\multicolumn{5}{c}{Number of cores}       \\ \cline{6-10} \cline{11-15}
graph                       &              &          &~~($ut$)~~   &~~($ut$)~~     &~GT-B~  &~MIP-B  &~MC-B~  &~PSO-B   &~Our~      &~GT-B~  &~MIP-B  &~MC-B~  &~PSO-B  &~Our~     \\

\hline
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{robot}}   &\multicolumn{1}{c|}{\multirow{2}{*}{88}}    &0.5  &839   &671      &58.7    &54.7 &42.6 &44.2  &31.4         &12  &11 &11  &11  &11               \\
                                              &    &1.0  &1114  &892     &61.5    &58.2  &44.3 &41.9  &30.3         &12  &10 &11  &10  &10              \\
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{sparse}}  &\multicolumn{1}{c|}{\multirow{2}{*}{96}}    &0.5 &179  &143     &44.8   &41.7 &42.5  &35.8  &28.4        &18  &16 &17  &16  &16        \\
                                              &    &1.0 &236  &189     &49.5   &43.8  &43.8 &37.2  &29.3        &18  &16 &16  &16  &15            \\

\hline

\multicolumn{1}{c|}{\multirow{2}{*}{fpppp}}    &\multicolumn{1}{c|}{\multirow{2}{*}{336}}    &0.5 &1590  &1272      &34.6   &34.6  &3.27  &3.05  &2.37       &12  &10  &11  &10  &10             \\
                                               &     &1.0 &2119  &1695     &38.5   &36.8  &35.2  &31.4  &25.1       &11  &10  &10  &10  &10              \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc500}}  &\multicolumn{1}{c|}{\multirow{2}{*}{500}}    &0.5 &280 &224        &77.8     &70.5  &68.2  &62.5  &44.6      &65  &60  &62  &58  &58              \\
                                              &    &1.0  &373  &300      &83.5     &75.9 &71.9   &64.8  &49.5      &63  &58  &60  &58  &56               \\
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc1000}}  &\multicolumn{1}{c|}{\multirow{2}{*}{1000}}   &0.5 &190 &152    &105.4  &94.2 &92.5   &88.3  &74.1       &88 &82  &84  &79  &78            \\
                                               &   &1.0 &254  &203   &99.5  &96.8  &94.3  &95.8  &78.9       &81 &77  &77  &76  &74            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc2000}}  &\multicolumn{1}{c|}{\multirow{2}{*}{2000}}   &0.5 &199  &159     &74.3   &55.3 &61.8 &44.7  &33.7       &184 &172  &175  &170  &167          \\
                                               &   &1.0 &268  &214     &6.81   &52.9 &54.7 &41.2  &36.2       &180 &168  &170  &168  &164         \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc3000}}   &\multicolumn{1}{c|}{\multirow{2}{*}{3000}}  &0.5 &1336  &1069    &132.7   &115.2 &100.4 &85.3  &72.8       &67  &64 &64  &64  &62          \\
                                                &  &1.0 &1779  &1423    &115.4   &104.9 &103.9 &80.5  &67.6       &62  &56 &58  &56  &56          \\
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{rnc5000}}    &\multicolumn{1}{c|}{\multirow{2}{*}{5000}}   &0.5 &850  &680    &146.7  &135.4  &126.9  &122.1  &103.7       &132 &124  &128 &125  &122          \\
                                                 &   &1.0 &1146 &917    &152.5   &139.1 &124.3  &127.9  &112.9       &125 &118  &122 &118  &115         \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{avg.}}    &   &0.5   &  &    &84.4      &75.2    &71.0  &64.2     &51.6    &72.3 &67.4 &69.0  &66.6 &65.5       \\
                                              &   &1.0   &  &    &83.6      &76.1    &71.6  &65.1     &53.7    &69.0 &64.1 &65.5  &65.3 &62.5 \\
\hline
\hline
\end{tabular}
\label{table:PCTS}
\end{table*}








\subsection{Time Complexity Analysis}

The time complexity of the proposed method is analyzed as follows, and the input task graph has $n$ nodes and $m$ edges.

In each iteration of the deadline-constrained task clustering stage, constructing $ECCG$ from $TVG$ requires $O(m^2)$, and finding the MWIS in $ECCG$ also requires $O(m^2)$ \cite{conference:LC}. Only a constant number of iterations are conducted before reaching the deadline constraint, and finding all contracted edges requires $O(m^2)$. In addition, each time before contracting an edge, updating $VCFG$ and evaluating its impact on the maximum clique size requires $O(n^2)$, and only a limited number of edges are contracted, making its computational cost remains at $O(n^2)$. The total time complexity of deadline-constrained task clustering is $O(m^2)$ (because $O(n)\leq O(m)$).

In the vendor assignment and task scheduling stage, constructing $VCFG$ and $VCPG$ requires $O(n^2)$. In each iteration of merging clusters, $O(m)$ is required to estimate the maximum clique size, and $O(n)$ is required to update both $VCFG$ and $VCPG$. Vendor assignment requires $O(n)$ iterations of merging clusters, and its time complexity is $O(mn)$. Performing the force-directed scheduling method to schedule all tasks requires $O(n^2)$, and the total time complexity of the vendor assignment and task scheduling stage is $O(mn)$.

The sum of $O(m^2)$ and $O(mn)$ is $O(m^2)$, which is the total time complexity of the proposed method.










\section{Experimental Results}



\subsection{Experimental Setup}

All the experiments were implemented in C on a Linux Workstation with an E5 2.6-GHz CPU and 32-GB of RAM. We tested eight benchmarks from two sources\footnote{https://www.kasahara.cs.waseda.ac.jp/schedule/index.html.}: task graphs modeled from real application programs, including robot control (robot), sparse matrix solver (sparse), and SPEC fpppp (fpppp); and randomly generated task graphs (rnc500, rnc1000, rnc2000, rnc3000 and rnc5000). The numbers of nodes in the real application benchmarks range from 88 to 334, and the randomly generated task graphs are much larger, with the numbers of nodes ranging from 500 to 5000. Considering that the maximum clique sizes of most task graphs modeled from real application programs are no larger than 4 \cite{article:CL}, the maximum clique sizes of the randomly generated task graphs are 3 or 4. The vulnerabilities of communications are analyzed via the method proposed in \cite{conference:HS}, which consists of statement analysis, observability analysis and detectability analysis. Because the benchmarks do not provide the HDL source codes for statement analysis, we assume that the statement weights of all signals are one in these experiments. To simplify the experiments, all intra-core communication delays were ignored, and we set the step of the core speed differences equal to 5\% of the fastest core speed.



Our proposed method was then compared with four other methods to demonstrate its effectiveness. The first method is the ``\textit{graph theoretic-based approach}'' (\textbf{GT-B} for short) \cite{article:XC}, which uses graph-theoretic techniques to detect the security problem with security constraints, and the recovery phase is ignored in our experiments because it incurs significant area and delay overheads to the design. The second method is the ``\textit{mixed integer programming-based approach}'' (\textbf{MIP-B} for short) \cite{article:YS}, which jointly considers the energy consumption and security constraints in the MPSoC design, using a mixed integer programming model with the objective of minimizing the energy consumption. The third method is the ``\textit{min-cut-based approach}'' (\textbf{MC-B} for short) \cite{article:NW}, which boosts performance by iteratively contracting the edges selected by the max-flow min-cut algorithm, and schedules tasks with the force-directed scheduling-based method. The fourth method is the ``\textit{particle swarm optimization (PSO)-based approach}'' (\textbf{PSO-B} for short) \cite{article:SR}, which uses a PSO-based method to explore the design space, and find a resource-optimized solution with the security constraints.





\subsection{Security-Driven Task Scheduling Results}


The security-driven task scheduling results are shown in Table \ref{table:PCTS}. Column $nodes$ give the number of tasks in each task graph. The communication-to-computation ratio ($CCR$) is the ratio of the inter-core communication delay to the computational cost of the task, and two $CCRs$ (0.5 and 1.0) are tested. The deadline is set to $t^d=0.8SL$, where $SL$ is the ASAP schedule length with all security constraints satisfied. The IP vendor constraint is set to the maximum clique size of the benchmark.



The results in Table \ref{table:PCTS} show that our proposed method obtains the lowest $vul_s$ for all benchmarks. When the $CCR$ is set to 0.5, our method reduces the vulnerabilities by 32.8, 23.6, 19.4 and 12.6, respectively, compared to those of GT-B, MIP-B, MC-B and PSO-B. When the $CCR$ becomes 1.0, the vulnerabilities saved by our method are 29.9, 22.4, 17.9 and 11.4, respectively, compared to those of GT-B, MIP-B, MC-B and PSO-B. The reasons that our proposed method outperforms the other methods are as follows. GT-B developed a graph-based method to assign tasks to cores following vendor diversity, but all communications are treated equally during the scheduling. MIP-B established a set of formulations representing the data dependencies between tasks to minimize the runtime energy, and the vulnerabilities are not its first optimization target. MC-B optimized the design vulnerability by reducing the number of unprotected communications, but ignored the vulnerability variation of communications, and it might also choose brother edges to contract, resulting in a larger $vul_s$. PSO-B explores the design space to find the near-optimal solution, and the quality of its output also depends on the iteration of the algorithm.






%The comparison results of five randomly generated task graphs. The number of edges in these task graphs is much larger than the edges of \textit{robot}, \textit{sparse}, and \textit{fpppp}, and therefore, the vulnerability of each communication is relatively much smaller (refer to Equ. (\ref{equ:risk_set1})). The comparison results show that our proposed method also obtained the best results in reducing both the $vul_s$ and the number of cores.




\begin{table}[!b]
\renewcommand{\arraystretch}{1.1}
\caption{Comparisons of CPU Runtime.}
\centering
\begin{tabular}{c|c|c|c|c|c|c|c}
\hline
\hline

~task~    &\multicolumn{1}{c|}{\multirow{2}{*}{\hspace{-0.5em}nodes\hspace{-0.5em}}}     &\multicolumn{1}{c|}{\multirow{2}{*}{\hspace{-0.5em}edges\hspace{-0.5em}}}     &\multicolumn{5}{c}{average CPU runtime ($s$)}   \\  \cline{4-8}
graph   &                                            &       &GT-B     &MIP-B &MC-B   &PSO-B  &Our          \\
\hline
\hline

robot   &88   &131     &15.4     &13.5  &17.5  &221.6  &18.7 \\

sparse  &96   &67    &27.3    &21.8 &41.2   &285.6  &33.8 \\

fpppp   &334   &1145     &41.9  &232.9  &50.2  &369.2  &47.6 \\

rnc500  &500   &1910      &72.8   &926.3   &113.6 &823.5  &95.4\\

\hspace{-0.5em}rnc1000\hspace{-0.5em}  &\hspace{-0.5em}1000\hspace{-0.5em}   &3005   &176.2    &2842.7    &259.3 &3271.3  &183.5\\

\hspace{-0.5em}rnc2000\hspace{-0.5em}   &\hspace{-0.5em}2000\hspace{-0.5em}   &3930    &351.9   &3959.8   &715.7  &8661.3  &553.6 \\

\hspace{-0.5em}rnc3000\hspace{-0.5em}   &\hspace{-0.5em}3000\hspace{-0.5em}   &\hspace{-0.5em}39034\hspace{-0.5em}     &\hspace{-0.5em}1227.4\hspace{-0.5em}    &8127.3  &\hspace{-0.5em}3582.6\hspace{-0.5em} &\hspace{-0.5em}33425.6\hspace{-0.5em}  &\hspace{-0.5em}3014.9\hspace{-0.5em}\\

\hspace{-0.5em}rnc5000\hspace{-0.5em}   &\hspace{-0.5em}5000\hspace{-0.5em}   &\hspace{-0.5em}55432\hspace{-0.5em}  &\hspace{-0.5em}3626.1\hspace{-0.5em}  &\hspace{-0.5em}15412.6\hspace{-0.5em}  &\hspace{-0.5em}9004.5\hspace{-0.5em}   &\hspace{-0.5em}91423.9\hspace{-0.5em}  &\hspace{-0.8em}6764.2\hspace{-0.5em} \\

\hline
\hline
\end{tabular}
\label{table:runtime}
\end{table}








Furthermore, our proposed method obtains the fewest cores among these methods. The goal of GT-B is to detect HT attacks, and optimizing the number of cores is not considered. MIP-B minimizes the runtime energy of MPSoC, and reducing the number of cores is not the key design target. MC-B does not optimize the number of cores in the vendor assignment stage because the vendors have not yet been determined, and estimating the number of cores during vendor assignment might not be accurate. PSO-B outputs schedules with low $vul_s$ and small numbers of cores, but its CPU runtimes are much larger. Unlike MC-B, our method uses a probability-based method to evaluate the number of reduced cores during cluster merging, which reduces the computational cost and compensates for the errors caused by the probability-based method.





The CPU runtimes of these methods are compared in Table \ref{table:runtime}. For the benchmarks modeled from real applications, all of the methods can produce solutions within several minutes. \textcolor{purple}{The time complexity of our method is $O(m^2)$, meaning that the computational time is primarily decided by the scale of $m$ (the number of edges). In addition, the actual CPU runtime is also affected by the number of iterations executed in Algorithms 1 and 2 to satisfy the deadline and vendor constraints.} For the benchmarks that contain many nodes and edges, such as \textit{rnc5000} which has 5000 nodes and 55432 edges, our proposed method can output a solution within approximately 10 minutes. This finding indicates that our proposed method is applicable for most benchmarks in real practice.




\subsection{Design Vulnerability \textit{vs.} Schedule Length}

Then, the effectiveness of our method in optimizing the design vulnerability is tested, and the $CCR$ is set to 1.0 for all the benchmarks. Three deadline constraints are tested in the experiments, which are $0.95SL$, $0.9SL$ and $0.85SL$, and the corresponding design vulnerabilities are presented in the Figs. \ref{subfig:risk_0.95sl}, \ref{subfig:risk_0.9sl}, and \ref{subfig:risk_0.85sl}, respectively.

\begin{figure}[!t]
\centering
\begin{tabular}{c}
\subfigure [] {
\hspace*{-1em}
\includegraphics[width=8.4cm]{figure/95SL.pdf}\label{subfig:risk_0.95sl}
} \\ \hspace*{-1em}
\subfigure [] {
\includegraphics[width=8.4cm]{figure/90SL.pdf}\label{subfig:risk_0.9sl}
} \\ \hspace*{-1em}
\subfigure [] {
\includegraphics[width=8.4cm]{figure/85SL.pdf}\label{subfig:risk_0.85sl}
}
\end{tabular}
\caption{Comparison of design vulnerabilities under different deadlines. \subref{subfig:risk_0.95sl} Design vulnerability with $t^d$=0.95$SL$. \subref{subfig:risk_0.9sl} Design vulnerability with $t^d$=0.9$SL$. \subref{subfig:risk_0.85sl} Design vulnerability with $t^d$=0.85$SL$.}
\label{fig:system_risk}
\end{figure}

For each benchmark, our proposed method outperforms GT-B, MIP-B, MC-B and PSO-B with different deadlines. The main reason is that our proposed method minimizes the vulnerabilities in both the schedule length optimization and vendor assignment stages. When the deadline is set to 0.95$SL$, the average vulnerability of our proposed method is 5.5, and the vulnerabilities of GT-B, MIP-B, MC-B and PSO-B are 9.4, 9.1, 8.4 and 7.2, respectively. Our method also obtains better results when the deadlines are set to 0.9$SL$ and 0.85$SL$, and the corresponding vulnerabilities are 15.7 and 32.7, respectively. Furthermore, our method shows more advantages than the other methods with shorter deadlines. The vulnerabilities saved by our method are 3.9, 3.6, 2.9 and 1.7 with the deadline $t^d=0.95SL$, compared to MC-B, GT-B and PSO-B, respectively; when the deadline becomes $0.85SL$, the vulnerabilities saved by our method are 13.8, 13.2, 9.6 and 6.8, compared to MC-B, GT-B and PSO-B, respectively.

\begin{figure}[!t]
\centering
%\hspace*{-0.2em}
\includegraphics[width=8.8cm]{figure/failure_protection.pdf}
\caption{Number of failure protections under 1000 attacks.}
\label{fig:failure_protection}
\end{figure}

Furthermore, we evaluate the robustness of the designs under HT attacks to demonstrate the necessity of optimizing the vulnerabilities in task scheduling. For each benchmark, we assume that the HTs only choose one communication to attack, and the attack possibility for each communication depends on the vulnerability of the communication. The possibility to attack the communication $e$ is set to $vul(e)/Total\_vul$, where $Total\_vul$ is the accumulated vulnerabilities of all edges in the benchmark. If the attacked communication is protected with security constraints, we consider it as a successful protection; otherwise, it is a failure protection. The deadline is set to 0.85$SL$, and 1000 such attacks are conducted on each benchmark. The numbers of failure protections are presented in Fig. \ref{fig:failure_protection}, which shows that our method results in fewer failure protections than the other methods do. The average number of failure protections of our method is only 4.38, whereas the numbers of failure protections of GT-B, MIP-B, MC-B and PSO-B are 11.38, 10.75, 8.38 and 6.63, respectively.


% The results indicates the failure protections of our proposed method is still quite low under the given performance constraints.




\subsection{Comparisons of Cores Required}

Finally, the numbers of cores needed by the different methods are compared. The deadline of the application is set to \textit{SL} so that the deadline-constrained task clustering stage can be skipped, and this eliminates the impacts of deadline-constrained task clustering results on the core usages. Tables \ref{table:core_usage_loose} and \ref{table:core_usage_tight} show the numbers of cores needed, where both loose and tight vendor constraints tested.% and our method obtains the fewest cores under these two vendor constraints.




\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\caption{Numbers of Cores Required with the Loose Vendor Constraint.}
\centering
\begin{tabular}{c|c|c|ccccc}
\hline
\hline
%\multicolumn{1}{c|}{\multirow{2}{*}{task}}        &\multicolumn{1}{c|}{\multirow{2}{*}{\textit{SL}}}                   & \multicolumn{8}{c}{Tight vendor constraints}         \\  \cline{3-11}

task       &\textit{SL}     &\multicolumn{1}{c|}{\multirow{2}{*}{\hspace{-0.2em}$CLQ$\hspace{-0.2em}}}    & \multicolumn{5}{c}{Loose vendor constraints ($vc=CLQ$)}      \\   \cline{4-8}

graph                           &($ut$)          &             &GT-B   &MIP-B &MC-B  &PSO-B &Our         \\
\hline
\hline

robot              &1114    &3            &9  &9  &9 &8    &8       \\

sparse              &236    &3            &12  &12  &12 &12    &12        \\

fpppp              &2119    &3            &9  &8  &9 &8    &8         \\

rnc500            &373      &3            &45  &42  &45 &40    &38          \\

rnc1000            &254     &3            &65  &61  &63 &58    &56        \\

rnc2000           &268      &3            &145  &138  &148 &132    &130      \\

rnc3000           &1779     &4            &53  &50  &51 &48    &48        \\

rnc5000           &1146     &4            &96  &93  &95 &90    &88        \\

\hline
avg.              &         &             &54.3  &51.6  &54.0 &49.5    &48.5         \\
\hline
\hline
\end{tabular}
\label{table:core_usage_loose}
\end{table}


The loose vendor constraints are first set for all benchmarks, where the vendor constraint is set to be the maximum clique size of the corresponding $TG$. Table \ref{table:core_usage_loose} shows the results, and the column $CLQ$ gives the maximum clique size of each $TG$. The results indicate that our proposed method needs the fewest number of cores among these methods, and the average numbers of cores required by GT-B, MIP-B, MC-B, PSO-B and our method are 54.3, 51.6, 54.0, 49.5 and 48.5, respectively. GT-B ignores core optimization, MIP-B treats the chip area as the secondary optimization target, MC-B minimizes the number of cores only in the task scheduling stage, and PSO-B explores the design space with a limited number of iterations. In our method, reducing the number of cores is considered in both vendor assignment and task scheduling, which enlarges the optimization space for saving the number of cores.


\begin{table}[h]
\renewcommand{\arraystretch}{1.1}
\caption{Numbers of Cores Required with the Tight Vendor Constraint.}
\centering
\begin{tabular}{c|c|c|ccccc}
\hline
\hline
%\multicolumn{1}{c|}{\multirow{2}{*}{task}}        &\multicolumn{1}{c|}{\multirow{2}{*}{\textit{SL}}}                   & \multicolumn{8}{c}{Tight vendor constraints}         \\  \cline{3-11}

task       &\textit{SL}     &\multicolumn{1}{c|}{\multirow{2}{*}{\hspace{-0.2em}$CLQ$\hspace{-0.2em}}}       & \multicolumn{5}{c}{Tight vendor constraints ($vc=2$)}    \\   \cline{4-8}

graph                           &($ut$)          &             &GT-B   &MIP-B &MC-B  &PSO-B &Our            \\
\hline
\hline

robot              &1114    &3                &8      &7   &8  &7   &7   \\

sparse              &236    &3                &11      &10   &11  &10   &10    \\

fpppp              &2119    &3               & 7     &7   &7  &6   &6   \\

rnc500            &373      &3                &38      &38   &37  &36   &35   \\

rnc1000            &254     &3                   &51      &48   &50  &48   &46   \\

rnc2000           &268      &3                  &127      &122   &124  &118   &116   \\

rnc3000           &1779     &4                &50      &46   &48  &45   &45   \\

rnc5000           &1146     &4                &91      &87   &88  &84   &82   \\

\hline
avg.              &         &                   &47.9      &45.6   &46.6  &44.3   &43.4   \\
\hline
\hline
\end{tabular}
\label{table:core_usage_tight}
\end{table}



The tight vendor constraints are also tested because there might not be sufficient vendors for some specific IPs, and the vendor constraints of all benchmarks are set to 2. To meet the tight vendor constraints, the vendor-constrained task clustering method proposed in \cite{article:NW} is used to remove some security constraints from communications and allow the adjacent tasks to be executed on the cores from the same IP vendor. This introduces additional vulnerabilities to the designs, although fewer cores are needed under tight vendor constraints. Our method also obtains the fewest cores among these compared methods, and the average numbers of cores needed by TG-B, MIP-B, MC-B, PSO-B and our method are 47.9, 45.6, 46.6, 44.3 and 43.4, respectively.

%Because MC-B, PSO-B and our method use the same vendor-constrained task clustering, the proportions of their unprotected edges are the same. C-B ignored reducing the number of unprotected edges to meet vendor constraints, and its numbers of unprotected edges are larger. For the benchmarks \textit{rnc3000} and \textit{rnc5000}, whose task graphs contain many 4-cliques, many edges become unprotected to satisfy the vendor constraint. The number of cores required shows that our proposed method also obtained the fewest cores among these four methods, and the average numbers of cores required by MC-B, PSO-B and our proposed method are 13.47\%, 20.68\% and 21.49\% less than that of C-B, respectively.





\section{Conclusions}

In this study, a security-driven task scheduling method is proposed to reduce the performance and area overheads of implementing security constraints in the design process. The communications between data-dependent tasks are treated with different vulnerabilities against HT attacks, and a maximum weight independent set-based task clustering method is proposed to meet tight deadline while maintaining a high security level. In addition, the numbers of cores required are optimized in both the vendor assignment and task scheduling stages by assigning tasks that can share most cores to the same vendor and scheduling them evenly in each time period, which enlarges the optimization space for reducing cores. Experimental results demonstrate that our proposed method obtains the highest system security and the fewest cores among all compared methods.

%\bibliographystyle{ieicetr}% bib style
%\bibliography{}% your bib database
\begin{thebibliography}{99}% more than 9 --> 99 / less than 10 --> 9

\bibitem{article:KX}
K. Xiao, D. Forte, Y. Jin, R. Karri, S. Bhunia, and M. Tehranipoor, ``Hardware Trojans: lessons learned after one decade of research,'' \textit{ACM Transactions on Design Automation of Electronic Systems}, vol. 22, no. 1, pp. 6-29, May 2016.


\bibitem{conference:XW}
X. Wang and R. Karri, ``NumChecker: detecting kernel control-flow modifying rootkits by using hardware performance counters,'' \textit{Proc. Design Automation Conference}, pp. 1-7, May 2013.

%\bibitem{conference:XTN}
%X.T. Ngo, J.-L. Danger, S. Guilley, Z. Najm, and O. Emery, ``Hardware property checker for run-time hardware Trojan detection,'' \textit{Proc. European Conference on Circuit Theory and Design}, pp. 1-4, 2015.

\bibitem{article:SB}
S. Bhunia, M.S. Hsiao, M. Banga, and S. Narasimhan, ``Hardware Trojan attacks: threat analysis and countermeasures,'' \textit{Proceedings of the IEEE}, vol. 102, no. 8, pp. 1229-1247, Aug. 2014.

\bibitem{conference:MH}
M. Hussain, A. Malekpour, H. Guo, and S. Parameswaran, ``EETD: an energy efficient design for runtime hardware Trojan detection in untrusted network-on-chip,'' \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 345-350, 2018.


\bibitem{conference:AM1}
A. Malekpour, R. Ragel, A. Ignjatovic, and S. Parameswaran, ``DosGuard: protecting pipelined MPSoCs against hardware Trojan based DoS attacks,'' \textit{Proc. International Conference on Applications-specific Systems, Architectures and Processors}, pp. 45-52, 2017

\bibitem{conference:FK}
F. Kounelis, N. Sklavos, and P. Kitsos, ``Run-time effect by inserting hardware Trojans in combinational circuits,'' \textit{Euromicro Conference on Digital System Design}, pp. 287-290, 2017.




\bibitem{network:SS}
M.T. Rahman, Q. Shi, S. Tajik, H. Shen, D.L. Woodard, M. Tehranipoor and N. Asadizanjani, ``Physical inspection \& attacks: new frontier in hardware security,'' \textit{Proc. International Verification and Security Workshop}, pp. 93-102, 2018.

%\bibitem{conference:MM}
%M. Banga and M.S. Hsiao, ``A novel sustained vector technique for the detection of hardware Trojans,'' \textit{Proc. International Conference of VLSI Design}, pp. 327-332, 2009.

\bibitem{conference:BB}
B. Bilgic and S. Ozev, ``Guaranteed activation of capacitive Trojan triggers during post production test via supply pulsing,'' \textit{Proc. Design, Automation \& Test in Europe Conference}, pp. 993-998, 2022.

%\bibitem{conference:KX}
%K. Xiao and M. Tehranipoor, ``BISA: Built-in self-authentication for preventing hardware Trojan insertion,'' \textit{Proc. International Symposium on Hardware-Oriented Security and Trust}, pp. 45-50, 2013.

\bibitem{article:DD}
D. Deng, Y. Wang, and Y. Guo, ``Novel design strategy toward A2 Trojan detection based on built-in acceleration structure,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 12, pp. 4496-4509, Feb. 2020.

\bibitem{article:YH1}
Y. Huang, S. Bhunia, and P. Mishra, ``Scalable test generation for Trojan detection using side channel analysis,'' \textit{IEEE Transactions on Information Forensics and Security}, vol. 13, no. 11, pp. 2746-2760, Nov. 2018.

%\bibitem{article:LN}
%L. Nguyen, C. Cheng, M. Prvulovic, and A. Zaji\'{c}, ``Creating a backscattering side channel to enable detection of dormant hardware Trojans,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 27, no. 7, pp. 1561-1574, Apr. 2019.


%\bibitem{article:SY}
%S. Yang, T. Hoque, P. Chakraborty, and S. Bhunia, ``Golden-free hardware Trojan detection using self-referencing,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 30, no. 3, pp. 325-338, Mar. 2022.




\bibitem{conference:YH}
Y. Hou, H. He, K. Shamsi, Y. Jin, D. Wu, H. Wu, ``R2D2: runtime reassurance and detection of A2 Trojan,'' \textit{Proc. International Symposium on Hardware-Oriented Security and Trust}, pp. 195-200, 2018.

%\bibitem{article:SB}
%S. Bhunia, M. Abramovici, D. Agrawal, P. Bradly, M.S. Hsiao, J. Plusquellic, and M. Tehranipoor, \textit{IEEE Design \& Test}, vol. 30, no. 3, pp. 6-17, May 2013.


%\bibitem{conference:JH}
%J. He, X. Guo, H. Ma, Y. Liu, Y. Zhao, and Y. Jin, ``Runtime trust evaluation and hardware Trojan detection using on-chip EM sensors,'' \textit{Proc. Design Automation Conference}, pp. 1-6, Jun. 2020.

%\bibitem{article:YH}
%Y. Hou, H. He, K. Shamsi, Y. Jin, D. Wu and H. Wu, ``On-chip analog Trojan detection framework for microprocessor trustworthiness,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 38, no. 10, pp. 1820-1830, Oct. 2019.

%\bibitem{conference:AK}
%A. Kulkarni, Y. Pino, and T. Mohsenin, ``SVM-based real-time hardware Trojan detection for many-core platform,'' \textit{Proc. International Symposium on Quality Electronic Design}, pp. 362-367, 2016.

%\bibitem{article:AK}
%A. Kulkarni, Y. Pino, M. French, and T. Mohsenin, ``Real-time anomaly detection framework for many-core router through machine learning techniques,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 13, no. 1, pp. 10-22, Jan. 2017.

%\bibitem{article:HZ}
%H. Zhao, L. Kwiat, K.A. Kwiat, C.A. Kamhoua, and L. Njilla, ``Applying chaos theory for runtime hardware Trojan monitoring and detection,'' \textit{IEEE Transactions on Dependable and Secure Computing}, vol. 17, no. 4, pp. 716-729, Jul. 2020.

%\bibitem{conference:AM}
%A. Malekpour, R. Ragel, D. Murphy, A. Ignjatovic, and S. Parameswaran, ``Hardware Trojan detection and recovery in MPSoCs via on-line application specific testing,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 13, no. 1, pp. 10-22, Jan. 2017.

\bibitem{article:BM}
B.J. Mohd, S. Abed, T. Hayajneh, and M.H. Alshayeji, ``Run-time monitoring and validation using reverse funciton (RMVRF) for hardware Trojans detection,'' \textit{IEEE Transactions on Dependable and Secure Computing}, vol. 18, no. 6, pp. 2689-2704, Nov. 2021.

%\bibitem{article:CB}
%C. Bao, D. Forte, and A. Srivastava, ``Temperature tracking: toward robust run-time detection of hardware Trojans,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 34, no. 10, pp. 1577-1585, Oct. 2015.

%\bibitem{article:JZ}
%J. Zhu \textit{et al.}, ``Jintide: utilizing low-cost reconfigurable external monitors to substantially enhance hardware security of large-scale CPU clusters,'' \textit{IEEE Journal of Solid-State Circuits}, vol. 56, no. 8, pp. 2585-2601, Aug. 2021.

%\bibitem{article:FK}
%F. Khalid, S.R. Hasan, S. Zia, O. Hasan, F. Awwad, and M. Shafique, ``MacLeR: machine learning-based runtime hardware Trojan detection in resource-constrained IoT edge devices,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 11, pp. 3748-3761, Nov. 2020.





%\bibitem{article:SS}
%S. Sethumadhavan, A. Waksman, M. Suozzo, Y. Huang, and J. Eum, ``Trustworthy hardware from untrusted components,'' \textit{Communications of the ACM}, vol. 58, no. 9, pp. 60-71, Sep. 2015.

\bibitem{article:TR}
T. Reece and W. H. Robinson, ``Detection of hardware Trojan in third-party intellectual property using untrusted modules,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 35, no. 3, pp. 357-366, Jul. 2015.

\bibitem{conference:MB}
M. Beaumont, B. Hopkins, and T. Newby, ``SAFER PATH: security architecture using fragmented execution and replication for protection against Trojaned hardware,'' \textit{Proc. Design, Automation \& Test in Europe Conference}, pp. 1000-1005, Mar. 2012.


\bibitem{conference:MS}
M. Shatta, I. adly, H. Amer, G. Alkady, R. Daoud, S. Hamed, and S. Hatem, ``FPGA-based architectures to recover from hardware Trojan horses, single event upsets and hard failures,'' \textit{Proc. International Conference on Microelectronics}, pp. 1-4, 2020.



\bibitem{article:JR3}
J. Rajendran, O. Sinanoglu, and R. Karri, ``Building trustworthy systems using untrusted components: a high-level synthesis approach,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 24, no. 9, pp. 2946-2959, Apr. 2016.



\bibitem{conference:XC}
X. Cui et al., ``High-level synthesis for run-time hardware Trojan detection and recovery,'' \textit{Proc. Design Automation Conference}, pp. 1-6, Jun. 2014.

\bibitem{article:SR}
S. Rajmohan, N. Ramasubramanian, and N. Naganathan, ``Hybrid evolutionary design space exploration algorithm with defence against third party IP vulnerabilities,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 10, pp. 2602-2614, Oct. 2020.



\bibitem{article:XC}
X. Cui, X. Zhang, H. Yan, L. Zhang, K. Cheng, Y. Wu, and K. Wu, ``Toward building and optimizing trustworthy systems using untrusted components: a graph-theoretic perspective,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 41, no. 5, pp. 1386-1399, Oct. 2020.


%\bibitem{conference:JR2}
%J. Rajendren, H. Zhang, O. Sinanoglu, and R. Karri, ``High-level Synthesis for Security and Trust,'' \textit{Proc. International On-Line Testing Symposium}, pp. 232-233, 2013.


\bibitem{conference:AS}
A. Sengupta and S. Bhadauria, ``Untrusted third party digital IP cores: power-delay trade-off driven exploration of hardware Trojan secuired datapath during high level synthesis,'' \textit{Proc. Great Lakes Symposium on VLSI}, pp. 167-172, May 2015.

\bibitem{article:YS}
Y. Sun, G. Jiang, S.-K. Lam, and F. Ning, ``Designing energy-efficient MPSoC with untrustworthy 3PIP cores,'' \textit{IEEE Transactions on Parallel and Distributed Systems}, vol. 31, no. 1, pp. 51-63, Jan. 2020.



\bibitem{article:CL}
C. Liu, J. Rajendran, C. Yang, and R. Karri, ``Shielding heterogeneous MPSoCs from untrustworthy 3PIPs through security-driven task scheduling,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 2, no. 4, pp. 461-472, Aug. 2014.

\bibitem{article:NW}
N. Wang, S. Chen, J. Ni, X. Ling, and Y. Zhu, ``Security-aware task scheduling using untrusted components in high-level synthesis,'' \textit{IEEE Access}, vol. 6, pp. 15663-15678, Jan. 2018.

\bibitem{conference:NW}
N. Wang, M. Yao, D. Jiang, S. Chen, and Y. Zhu, ``Security-driven task scheduling for multiprocessor system-on-chips with performance constraints,'' \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 545-550, 2018.


\bibitem{conference:HS}
H. Salmani and M. Tehranipoor, ``Analyzing circuit vulnerability to hardware Trojan insertion at the behavioral level,'' \textit{IEEE International Symposium on Defect and Fault Tolerance in VLSI and Nanotechnology Systems}, pp. 190-195, 2013.





\bibitem{article:WH}
W. Hu, C.-H. Chang, A. Sengupta, S. Bhunia, R. Kastner, H. Li, ``An overview of hardware security and trust: threats, countermeasures, and design tools,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 40, no. 6, pp. 1010-1038, Jun. 2021.


%\bibitem{article:YC}
%Y. Cao, C.Q. Liu, and C.-H. Chang, ``A low power diode-clamped inverter-based strong physical unclonable function for robust and lightweight authentication,'' \textit{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol. 65, no. 11, pp. 3864-3873, Nov. 2018.

%\bibitem{article:FP}
%F. Pareschi, G. Setti, and R. Rovatti, ``Implementation and testing of high-speed CMOS true random number generators based on chaotic systems,'' \textit{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol. 57, no. 10, pp. 3124-3137, Dec. 2010.





%\bibitem{article:QS}
%Q. Shi, M.M. Tehranipoor, and D. Forte, ``Obfuscated built-in self-authentication with secure and efficient wire-lifting,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 38, no. 11, pp. 1981-1994, Nov. 2019.

\bibitem{article:DM}
D. Meng, R. Hou, G. Shi, B. Tu, A. Yu, Z. Zhu, X. Jia, Y. Wen, and Y. Yang, ``Built-in security computer: deploying security-first architecture using active security processor,'' \textit{IEEE Transactions on Computers}, vol. 69, no. 11, pp. 1571-1583, Nov. 2020.

\bibitem{article:NH}
N. Hu, M. Ye, and S. Wei, ``Surviving information leakage hardware Trojan attacks using hardware isolation,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 7, no. 2, pp. 253-261, Apr. 2019.

%\bibitem{book:TA}
%T. Alves and D. Felton, TrustZone: Integrated hardware and soft ware security-enabling trusted computing in embedded systems, ARM, Cambridge, U.K., White Paper, 2014.


\bibitem{conference:HK}
H. Kim, S. Hong, B. Preneel, and I. Verbauwhede, ``STBC: Side channel attack tolerant balanced circuit with reduced propagation delay, \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 74-79, 2017.

%\bibitem{article:SP}
%S. Patranabis, A. Chakraborty, D. Mukhopadhyay, and P.P. Chakrabarti, ``Fault space transformation: a generic approach to counter differential fault analysis and differential fault intensity analysis on AES-like block ciphers,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 12, no. 5, pp. 1092-1102, May 2017.

%\bibitem{article:AS0}
%A. Sengupta, D. Roy, and S.P. Mohanty, ``Triple-phase watermarking for reusable IP core protection during architecture synthesis,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 37, no. 4, pp. 1092-1102, Apr. 2018.

\bibitem{article:AS1}
A. Sengupta and M.Rathor, ``IP core steganography for protecting DSP kernels used in CE systems,'' \textit{IEEE Transactions on Consumer Electronics}, vol. 65, no. 4, pp. 506-515, Nov. 2019.

\bibitem{article:SY1}
S. Yu, C. Gu, W. Liu, and M. O'Neill ``Deep learning-based hardware Trojan detection with block-based netlist information extraction,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 10, no. 4, pp. 1837-1853, Oct. 2022.

%\bibitem{article:WS}
%W. Shan, S. Zhang, J. Xu, M. Lu, L. Shi, and J. Yang, ``Machine learning assisted side-channel-attack countermeasure and its application on a 28-nm AES circuit,'' IEEE Journal of Solid-State Circuits, vol. 55, no. 33, pp. 794-804, Mar. 2020.


\bibitem{conference:XZ}
X. Zhang and M. Tehranipoor, ``Case study: detecting hardware Trojans in third-party deigital IP cores,'' \textit{International Symposium on Hardware-Oritented Security and Trust}, pp. 67-70, 2011.






\bibitem{article:SB1}
S. Bhunia, M. Abramovici, D. Agrawal, P. Bradley, M.S. Hsiao, J. Plusquellic, M. Tehranipoor, ``Protection against hardware Trojan attacks: towards a comprehensive solution,'' \textit{IEEE Design \& Test}, vol. 30, no. 3,  pp. 6-17, Jun. 2013.

%\bibitem{conference:RC}
%R.S. Chakraborty, S. Narasimhan, and S. Bhunia, ``Hardware Trojan: threats and emerging solutions,'' \textit{Proc. IEEE International High Level Design Validation and Test Workshop}, pp. 166-171, 2009.

\bibitem{article:RC}
R. S. Chakraborty, S. Pagliarini, J. Mathew, S. R. Rajendran, and M. N. Devi, ``A flexible online checking technique to enhance hardware Trojan horse detectability by reliability analysis,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 5, no. 2, pp. 260-270, Apr. 2017.




\bibitem{article:NP}
N. Pundir, S. Aftabjahani, R. Cammarota, M.Tehranipoor, and F. Farahmandi,  ``Analyzing security vulnerabilities induced by high-level synthesis,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 18, no. 3, pp. 47-68, 2022.







\bibitem{conference:DG}
D. Gizopoulos \textit{et al.}, ``Architectures for online error detection and recovery in multicore processors,'' \textit{Proc. Design, Automation and Test in Europe Conference}, pp. 533-538, 2011.

\bibitem{article:NV}
N. Veeranna and B.C. Schafer, ``Hardware Trojan detection in behavioral intellectual properties (IP's) using property checking techniques,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 5, no. 4, pp. 576-585, Oct. 2017.







%\bibitem{article:MT}
%M. Tehranipoor and F. Koushanfar, ``A survey of hardware Trojan taxonomy and detection,'' \textit{IEEE Design and Test of Computers}, vol. 27, no. 1, pp. 10-25, Jan. 2010.

\bibitem{article:JC}
J. Cruz, P. Slpsk, P. Gaikwad, and S. Bhunia, ``TVF: a metric for quantifying vulnerability against hardware Trojan attacks,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 31, no. 7, pp. 969-979, Jul. 2023.



\bibitem{article:YD}
Y. Dou, C. Gu, C. Wang, W. Liu, and F. Lombardi, ``Security and approximation: vulnerabilities in approximation-aware testing,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 11, no. 1, pp. 265-271, Jan. 2023.







%\bibitem{conference:SM}
%S. Moulik, R. Devaraj, A. Sarkar, and A. Shaw,  ``A deadline-partition oritented heterogeneous multi-core schedule for periodic tasks,'' \textit{Proc. International Conference on Parallel and Distributed Computing, Applications and Technologies}, pp. 204-210, 2017.

%\bibitem{conference:SM-SMC}
%S. Moulik, Z. Das, and G. Saikia,  ``CEAT: A cluster based energy aware scheduler for real-time heterogeneous systems,'' \textit{Proc. International Conference on Systems, Man, and Cybernetics}, pp. 1815-1821, 2017.

%\bibitem{conference:YS}
%Y. Sharma and S. Moulik,  ``CETAS: A cluster based energy and temperature efficient real-time scheduler for heterogeneous platforms,'' \textit{Proc. The ACM/SIGAPP Symposium on Applied Computing}, pp. 501-509, 2017.

%\bibitem{article:YS1}
%Y. Sharma, S. Chakraborty, and S. Moulik,  ``ETA-HP: An energy and temperature-aware real-time scheduler for heterogeneous platforms,'' \textit{The Journal of Supercomputing}, vol. 78, pp. 10595-10619, 2022.

%\bibitem{article:YS2}
%Y. Sharma and S. Moulik, ``FATS-2TC: A fault tolerant real-time scheduler for energy and temperature aware heterogeneous paltforms with two types of cores,'' \textit{Microprocessors and Microsystems}, vol. 96, pp. 104744-104744, 2022.

%\bibitem{article:SM1}
%S. Moulik, ``RESET: a real-time scheduler for energy and temperature aware heterogeneous multi-core systems,'' \textit{Integration, the VLSI Journal}, vol. 77, pp. 59-69, 2021.

%\bibitem{article:SM2}
%S. Moulik, Z. Das, R. Devaraj, and S. Chakraborty, ``SEAMERS: A semi-partitioned energy-aware scheduler for heterogeneous multicore real-time systems,'' \textit{Journal of Systems Architecture}, vol. 114, pp. 101953-101953, 2021.






\bibitem{conference:LC}
L. Chang, W. Li, and W. Zhang,  ``Computing a near-maximum independent set in linear time by reducing-peeling,'' \textit{Proc. ACM International Conference on Management of Data}, pp. 1181-1196, 2017.



\bibitem{article:PP}
P.G. Paulin and J.P. Knight, ``Force-directed scheduling for the behavioral synthesis of ASIC's,''  \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 8, no. 6, pp. 661-679, Jun. 1989.



%\bibitem{article:BC}
%B. C. Schafer and Z. Wang, ``High-Level Synthesis Design Space Exploration: Past, Present, and Future," \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 10, pp. 2628-2639, Oct. 2020.

\end{thebibliography}

% biography section
%
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:

\begin{IEEEbiography}{Nan Wang}
received a B.E. degree in computer science from Nanjing University, Nanjing, China, in 2009, and M.S and Ph.D. degrees from the Graduate School of IPS, Waseda University, Japan, in 2011, and 2014, respectively. He is currently an associate professor in School of Information Science and Engineering, East China University of Science and Technology, Shanghai, China. His current research interests include VLSI design automation, low power design techniques, network-on-chip and reconfigurable architectures. Dr. Wang is a member of IEEE and IEICE.
\end{IEEEbiography}

\begin{IEEEbiography}{Lijun Lu}
received the B.E. degree in information engineering from East China University of Science and Technology, Shanghai, China, in 2024.
He is currently working toward the M.S. degree in electronic information from East China University of Science and Technology, Shanghai, China.
His current research interests include hardware Trojan detection and hardware security.
\end{IEEEbiography}

\begin{IEEEbiography}{Songping Liu}
received the B.E. degree in information engineering from East China University of Science and Technology, Shanghai, China, in 2021.
He is currently working toward the M.S. degree in electronic information from East China University of Science and Technology, Shanghai, China.
His current research interests include hardware Trojan detection and hardware security.
\end{IEEEbiography}

% if you will not have a photo at all:
%\begin{IEEEbiography}{Song Chen}
%received a B.S. degree in computer science from Xi'an Jiaotong University, Xi'an, China, in 2000, and M.S. and Ph.D. degrees in computer science from Tsinghua University, Beijing, China, in 2003 and 2005, respectively. From August 2005 to March 2009, he served as a research associate at the Graduate School of IPS, Waseda University, Japan, and from April 2009 to August 2012, he served the same university as an assistant professor. He is currently an associate professor at the Dept. of Electronic Sci. and Tech., University of Science and Technology of China (USTC). His current research interests include several aspects of VLSI physical design automation, on-chip communication system, and computer-aided design for emerging technologies. Dr. Chen is a member of IEEE and IEICE.
%\end{IEEEbiography}

\begin{IEEEbiography}{Hongqing Zhu}
received the ph.D. degree from Shanghai Jiao Tong University, Shanghai, China, in 2000. From 2003 to 2005, she was a Post-Doctoral Fellow with the Department of Biology and Medical Engineering, Southeast University, Nanjing, China. She is currently a Professor at the East China University of Science and Technology, Shanghai. Her current research interests include deep learning, pattern recognition, and information security. She is a member of IEEE and IEICE.
\end{IEEEbiography}

%\vspace{-50em}

\begin{IEEEbiography}{Yu Zhu}
received the B.S. and Ph.D. degrees in electronics and communication engineering from Nanjing University of Science and Technology, Nanjing, China, in 1995 and 1999 respectively. She is currently a professor of electronics and communication engineering in East China University of Science and Technology, Shanghai, P.R. China. In 2005, she was a research scholar in UIUC. Her current research interests include computer design automation, pattern recognition and machine learning.
\end{IEEEbiography}

\clearpage



\section*{Authors' Response}
$~~~~$We greatly appreciate the Editor's and the reviewers' insightful and scrupulous reviews of our paper. The comments provided have contributed substantially to the improvement of our manuscript. In what follows, we present the detailed explanations of how the manuscript has been revised to respond to the comments of the associate editor and the reviewers. In the previous pages, the sentences colored blue, red, purple and cyan are the modified parts.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\section*{Reviewer 1}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
The authors may consider adding a table summarizing all mathematical symbols to improve the readability of the paper.

\subsection*{Responses}

We appreciate the reviewer's valuable suggestion. To improve the readability of the paper, we have added a table summarizing key variables and acronyms at the beginning of Section 4 as \textcolor{blue}{Table \ref{table:notation}}.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\vspace{10em}


\section*{Reviewer 2}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
My only comment is that I would clearly state that this work extends some previous work from the same authors. This was already done in the Motivation section, but in third-person. I would clearly state this before the contribution in the Introduction, so that it is apparent the work extends a conference one, which is my understanding.

\subsection*{Responses}

We appreciate the reviewer's valuable suggestion. We agree that the connection to our prior work should be stated more clearly. Accordingly, we have added a statement in the Introduction to clarify that this manuscript is an extended version of our previous conference paper.

This modification can be found on the right-hand column of page 1. The added sentence, highlighted in cyan in the revised manuscript, is as follows:

\textcolor{cyan}{This study extends our prior work \cite{conference:NW} 
which considered only performance constraints in 
security-aware task scheduling, by co-optimizing 
design vulnerability against HTs and the number of 
required cores.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\vspace{10em}

\section*{Reviewer 3}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
One issue in the previous round of review is the difficulty in keeping in mind all the acronyms. Although the authors removed some unnecessary acronyms, the reviewer still thinks that it is essential to provide list of acronyms/abbreviations for ease of understanding.

\subsection*{Responses}

We thank the reviewer for this constructive feedback. We acknowledge that keeping track of acronyms can be challenging. To resolve this, we have created a dedicated table that lists key variables and acronyms at the beginning of Section 4 as \textcolor{blue}{Table \ref{table:notation}}.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 2}
In literature review, the authors may need to include a discussion and analysis on scheduling approaches specifically for MPSoCs incorporating untrusted 3PIP cores.

\subsection*{Responses}

We thank the reviewer for this valuable suggestion. To better contextualize our work, we have significantly restructured and expanded the Section 2 to include a focused discussion on scheduling approaches for MPSoCs with untrusted 3PIP cores.

Specifically, we have added two new subsections to create a more logical flow:
\begin{itemize}
    \item A new \textcolor{purple}{Section 2.2 Modular Redundancy for Trojan-tolerant Design}, has been added (highlighted in purple). This section introduces the fundamental hardware-level strategies (e.g., replication, comparison, and voting) that form the basis for security-driven scheduling, providing essential background.

    \item A new \textcolor{blue}{Section 2.3 Security-Driven Task schedules for MPSoC}, directly addresses the reviewer's comment. This section is dedicated to analyzing prior art in our specific domain. It reviews works that:
    \begin{itemize}
        \item Integrate security constraints (like duplication and vendor diversity) directly into the task scheduling flow for systems using untrusted IPs.
        \item Propose optimization techniques to mitigate the significant performance, area, and energy overheads caused by these security-driven scheduling approaches.
    \end{itemize}
\end{itemize}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 3}
Referring to Eq. (3), does the performance constraint in this work literally represent the deadline for task finish time? If so, why not directly using deadline constraints?


\subsection*{Responses}

We thank the reviewer for this insightful comment. The reviewer is correct; in our work, the term "performance constraint" was used to represent a deadline for task finish time.

To improve clarity and adopt more standard terminology, we have revised the manuscript to use \textcolor{purple}{``deadline constraint"} consistently throughout the paper. This change has been applied globally. Key examples include:
\begin{itemize}
    \item The paper's title and abstract, which now refer to \textcolor{purple}{``Deadline Constraints"}.
    
    \item The problem formulation in Section 3.5, where the input is now described as a \textcolor{purple}{``tight deadline of this application $t^d$"}.

    \item All related algorithm and section titles have also been updated, such as the title of Section 4.1, ``Deadline-Constrained Task Clustering".
\end{itemize}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\subsection*{Comment 4}
The term ``core minimization'' is to some extent awkward. Apparently, it means to achieve the lowest number of required cores. It is more appropriate to use ``core usage minimization''.

\subsection*{Responses}

We thank the reviewer for this excellent suggestion to improve the clarity of our terminology. We agree that "core usage minimization" is a more appropriate term. We have revised the manuscript accordingly, replacing all instances of ``core minimization" with \textcolor{purple}{``core usage minimization"}.

Key instances of this revision include:

\begin{itemize}
    \item The title of Section 4.2, which now reads:
    
    ``Vendor Assignment with \textcolor{purple}{Core Usage Minimization}"

    \item The overview of the methodology in the first paragraph of Section 4, which now states:

    ``...deadline-constrained task clustering, vendor assignment with \textcolor{purple}{core usage minimization}, and task scheduling."

    \item The caption for Algorithm 2, which has been updated to:

    ``Vendor assignment with \textcolor{purple}{core usage minimization}."
\end{itemize}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 5}
This paper heavily relies on pseudocodes to explain the key steps of the methodology, The authors can include flowcharts to help clarify the algorithmic flow.

\subsection*{Responses}

We appreciate this constructive feedback. To make our methodology easier to follow, we have made several improvements by adding both a high-level flowchart and more detailed in-text descriptions.

\begin{enumerate}
    \item To provide a clearer, high-level overview, we have added a new flowchart as Figure \ref{fig:overall_flow}. To guide the reader to this figure, we also inserted a new descriptive sentence at the beginning of Section 4.3, highlighted in blue:
    
    ``\textcolor{blue}{\cref{fig:overall_flow} gives the whole procedure of our proposed security-driven task scheduling method. First, task clustering method (refer to Algorithm 1) iteratively contracts edges to meet the deadlines with a minimized vulnerability increment; Then, vendor assignment method (refer to Algorithm 2) assigns tasks to IP vendors with core usage minimization, and the vendor assignment is further adjusted considering core speed variation. Finally, tasks from the same IP vendor are scheduled together using the force-directed scheduling method \cite{article:PP}, because it schedules tasks evenly across each time period, requiring only a small number of cores.}"

    \item To enhance the clarity of the pseudocode itself, we have added descriptive step-by-step comments directly into Algorithms \ref{alg:PCTC} and \ref{alg:VA}. For example, in Algorithm 1, we added:

    \textit{\textcolor{blue}{/* Step 1: Construct TVG and calculate edge weights. */}}
    
    \textit{...}
    
    \textit{\textcolor{blue}{/* Step 2: Construct ECCG and find the MWIS. */}}

    Furthermore, we added summary paragraphs in the main text to walk through the logic of each algorithm. For instance, the following blue-highlighted paragraph was added in Section 4.2 to explain the flow of Algorithm \ref{alg:VA}:
    
    ``\textcolor{blue}{Algorithm \ref{alg:VA} describes the proposed vendor assignment algorithm which consists of vendor assignment and vendor adjustment stages. In the first step... In the second step...}"
\end{enumerate}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\subsection*{Comment 6}
The authors claim a low complexity of $O(m^2)$, in which $m$ is the number of nodes. How comes that the scheduling approach takes exceptionally long execution times (regarding the CPU runtime statistics in Table 2)?

\subsection*{Responses}

We thank the reviewer for this important question regarding the relationship between the theoretical complexity and the practical runtime. We apologize if our complexity description caused any confusion. The complexity of our method is $O(m^2)$, where $m$ is the number of edges.The execution times reported in Table \ref{table:runtime}, especially for the largest benchmarks, are attributable to two main factors, which we have now clarified in the text:

\textcolor{purple}{The time complexity of our method is $O(m^2)$, meaning that the computational time is primarily decided by the scale of $m$ (the number of edges). In addition, the actual CPU runtime is also affected by the number of iterations executed in Algorithms 1 and 2 to satisfy the deadline and vendor constraints.}

The exceptionally long execution times for the largest benchmarks (e.g., rnc5000 with 5000 nodes and 55,432 edges) reported in Table \ref{table:runtime} are primarily attributable to the following reasons:
\begin{enumerate}
    \item \textbf{Benchmark Scale:} The benchmark \textit{rnc5000} is exceptionally large (5,000 tasks, 55,432 edges). While the $O(m^2)$ complexity correctly predicts that processing time will increase quadratically with the number of edges, the absolute time for a graph of this size is naturally substantial. The reported time of approximately 10 minutes is, in our view, still practically acceptable for a design-time scheduling algorithm applied to a complex MPSoC design, which is typically an offline process.
    \item \textbf{Iterative Nature of the Algorithm:} Our method is iterative. Algorithms 1 and 2 repeat until deadline and vendor constraints are met. While the number of iterations is typically a small constant, this constant can be meaningful for large graphs with tight constraints. Each iteration involves the costly $O(m^2)$ step of building and solving the MWIS on the ECCG. For a large graph requiring several iterations, the total time is effectively a multiple of $O(m^2)$.
\end{enumerate}







\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}

% that's all folks
\end{document}






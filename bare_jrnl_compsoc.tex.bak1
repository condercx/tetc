
%% bare_jrnl_compsoc.tex
%% V1.4a
%% 2014/09/17
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8a or later) with an IEEE
%% Computer Society journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE!
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_conf_compsoc.tex,
%%                    bare_jrnl_compsoc.tex, bare_jrnl_transmag.tex
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices and paper sizes can       ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/


\documentclass[10pt,journal]{IEEEtran}
\usepackage{savesym}
\usepackage{amsmath}
\savesymbol{iint}
\usepackage{txfonts}
\usepackage{graphicx}
%\usepackage{amssymb}
%\usepackage{verbatim}
\usepackage{algorithm} %format of the algorithm
\usepackage{algorithmic}
%\usepackage{algorithmic2e}
\usepackage{color}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{makecell}
%\usepackage[numbers,sort&compress]{natbib}
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[10pt,journal,compsoc]{../sty/IEEEtran}


\newtheorem{definition}{\textbf{Definition}}
\newtheorem{lemma}{\textbf{Lemma}}
\newtheorem{property}{\textbf{Property}}
\newtheorem{proof}{Proof}
\newtheorem{problem}{\textbf{Problem}}



\hyphenpenalty=7000


% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.
%
% Note that some packages require special options to format as the Computer
% Society requires. In particular, Computer Society  papers do not use
% compressed citation ranges as is done in typical IEEE papers
% (e.g., [1]-[4]). Instead, they list every citation separately in order
% (e.g., [1], [2], [3], [4]). To get the latter we need to load the cite
% package with the nocompress option which is supported by cite.sty v4.0
% and later. Note also the use of a CLASSOPTION conditional provided by
% IEEEtran.cls V1.7 and later.





% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/tex-archive/info/epslatex/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex






% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=footnotesize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a sans serif font rather
% than the serif font used in traditional IEEE formatting and thus the need
% to invoke different subfig.sty package options depending on whether
% compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Do not use the stfloats baselinefloat ability as IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/dblfloatfix/




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and
% Axel Sommerfeldt. This package may be useful when used in conjunction with
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/endfloat/
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/url/
% Basically, \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Security-Driven Task Scheduling under Performance Constraints for MPSoCs with Untrusted 3PIP Cores}
%\title{Security-Aware Task Scheduling for MPSoCs with Performance and Area Optimization}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%
%
%\IEEEcompsocitemizethanks is a special \thanks that produces the bulleted
% lists the Computer Society journals use for "first footnote" author
% affiliations. Use \IEEEcompsocthanksitem which works much like \item
% for each affiliation group. When not in compsoc mode,
% \IEEEcompsocitemizethanks becomes like \thanks and
% \IEEEcompsocthanksitem becomes a line break with idention. This
% facilitates dual compilation, although admittedly the differences in the
% desired content of \author between the different types of papers makes a
% one-size-fits-all approach a daunting prospect. For instance, compsoc
% journal papers have the author affiliations above the "Manuscript
% received ..."  text while in non-compsoc journals this is reversed. Sigh.

\author{Nan~Wang,~\IEEEmembership{Member,~IEEE,}
%        ~Manting~Yao,%~\IEEEmembership{Member,~IEEE,}
        ~Song~Chen,~\IEEEmembership{Member,~IEEE,}
        ~Hongqin~Zhu, ~\IEEEmembership{Member,~IEEE,}
        and~Yu~Zhu,~\IEEEmembership{Member,~IEEE,}

\thanks{This work was supported by the National Key R\&D Program of China under Grant 2022YFD2000400.}
\thanks{Nan Wang, Hongqin Zhu and Yu Zhu are with the School of Information Science and Engineering, East China University of Science and Technology, Shanghai, 200237, China.}% <-this % stops a space
\thanks{Song Chen is with the School of Information Science and Technology, University of Science and Technology of China, Hefei, 230026, China.}
%\thanks{Cong Hao and Takeshi Yoshimura are with the Graduate School of Information, Production and Systems, Waseda University, 808-0135, Japan.}% <-this % stops a space
}

% note the % following the last \IEEEmembership and also \thanks -
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
%
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
\markboth{Journal of \LaTeX\ Class Files,~Vol.~13, No.~9, September~2014}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Computer Society Journals}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
%
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.



% The publisher's ID mark at the bottom of the page is less important with
% Computer Society journal papers as those publications place the marks
% outside of the main text columns and, therefore, unlike regular IEEE
% journals, the available text space is not reduced by their presence.
% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2014 IEEE}
% or like this to get the Computer Society new two part style.
%\IEEEpubid{\makebox[\columnwidth]{\hfill 0000--0000/00/\$00.00~\copyright~2014 IEEE}%
%\hspace{\columnsep}\makebox[\columnwidth]{Published by the IEEE Computer Society\hfill}}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark (Computer Society jorunal
% papers don't need this extra clearance.)



% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}



% for Computer Society papers, we must declare the abstract and index terms
% PRIOR to the title within the \IEEEtitleabstractindextext IEEEtran
% command as these need to go into the title area created by \maketitle.
% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\IEEEtitleabstractindextext{%
\begin{abstract}
The high penetration of third-party intellectual property (3PIP) brings a high risk to MPSoCs, and \textcolor{red}{a set of security-driven constraints are imposed into task scheduling step} to protect MPSoCs against malicious modifications. Because of the serious performance and area overheads incurred, designers also treat these security-driven constraints as loose constraints in the design process, and achieve the design goals within a pre-defined permissible security risk. In this work, a security-driven task scheduling method is proposed to achieve a high security level under performance constraints, and the number of cores required is also optimized. Firstly, the schedule length is iteratively optimized by assigning sets of data-dependent tasks in the performance constraint-violated paths to the same core, with a maximum weight independent set-based method. Secondly, the number of cores required is analyzed during vendor assignment according to the distributions of tasks and optimized by maximizing the core sharing of tasks. Finally, tasks are scheduled to time periods using the force-directed scheduling method. Experimental results show the effectiveness of our method in reducing the numbers of cores while maintaining the system security under performance constraints.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
MPSoC, hardware trojan, task scheduling, security, third-party IP core.
\end{IEEEkeywords}}


% make the title area
\maketitle


% To allow for easy dual compilation without having to reenter the
% abstract/keywords data, the \IEEEtitleabstractindextext text will
% not be used in maketitle, but will appear (i.e., to be "transported")
% here as \IEEEdisplaynontitleabstractindextext when the compsoc
% or transmag modes are not selected <OR> if conference mode is selected
% - because all conference papers position the abstract like regular
% papers do.
\IEEEdisplaynontitleabstractindextext
% \IEEEdisplaynontitleabstractindextext has no effect when using
% compsoc or transmag under a non-conference mode.



% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}

The increased design productivity requirements for heterogeneous multiprocessor System-on-Chip (MPSoC) require the industry to procure and use the latest commercial-off-the-shelf (COTS) electronic components to track the most cutting edge technology while reducing manufacturing costs. \textcolor{red}{This has given rise to the trend of outsourcing design and fabrication of 3PIP components, that may not be trustworthy, and the hardware Trojans in these 3PIP components present high risks of malicious inclusions and data leakage in products \cite{conference:XW}. This raises security concerns \cite{article:SB} since a small hardware modification by an adversary in the 3PIP cores can compromise the whole chip \cite{conference:MH}. If such chips run time-critical applications (e.g. in autonomous vehicles), the hardware trojan attack may lead to catastrophic or life-threatening consequences \cite{conference:AM1}. Similarly, if these chips are used in information critical systems (e.g. banking), the confidentiality and integrity of the user's data can be compromised \cite{conference:FK}.}

%In particular, the growing number of mission-critical applications (e.g., finance and military) that use MPSoCs means that security is the highest priority issue \cite{article:CL, article:DM}, whereas the increasing integration of third-party Intellectual Property (3PIP) and the outsourcing of fabrication indicate that most MPSoCs are not 100\% trustworthy.



Emerging security problems bring an urgent need for detecting possible hardware Trojan attacks or muting the effects. The methods for detecting hardware Trojans can mainly be classified into the following groups: physical inspection \cite{network:SS}, functional testing \cite{conference:MM, conference:BB}, built-in tests \cite{conference:KX, article:DD}, side-channel analyses \cite{article:YH1, article:LN, article:SY}. However, it is impossible to detect advanced hardware trojans, such as A2, because of its Trojan insertion stage and software triggered mechanism \cite{conference:YH}. To safeguard against potentially undetected trojans, runtime validation approaches provide a last line of defense against trojan attacks and often attempt to contain the effect of an activated trojan \cite{article:SB}.


The runtime monitoring techniques always insert hardware sensors in circuits to check the runtime abnormal behaviors by monitoring the side channel signals or circuit operations \cite{conference:JH, article:YH}. The main challenge in runtime monitoring is that many extra circuit overheads must be added to ensure the monitoring effectiveness and accuracy even though many studies have been proposed to reduce the overheads \cite{ article:JZ, conference:MH}. However, hardware trojan may still escape these runtime monitoring techniques because too few gates are utilized, and it will not cause any thermal or power fluctuation.

\textcolor{cyan}{Design-for-trust techniques also provide comprehensive protections to circuits and verify the correctness of system functionality at runtime. Incorporating security constraints in MPSoC design process is one of the most popular design-for-trust techniques, which can mute the hardware trojan effects and enable trustworthy computations using untrusted 3PIP cores \cite{article:JR3, article:SS, article:TR, conference:MB, conference:XC, conference:JR2, conference:MS}. This is achieved by duplicating tasks and mapping them on 3PIP cores of different vendors to detect trojans that alter task outputs or mute potential trojan effects by preventing collusion between malicious 3PIP cores from the same vendor. Designing MPSoCs with these security constraints brings significant overheads of design targets, and researchers have developed a number of solutions and created trusted designs with minimal resource overheads, performance degradation and energy consumption \cite{article:SR, conference:AS, article:YS}, and some researchers start to consider security constraints as loose constraints to satisfy the design goals while maximizing the system security \cite{article:XC, article:CL, article:NW, conference:NW}.}

\textcolor{blue}{The above mentioned works focused on area optimization mainly address the problem in task scheduling stage \cite{article:SR}, and it is because that the number of cores required can only be evaluated after vendor assignment. However, vendor assignment is a prior stage of task scheduling, whose results significantly affect the area optimization results in task scheduling, and ignoring the area optimization during vendor assignments limits the area optimization results. Furthermore, these researchers treated each communications equally when optimizing the system performance \cite{article:CL, article:NW, conference:NW}, but removing security constraints from different communications causes different security loss and communications with larger security importance should have higher protection priorities\cite{article:XC}}.


In this paper, we focus on the design of MPSoCs though security-driven task scheduling, and set the desired performance as constraints. Our goal is to find a schedule with a high security level and a small number of cores required. A three-step design methodology, consisting of task clustering, vendor assignment and task scheduling, is proposed to enable MPSoC designers to achieve the desired performance by setting it as a constraint, and obtain a high-security design with a small number of cores. To satisfy the performance constraints, a maximum weight independent set-based method is proposed to minimize the induced system security risk by iteratively assigning edges to intra-core communications. Furthermore, the numbers of cores are optimized in both the vendor assignment and task scheduling stages, by iteratively assigning tasks that share the most common cores to the same vendor and scheduling these tasks evenly in each time period. The experimental results demonstrate the high quality of the task scheduling results in reducing both system security risks and the number of cores under performance constraints.

%Firstly, a maximum weight independent set-based method iteratively selects inter-core communications and assigns the connected tasks to the same core to reduce the performance with minimized security risks. Secondly, the numbers of cores are estimated and optimized during vendor assignment by the cluster merging-based method. Finally, tasks from the same IP vendor are scheduled together using the force-directed scheduling method \cite{article:PP}. The experimental results demonstrate the high quality of the task scheduling results in reducing both system security risks and the number of cores under performance constraints. The contributions of the paper are summarized as follows:
%\begin{enumerate}

%\item We propose a design methodology that enables MPSoC designers to make trade-offs between system security and performance. The designers can achieve the desired performance by setting it as a constraint, and obtain a high-security design with a small number of cores.

%\item To satisfy the performance constraints, a maximum weight independent set-based method is proposed to minimize the induced system security risk by iteratively assigning edges to intra-core communications. In addition, some intra-core communications will be reassigned with security constraints after the exact core speeds are determined to further reduce the system security risk.

%\item The numbers of cores are optimized in both vendor assignment and task scheduling stages, by iteratively assigning tasks that share the most common cores to the same vendor and scheduling these tasks evenly in each time period, and this enlarges the optimization space of reducing cores.

%\end{enumerate}



\textcolor{red}{The earlier conference version of this paper appeared at \cite{conference:NW}. Compared with \cite{conference:NW}, this paper has a number of new contributions.}

\begin{enumerate}

\item \textcolor{red}{This work treats communications with different security importance, and provides a schedule with a minimized system security risk.}

\item \textcolor{red}{Rather than assigning one task to an IP vendor each time, this vendor assignment method groups all tasks into a number of $vc$ (vendor constraint) clusters and assigns an entire cluster to an IP vendor at a time. Furthermore, this vendor assignment method evaluates the number of cores saved when clustering tasks rather than estimating the number of cores required, which speeds up the processing time and provides better results.}

\item \textcolor{red}{This work considers core speed variation in the design process. All tasks are first assumed to be performed with the slowest speed, and the vendor assignment will be adjusted after the exact core speeds are determined to further reduce the system security risk.}

\end{enumerate}



The remainder of this paper is organized as follows. Section II shows the related work, and Section III demonstrates our motivations and describes the optimization problem. Section IV presents the details of our proposed task scheduling method. Section V illustrates the experimental results, and Section VI gives the conclusions.



\begin{figure}[!t]
\centering
\hspace*{-0.8em}
\includegraphics[width=7.8cm]{figure/HT_insert.pdf}
\caption{Hardware trojans inserted by different parties at different stages of IC life cycle \cite{article:SB}.}
\label{fig:3PIP_threats}
\end{figure}



\section{Related Work}




In general, the IPs procured from third party vendors are usually not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert trojan logic in 3PIPs coming out of the IP house, and the outsourced design and test services, as well as electronic design automation software tools supplied by different vendors, also make ICs vulnerable to malicious implants (see Fig. \ref{fig:3PIP_threats})\cite{article:SB}.



\begin{table*}[!t]
\renewcommand{\arraystretch}{1.0}
\caption{\textcolor{red}{Comparison with related works}}
\centering
\begin{tabular}{c|c|c|c|c|c|c}
\hline
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{Technique}}    & \multicolumn{1}{c|}{\multirow{2}{*}{Detect Trojans}}           &Prevent collusion  &\multicolumn{1}{c|}{\multirow{2}{*}{Recovery}}     &\multicolumn{1}{c|}{\multirow{2}{*}{Optimize area}}  & \multicolumn{1}{c|}{\multirow{2}{*}{Optimize delay}}  & Optimize power    \\
    &    &malicious 3PIPs  &   &  &   &or energy   \\
\hline
\hline

%\cite{conference:JR2}     &Yes   &Yes    &No   &No     &No   &No    &No     \\


\cite{article:JR3}        &Yes      &Yes   &No     &No   &No    &Yes    \\

\cite{conference:XC}      &Yes       &No   &Yes    &No   &No    &No    \\

\cite{article:SR}        &Yes       &Yes   &No     &Yes   &Loose delay constraints    &Loose power constraints    \\

\cite{conference:AS}      &Yes      &Yes   &No     &No   &No    &Yes   \\

\cite{article:YS}        &Yes       &Yes   &No     &No   &Loose delay constraints    &Yes   \\

\cite{article:XC}        &Yes       &Yes   &Yes     &Loose area constraints   &Loose delay constraints    &No     \\

\cite{article:CL}        &Yes       &In most cases   &No     &No   &Tight delay constraints    &No     \\




This work                &Yes       &In most cases   &No     &Yes   &Tight delay constraints    &No     \\

\hline
\hline
\end{tabular}
\label{table:comparison_related_works}
\end{table*}

%\subsection{Runtime Monitoring}

%Runtime monitoring detects hardware trojans by continuously checking and verifying the behavior of side-channel signals or circuit operations, and recent researchers have focused on improving runtime hardware trojan detection accuracy. He \textit{et al.} \cite{conference:JH} developed a runtime trust evaluation framework based on on-chip electron magnetic sensors and achieved a high hardware trojan detection accuracy. Hou \textit{et al.} \cite{article:YH} guarded the concerned signals and initiated a hardware interrupt request when abnormal toggling events occurred. Kulkarni \textit{et al.} \cite{conference:AK, article:AK} proposed real-time anomaly detection frameworks based on support vector machines and K-nearest neighbors for many-core architecture. Zhao \textit{et al.} \cite{article:HZ} proposed a runtime trojan detection model that applied chaos theory to characterize side-channel parameters. Malekpour \textit{et al.} \cite{conference:AM} focused on mitigating hardware trojans with a permanent impact on the system and successfully detected hardware trojans with a slightly higher area and performance overheads.

%Researchers also observed the significant increment of resources, power and performance caused by runtime monitoring, and many solutions have been proposed to reduce these increments while maintaining high accuracy of trojan detection. Mohd \textit{et al.} \cite{article:BM} developed a low-power, low-energy and trusted design based on a smart runtime monitoring algorithm. Bao \textit{et al.} \cite{article:CB} demonstrated approaches with low hardware resource overhead for runtime trojan detection with thermal sensors. Zhu \textit{et al.} \cite{article:JZ} obtained a high effectiveness in detecting pervasive hardware security issues with little performance loss. Khalid \textit{et al.} \cite{article:FK} proposed a single power-port current acquisition block using current sensors in time-division multiplexing, which increases detection accuracy with a reduced area overhead.% Hussain \textit{et al.} \cite{conference:MH} demonstrated a runtime energy-efficient hardware trojan localization design for network-on-chips, where the authentication was activated only when the hardware trojans were triggered.

%The main advantage of security monitors is the reconfigurability to various checks without the ``golden model", but these checks are simple, and do not cover the entire circuit \cite{article:SB}. Therefore, finding all hidden trojans using security monitors still cannot be guaranteed although many studies have been proposed to improve the detection efficiency.



\subsection{Hardware Trojans and Countermeasures}


%hardware security threats can results from unintentional design flaws [1-3], system side effects [4-7], and intended malicious design modifications [8]-[10]. They usually target security assets, such as cryptographic functions, secure architecture,


%It is extremely difficult to detect all hardware trojans in 3PIPs since there is no known golden model for 3PIPs. IP vendors usually provide source code, which may contain trojans, and a trojan can be very well hidden during normal functional operations. Besides, an attacker may distribute few codes to reduce the trojan footprint, and a large industrial-strength IP can include thousands of lines of code.

\textcolor{magenta}{Hardware trojan attacks are intended to affect normal circuit operation, potentially with catastrophic consequences in critical applications in the domains of communications, banking, space and military \cite{article:SB1}. They can also aim at leaking secret information from inside a chip through covert channels or affect the reliability of an IC through undesired process changes that cause device ware-out and long-term reliability issues \cite{conference:RC}. In addition, they can be used to assist software attacks by providing hardware back-door, and make the system operate in an incorrect way, such as modifying the scheduling results of a real-time system \cite{conference:SM,conference:SM-SMC,article:SM1,article:SM2}.} \textcolor{blue}{From the perspective of the activation methods, hardware trojans can be classified as either \textit{always-on} or \textit{conditionally triggered}. An always-on trojan is inserted in rarely accessed places and its footprint is kept small. Conditionally triggered trojans hibernate initially, and are activated either by the trojan implanter or by on-chip triggers \cite{article:CL}.}

\textcolor{red}{Numerous and various functional and parametric tests are required to verify whether a 3PIP contains hardware trojans. However, testing a black-box component is very difficult and time-consuming, and it is impractical to do such an exhaustive test for a large and complex design. Therefore, a number of countermeasures have been developed against hardware Trojans at design stage \cite{article:WH}. Hardware security primitives use random number generator (TRNG) \cite{article:YC} or physical unclonable function (PUF) \cite{article:FP} to provide built-in self authentication against various threats and vulnerabilities arising at different phases of IC life cycle \cite{article:QS, article:DM}. System and architectural protection techniques prevent information leakage through shared resource \cite{conference:AA} and build trusted execution environment \cite{book:TA}. Side-channel protection techniques introduces noise or randomization in the software implementation to eliminating side-channel leakage \cite{conference:HK, article:SP}. IP protection techniques use hardware watermarking or steganography to protect an IP against threats \cite{article:AS0, article:AS1}. Machine learning-assisted designs provide defenses against hardware security threats or enhance the systems robustness \cite{conference:KH, article:WS}.}

Although hardware trojan detection methods are implemented in different design stages, finding all hardware trojans cannot be guaranteed even with the most cutting-edge technologies. \textcolor{blue}{However, many applications, such as banking and military systems, have high security requirements \cite{conference:XZ}}. Therefore, trojan-tolerant design methodologies are another way to protect designs from trojan attacks \cite{article:KX}.


\subsection{Design-for-Trust}



Design-for-trust technique uses strategies at design time to help detect hardware trojans or mute the attack effects at runtime \cite{article:JR3, article:SS}. A number of studies have been proposed to detect malicious outputs by duplicating 3PIPs and comparing their results, and to avoid collusion between parent and child tasks from the same vendor. Incorporating the above design constraints (also named security constraints) in MPSoC design process has attracted the attention of researchers.

Reecee \textit{et al.} \cite{article:TR} identified hardware trojans through comparisons of two similar untrusted designs by testing functional differences for all possible input combinations. Beaumont \textit{et al.} \cite{conference:MB} developed an online trojan detection architecture that implements fragmentation, replication, and voting. Cui \textit{et al.} \cite{conference:XC} implemented both trojan detection and fast recovery at runtime for mission-critical applications, using recomputation with IP cores from different vendors. Shatta \textit{et al.} \cite{conference:MS} presented methodologies that detect the errors triggered by hardware trojans in 3PIPs using voters, and recover the system by replacing the error.

\textcolor{blue}{Security constraints for duplication, 3PIP vendor diversity have been recently proposed for hardware trojan protection, and high-level synthesis is the ideal level for incorporating security constraints \cite{conference:JR2}}. \textcolor{red}{However, fulfilling the security constraints in task scheduling always incurs significant overheads of system performance, chip area and power of heterogeneous multicore platforms, and researchers have started to reduce these overheads of MPSoCs built from 3PIP cores in high-level synthesis. Rajmohan \textit{et al.} \cite{article:SR} proposed a PSO-based hybrid evolutionary algorithm, and Sengupta \textit{et al.} \cite{conference:AS} proposed a bacterial foraging optimization-based design space exploration method to achieve the task schedule with higher security and less hardware overheads. Sun \textit{et al.} \cite{article:YS} minimized the energy consumption while simultaneously protecting the MPSoC against the effects of hardware trojans with security constraints. Cui \textit{et al.} \cite{article:XC} solved the online hardware trojan detection and recovery problem with graph-theoretic models that minimize the implementation cost of the design budget and area overhead. Liu \textit{et al.}\cite{article:CL} proposed a set of task scheduling methods to reduce the increments of performance and hardware due to the security constraints. Wang \textit{et al.} \cite{article:NW, conference:NW} optimized the design budget and system performance with a minimized number of intra-core communications which are not protected by security constraints.}

\textcolor{blue}{The comparison between the proposed technique and other techniques that implement security constraints is summarized in Table I. The security constraints cause significant overheads of power, delay, and area \cite{article:JR3, conference:XC}, and a number of techniques were developed to optimized these overheads, but the optimization space turns to be very limited \cite{article:SR, conference:AS, article:YS, article:XC}. Recent researchers treat security constraints as loose constraints (some constraints that can be violated) to achieve tight design targets, but they forget to minimize the induced security risks \cite{article:CL, article:NW, conference:NW}. In this work, our proposed method can provide solutions with smaller circuit area under tight delay constraints. Moreover, our approach optimized system security risk, which is always ignored by the conventional approaches.}

%In this work, we provide a method that enables designers to make trade-offs between security and system performance by setting the required performance as constraints, and both the security risks and the number of cores are optimized under the given performance constraints.






\section{Preliminaries and Problem Description}

In this section, we first present the preliminaries and then describe the problem of this paper.
%At present, industry needs to procure and use the latest COTS 3PIPs to track the most cutting-edge technology while reducing the manufacturing costs, but this brings a high risk to the systems.

%\subsection{Threat Model}

%3PIP cores fall into one of the three categories: soft, firm, and hard, depending on their format when they are supplied. \textcolor{blue}{Soft IP cores are described using VHDL or Verilog, and hardware Trojans can be inserted into soft IP cores by IP vendors during IP design}.


%In general, the Register Transfer-Level (RTL) files of IPs might have been imported from third party vendors, and 3PIPs procured from IP vendors are usually not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert Trojan logic in 3PIPs coming out of the IP house, and the Trojans may modify function, deny service, or create a backdoor to leak information.% and therefore, hardware Trojan protection strategy during HLS requires attation.



%It is extremely difficult to detect all of the hardware Trojans in 3PIPs since there is no known golden model for 3PIPs. IP vendors usually provide source code, which may contain Trojans. A Trojan can be very well hidden during the normal functional operation of the 3PIP supplied as RTL code. An attacker may distribute few RTL codes so as to reduce Trojan footprint, and a large industrial-strength IP can include thousands of lines of code, resulting in identifying the Trojan in an IP to be an extremely challenging task. When a Trojan exists in an IP, all the fabricated cores will contain Trojans, and detecting all Trojans in an SoC chip is also impossible.



%At present, industry needs to procure and use the latest Commercial-Off-The-Shelf (COTS) electronic components in order to track the most cutting edge technology while reducing the manufacturing costs. However, the hardware Trojans in these COTS components present high risks of malicious inclusions and data leakage in products \cite{conference:XW2}. In the present study, we ignore the threats posed by software Trojans and only consider the protection of applications from hardware Trojans.


%3PIPs procured from IP vendors are not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert malicious logic in 3PIPs coming out of the IP house.

%In Trojaned hardware, the attacker may modify the function, deny service, or create a backdoor to leak confidential information, thereby allowing the task running on the malicious intellectual property (IP) core to either generate additional output and trigger Trojans in other IP cores from the same vendor, or to produce incorrect outputs \cite{article:CL}. To protect applications from these risks, most previous studies have either implemented hardware Trojan detection and prevention, or security-aware system level designs.

%Although hardware Trojans detection methods are implemented in different stages, finding all hardware Trojans cannot be promised even with the most cutting-edge technologies. However, many applications such as banking and military systems have high security requirements, and therefore, design-for-security methodologies that mute the hardware Trojan effects require attention.


\subsection{Threat Model}




\textcolor{cyan}{In this work, we adopt the same threat model in \cite{article:CL, article:YS}, which mainly focuses on detecting (or muting) malicious modifications. The trojan may cause the task running on the malicious 3PIP to either produce incorrect output or generate additional output to trigger trojans in another 3PIP core from the same vendor. As a result, the following two cases can occur at runtime: 1) Due to the insertion of the malicious logic into a 3PIP core, the outputs of the infected cores will be altered at some undetectable points, 2) Trojans distributed on multiple cores (in order to reduce the chance of being detected) can also form malicious communication paths where a malicious logic in one core triggers the trojans in another core using a secret communication channel.}% (e.g.,when some illegal values are written to certain memory space).


\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.9cm]{figure/tg.png}\label{subfig:tg4}
} &\hspace*{-1.0em}
\subfigure [] {
\includegraphics[width=5.4cm]{figure/constraint_example1.pdf}\label{subfig:asap_schedule_security}
} & \hspace*{-0.5em}
\subfigure [] {
\includegraphics[width=5.7cm]{figure/performance-motivation1.pdf}\label{subfig:performance-motivation}
}
\end{tabular}
\caption{Example of task graph and its schedules. \subref{subfig:tg4} Task graph. \subref{subfig:asap_schedule_security} ASAP schedule with security constraints. \subref{subfig:performance-motivation} Schedule length optimization results.}
\label{fig:security}
\end{figure*}

\subsection{Security Constraints}
\label{subsect:sec}

\textcolor{blue}{Recently proposed security constraints improves the design reliability using untrusted 3PIPs\cite{conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}, and the effectiveness of the security constraints in detecting the deliberated faults induced by trojans and isolating the triggered trojans are explained in \cite{article:JR3}}. The two types of security constraints that are commonly used are described as follows.% tasks are scheduled under the following two types of security constraints. %\cite{conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}.%: \textit{task duplication} and \textit{vendor diversity}.


\subsubsection{Duplication-With-Diversity}

Each task is duplicately executed on the cores from different vendors, and the outputs of these cores are compared by a trusted component (not designed by the third party) to ensure the trustworthiness of the comparison step \cite{conference:DG}.

Duplication-with-diversity is set based on the fact that the probability of trojans implanted by different attackers having the same trigger input is quite low, and it is virtually impossible that two cores from different IP vendors will output the same tampered results after the same trigger input \cite{article:NV}.% In the following descriptions, the duplicated task of $v_i$ is denoted as $v_{i'}$.



\subsubsection{Isolation-With-Diversity}

Data-dependent tasks are executed on the cores fabricated from different IP vendors to isolate the triggered hardware trojans.

%This type of security constraint can be used to isolate the triggered hardware Trojans. Because attackers always distribute Trojans in multiple IP cores and construct secret communications between IP cores to leak information or to trigger the hibernating Trojans, and these secret communications between IP cores from the same vendor cannot be acquired by other vendors \cite{article:JR3}.

To mute Trojan footprints, attackers always distribute Trojans in multiple IP cores and construct secret communications between IP cores to leak information or to trigger the hibernating Trojans, and these secret communications between IP cores from the same vendor cannot be acquired by other vendors \cite{article:JR3}. Although the redundant execution approaches, including voting architecture \cite{conference:MB}, dual/triple modular redundancy \cite{conference:DG}, and duplication-with-diversity, can detect the hardware Trojans by comparing the outputs of cores from different vendors with the same input, they cannot cut off secret communications between multiple IP cores. Therefore, this isolation-with-diversity is also introduced to isolate the triggered hardware trojans from the rest of the system.

%Thus the vendor diversity constraint which forces the is also introduced to isolate the triggered hardware Trojans from the rest of the system.

%To mute the Trojan footprint, the attacker always distributes Trojans in multiple IP cores and constructs secret communications between cores to leak information or to trigger the hibernating Trojans. In this study, we assume that the secret communication between cores from the same vendor cannot be acquired by other vendors and that the attackers of different vendors plant different hardware Trojans.

%In a task graph with $n$ nodes and $m$ edges, the number of task duplication constraints is $n$, and the number of vendor diversity constraints is $2m$ (both the task graph and the duplicated task graph contain $m$ vendor diversity constraints). Therefore, the number of all security constraints (denoted as $scy$) is $n+2m$.






\subsection{Motivations}




\textcolor{cyan}{Fulfilling security constraints incurs significant overheads of performance and area}, and Fig. \ref{fig:security} gives an example, where 10 tasks are sorted into 4 different types. All intra-core communication delays are ignored, and the computational times of all tasks are assumed to be 1 unit of time (\textit{ut}), which also equal their inter-core communication delays. Fig. \ref{subfig:tg4} and Fig. \ref{subfig:asap_schedule_security} show the task graph and its as-soon-as-possible (ASAP) task schedule with security constraints, where tasks colored white, gray, and pink are assigned to the 1st, 2nd, and 3rd vendors, respectively. The duplicated task of $v_i$ is denoted as $v_{i'}$. Satisfying all security constraints makes the schedule length to be 7 \textit{ut}, and 6 cores from 3 IP vendors are needed.

\textcolor{red}{In this work, we target embedded platforms which executes application-specific tasks and have high security requirements. \textcolor{cyan}{Such platforms cannot handle tasks that occur suddenly at runtime, and they are widely-used in auto-motive, safety-critical systems, etc.} In such systems, designers always have the prior knowledge of the application and its runtime constraints, which requires designers to perform security-driven customizations to meet performance and area requirements \cite{article:YS}}.

%Researchers have started to explore the possibility of grouping data-dependent tasks into a cluster to reduce the number of IP vendors required \cite{article:XC, article:CL, article:NW} or the system performance \cite{article:CL, article:NW, conference:NW}, which violates the vender diversity constraints. However, a pre-defined maximum permissible security loss is allowed to reduce the overheads of power, area, energy, and performance \cite{article:SR}, so designers also seek the solutions to minimize system security loss with the desired targets.


\subsubsection{System Risks in Performance Optimization}

\textcolor{blue}{To reduce the performance overheads, researchers imposed loose security constraints during task scheduling, and explored the possibility of assigning data-dependent tasks into a single core to hide the inter-core communication delay \cite{article:CL, article:NW, conference:NW} within a pre-defined maximum permissible security. In the following paper, clustering the connected data-dependent tasks into one core is denoted as \textbf{edge contraction}, and the edge that represents an inter-core communication is a \textbf{contracted edge}.}

\textcolor{blue}{Edge contraction brings risks to the system, and traditional methods that optimize system performance either ignored the consequence security loss \cite{article:CL}, or treated every communications with the same security importance \cite{article:NW, conference:NW}. However, different edges face different security risks \cite{article:SR, article:XC}, and the reason that security risk variation must not be ignored is illustrated by Fig. \ref{subfig:performance-motivation}, where the optimization target is to reduce the schedule length in Fig. \ref{subfig:asap_schedule_security} by 1 \textit{ut}. Traditional methods \cite{article:NW, conference:NW} contract the fewest edges, and $e_{1,4}$ and $e_{2,5}$ will be contracted (see the 1st schedule length optimization result in Fig. \ref{subfig:performance-motivation}). However, attackers may likely modify the system settings to crash the whole system or output their desired results, meaning that edges $e_{1,4}$ and $e_{2,5}$ require high-priority protection. Instead, tasks 8-10 demonstrate the results, and not only the probabilities of attacking these tasks and related communications but also the consequence system damages are much lower. Therefore, contracting $e_{5,8}$, $e_{6,9}$, and $e_{7,10}$  causes less security risks (see the 2nd schedule length optimization result in Fig. \ref{subfig:performance-motivation}), even though this contracts more edges.}





\begin{figure}[!h]
\centering
\begin{tabular}{c}
%\hspace{-1em}
\subfigure [] {
\includegraphics[width=7.5cm]{figure/security1.pdf}\label{subfig:resource_req1}
} \\
%\hspace{-1em}
\subfigure [] {
\includegraphics[width=7.5cm]{figure/security2.pdf}\label{subfig:resource_req2}
}
\end{tabular}
\caption{Example of vendor assignments. \subref{subfig:resource_req1} Vendor assignment and its ASAP schedule, which requires 6 cores. \subref{subfig:resource_req2} Vendor assignment and its ASAP schedule, which requires 7 cores.}
\label{fig:resource_req_motivation}
\end{figure}








\subsubsection{Reducing Cores in Vender Assignment}

\textcolor{blue}{Traditional methods always start to optimize the numbers of cores after vendor assignment stage when the numbers of cores required can be evaluated \cite{article:YS, article:XC, article:CL, article:NW}. However, the vendor assignment results also determine the number of cores required, and Fig. \ref{fig:resource_req_motivation} gives the example. The performance constraints is assumed to be 7 $ut$, and all security constraints are satisfied, which are represented by the blue (\textit{task duplication}) and black (\textit{vendor diversity}) lines between tasks. Fig. \ref{subfig:resource_req1} and Fig. \ref{subfig:resource_req2} give two different vendor assignments and their ASAP schedules. With the vendor assignment given in Fig. \ref{subfig:resource_req1}, the scheduling result requires 6 cores, but 7 cores are required with the vendor assignment shown in Fig. \ref{subfig:resource_req2}.}



\subsection{Problem Description}


Clustering data-dependent tasks to reduce schedule length violates the \textit{Isolation-With-Diversity}, leaving the corresponding intra-core communications unprotected. \textcolor{cyan}{Although incorporating security constraints in the design process cannot guarantee the detection of all hardware trojan attacks, the risks caused by hardware trojans can be significantly reduced. In this paper, the security risk of a intra-core communication is regarded as the reduced risk after applying security constraints to this communication, and we assume that different communications face different security risks.} The security risk of each communication is determined by the MPSoC designers, which can be evaluated by the method given in \cite{article:SR}, and communications facing larger security risks should have higher protection priorities. The problem of this paper can be described as follows.



\begin{problem}
\textcolor{blue}{The inputs of this problem are task graph $TG$, vendor and performance constraints, core speeds of vendors, and security risk of each communication. The target is to find a schedule with the least system security risk, and the number of cores required is also optimized.}
\end{problem}


The system security risk $risk_s$ is regarded as the accumulated security risks of all unprotected communications, which can be calculated as follows:
\begin{equation}
risk_s=\sum \limits_{e\in E_c}risk(e)
\end{equation}

\noindent where $E_c$ is the set of all all unprotected communications, and $risk(e)$ is the security risk that $e$ faces. \textcolor{red}{The descriptions of notations used in this work has been presented in Table \ref{table:notation}.}

\begin{table}[!h]
\renewcommand{\arraystretch}{1.06}
\caption{\textcolor{red}{Descriptions of Notations}}
\centering
\begin{tabular}{l|p{6cm}}
\hline
\hline

Notation    &Description     \\
\hline
\hline

$v_i$   &The $i$-th task, and its duplicated task is $v_{i'}$.\\

$c$   &The cluster, which consists of a set of tasks.\\

$e_{ij}$  &Communication from task $v_i$ to task $v_j$. \\

$risk(e)$   &The security risk hidden in the communication $e$.\\

$risk_s$  &The total system security risk.     \\

$dly(e)$   &The inter-core communication delay of $e$.  \\

$w(e)$   &The evaluated weight of contracting $e$.   \\

$prob(v_i,t_j)$   &The probability that task $v_i$ is executed in time $t_j$.   \\

$DG(c,t_j)$   &The number of tasks in cluster $c$ that are executed in time period $t_j$.   \\

$DG_{max}(c)$   &The maximum of all $DG(c,t_j)$, which estimates the number of cores required for cluster $c$. \\

$Merge(c_i,c_j)$   &The number of cores reduced after merging clusters $c_i$ and $c_j$.   \\

\hline
\hline
\end{tabular}
\label{table:notation}
\end{table}




%In this work, the calculation of $risk(e)$ is determined by system designers. All possible reasons for the Trojan attack via $e$ should be considered, such as the types of connected tasks, the importance of information transmitted, and the difficulty of leaking information.

%To simplify the experiments, the core speeds of all vendors are assumed to be the same. If the core speeds of different vendors vary, this proposed method can easily be extended to fit.





\section{Security-Driven Task Scheduling with Performance Constraints}

In this section, a three-step task scheduling method is proposed, and both the system security risks and the number of cores required are optimized under performance constraints. The three steps of our proposed method are performance-constrained task clustering, vender assignment with core minimization, and task scheduling.




\subsection{Performance-Constrained Task Clustering}
%System performance is one of the key considerations for designers, and they always put several timing-critical tasks into the same core to change the inter-core communication delays into a much smaller intra-core communication delay to reduce the schedule length \cite{article:CL, article:NW, conference:NW}. However, this brings consequence security loss to the system, which must be optimized under performance constraints.

In this stage, we first apply security constraints to all tasks and communications, and then iteratively assign data-dependent tasks into the same core to meet the performance constraints with an optimized system security risk. Typically, the cores produced by different vendors have different speeds, and the exact speed of each core is not determined yet, so we assume that tasks are performed with the slowest speed when optimizing the schedule length. In addition, we discuss only the method of contracting edges in $TG$, and schedule length optimization of the duplicated task graph $TG'$ can be performed in the same manner.

Source and sink nodes $s$ and $t$ are added to $TG$, and directed edges that point from $s$ to 0-indegree nodes and from 0-outdegree nodes to $t$ are also added. An example of the task graph from Fig. \ref{subfig:tg4} with $s$ and $t$ added is given in Fig. \ref{subfig:TG1}. \textcolor{cyan}{The \textbf{timing violated graph} ($TVG=(V_T, E_T)$) is then constructed by all paths from $s$ to $t$ whose lengths exceed the performance constraints, and it is an induced subgraph of $TG$}. $V_T$ consists of $s$, $t$ and all tasks with negative slacks, and $E_T=\{(v_i,v_j)\in E, v_i\in V_T \textrm{~and~} v_j\in V_T\}$. Let $slack(v)$ be the slack time of $v$ under the performance constraint, and it is calculated as follows:
\begin{equation}
slack(v) = t_{alap}(v)-t_{asap}(v)-exec(v)
\end{equation}

\noindent where $exec(v)$ is the execution time of task $v$, and $t_{asap}(v)$ and $t_{alap}(v)$ are the ASAP and as-late-as-possible (ALAP) schedules, respectively. Fig. \ref{subfig:tvg1-1} gives an example of $TVG$, where the performance constraint is 5 $ut$, and delay is 1 $ut$ for each edge.





\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1em}
\subfigure [] {
\includegraphics[width=2.3cm]{figure/TG1.pdf}\label{subfig:TG1}
}&\hspace*{-1.6em}
\subfigure [] {
\includegraphics[width=3cm]{figure/tvg.pdf}\label{subfig:tvg1-1}
} &\hspace*{-1.6em}
\subfigure [] {
\includegraphics[width=3.05cm]{figure/tvg1.pdf}\label{subfig:tvg1-2}
}
\end{tabular}
\caption{Example of evaluating the timing violated graph. \subref{subfig:TG1} Task graph with $s$ and $t$. \subref{subfig:tvg1-1} $TVG$ with a timing constraint of 5 $ut$. \subref{subfig:tvg1-2} The evaluation of $w_{dly}(e)$.}
\label{fig:weight_e}
\end{figure}

\textcolor{red}{For the application-specific IPs, data-dependent tasks might have to be executed by different IP cores, resulting that the corresponding edge cannot be contracted. Therefore, we only focus the edges that can be contracted to reduce the schedule length. In the following discussion, we assume that all edges can be contracted for simplicity.}

Let $dly(e_{ij})$ be the inter-core communication delay of $e_{ij}$, and all intra-core communication delays are ignored in this work. Contracting an edge ($e_{ij}$) reduces the lengths of all paths that pass though $e_{ij}$ by $dly(e_{ij})$. Let $w_{dly}(e_{ij})$ be the sum of the reduced schedule lengths of all paths (from $s$ to $t$) in $TVG$ after contracting $e_{ij}$, and it is calculated by the following equation.
\begin{equation}
w_{dly}(e_{ij})=path_{tvg}(e_{ij})*dly(e_{ij})
\end{equation}


\noindent where $path_{tvg}(e_{ij})$ is the number of paths in $TVG$ that pass through $e_{ij}$.



\textcolor{blue}{Our target is to contract the edges with larger $w_{dly}(e_{ij})$, while the increased security risk is smaller, and the total weight that evaluates an edge $e_{ij}$ contraction in $TVG$ is denoted as $w(e_{ij})$, which is calculated as follows:}
\begin{equation}
w(e_{ij}) = \frac{w_{dly}(e_{ij})}{risk(e_{ij})}
\label{equ:weight_e}
\end{equation}

\noindent where $risk(e_{ij})$ denotes the security risk if $e_{ij}$. Equ \ref{equ:weight_e} indicates that we hope to choose the edge with larger $w_{dly}(e_{ij})$, while the increased security risk is smaller, in the task clustering s Fig. \ref{subfig:tvg1-2} illustrates the $w_{dly}(e_{ij})$ and $risk(e_{ij})$ in $TVG$, which are indicated next to the edges.%, and the $dly(e)$ of all edges is 1 $u.t.$.% Choosing the edges with larger $w(e_{ij})$ indicates that less edges will be contracted until the performance constraint is reached.


\textcolor{blue}{However, not all edges can be contracted with respect to the multicore parallel execution. Let $in\_edge(v)$ be the set of edges that end with $v$, and let $out\_edge(v)$ be the set of edges that start from $v$. Edges in $TG$ that belong to the same $in\_edge(v)$ or $out\_edge(v)$ are called \textbf{brother edges}. If an edge is contracted during performance optimization, all its brother edges can no longer be contracted. The reason is that contracting brother edges means the tasks that once could be executed parallel in different cores now must be executed sequentially in the same core, and this may result in an increased schedule length. For example, contracting the brother edges $e_{4,6}$ and $e_{4,7}$ in Fig. \ref{subfig:tvg1-2} makes $v_6$ and $v_7$ must be conducted sequentially in the same core, but they once can be computed at the same time in different cores.}

\textcolor{blue}{In addition, two edges belong to the same path in $TVG$ should not be contracted simultaneously, and this avoids the over optimization of path length, which causes additional system security risk. The following example explains the reason. Suppose that edges $e_1$ and $e_2$ belong to the same path in $TVG$, and contracting either $e_1$ or $e_2$ will make the path length smaller than the performance constraint. However, if $e_1$ and $e_2$ are both contracted, the path length is over optimized, and this causes additional system risk increment.}


\textcolor{cyan}{Then, a weighted \textbf{edge contraction conflict graph} ($ECCG=(V_E,E_E)$) is constructed to represent whether every pair of edges in $TVG$ can be contracted simultaneously}. Each vertex in $V_E$ represents an edge in $TVG$ that can be contracted, and the weight of a vertex in $V_E$ equals the weight of the corresponding edge in $TVG$. \textcolor{red}{Two vertices in $V_E$ are connected when their corresponding edges cannot be contracted simultaneously, under one of the following two situations:
\begin{enumerate}
\item Two edges that share the same source or target node (with respect to the multicore parallel execution);
\item These two edges belong to the same path in $TVG$ (to prevent the over optimization of path length).
\end{enumerate}}


\textcolor{cyan}{The maximum weight independent set (MWIS) of the weighted $ECCG$ is calculated by the method proposed in \cite{conference:LC}, and the target is to a set of edges with maximum weight that can be contracted simultaneously.} Algorithm \ref{alg:PCTC} gives the details of the performance-constrained task clustering algorithm with the goal of minimizing the system security risk. In the first step (\textit{lines: 2-5}), $TVG$ is constructed from $TG$, and the weights of all edges in $TVG$ are evaluated. In the second step (\textit{lines: 6-10}), the weighted $ECCG$ is built, and its MWIS is calculated. In the third step (\textit{lines: 11-13}), the MWIS-selected edges in $TG$ are contracted. These three steps are iteratively repeated until the performance constraint is satisfied.

\begin{algorithm}[!h]
\caption{Task clustering with performance constraint, $task\_cluster(TG, pc)$.}
\label{alg:PCTC}
\begin{flushleft}
{Input:}
task graph, $TG$;\\
\hspace*{2.8em}performance constraint, $pc$.\\
{Output:} performance-constrained clustering result, $TC$.
\end{flushleft}
\begin{algorithmic}[1]
\WHILE{$TG.schedule\_length > pc$}
\STATE Construct $TVG$ from $TG$.
\FOR{each $e$ in $TVG$}
\STATE Calculate $w(e)$;
\ENDFOR
\STATE Construct $ECCG$ from $TVG$;
\FOR{Each node $e$ in $ECCG$}
\STATE $ECCG.node\_weight(e)=w(e)$;
\ENDFOR
\STATE Calculate $MWIS$ in $ECCG$;
\FOR{each node $e$ in $MWIS$}
    \STATE Contract the corresponding edge $e$ in $TG$;
\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}


\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1.0em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG1.pdf}\label{subfig:EVG1}
} &\hspace*{-1.7em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG2.pdf}\label{subfig:EVG2}
} &\hspace*{-1.7em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG3.pdf}\label{subfig:EVG3}
}
\end{tabular}
\caption{Example of performance-constrained task clustering procedure. \subref{subfig:EVG1} $TVG$ and its corresponding $ECCG$ before task clustering. \subref{subfig:EVG2} $TVG$ and its corresponding $ECCG$ after 1st iteration of task clustering. \subref{subfig:EVG3} $TVG$ and corresponding $VCG$ after 2nd iteration of task clustering.}
\label{fig:TC}
\end{figure}


With the security risks of communications given in Fig. \ref{subfig:tvg1-2}, an example of performance-constrained task clustering is presented in Fig. \ref{fig:TC}, where we are about to optimize the schedule length by 2 $ut$. The $TVG$ consists of the nodes and edges with black color, and dashed lines are the contracted edges. The $ECCG$ is given beneath the corresponding $TVG$, and the weight of contracting an edge is marked next to the node in $ECCG$. The $TVG$ and its corresponding $ECCG$ are constructed (see Fig. \ref{subfig:EVG1}), and its MWIS is $\{e_{5,8}, e_{6,9}, e_{7,10}\}$ which is contracted in the first iteration. Then, both $TVG$ and $ECCG$ are updated as shown in Fig. \ref{subfig:EVG2}, where $e_{5,7}$ and $e_{8,10}$ are not in $ECCG$ because their brother edges $e_{5,8}$ and $e_{7,10}$ are already contracted. The MWIS of the current $ECCG$ is $\{e_{1,4}, e_{2,5}\}$, and after contracting these edges, Fig. \ref{subfig:EVG3} gives the final clustering results, with performance constraint satisfied.% and the corresponding $ECCG$, and $e_{5,8}$ is contracted in the final iteration.



\subsection{Vendor Assignment with Core Minimization}

%With performance-constrained task clustering results, tasks are then assigned to IP vendors.
The principle of vendor assignment is to iteratively cluster tasks into a number of $v_c$ (vendor constraint) clusters, and assign each cluster with an IP vendor according to its core speed. Different from the task clustering in the performance-constrained task clustering stage that violates the isolation-with-diversity by clustering date-dependent tasks, clustering (also named \textbf{cluster merging}) in vendor assignment follows all security constraints.%, and only clusters tasks that can be assigned with the same IP vendor. % The speed variations of cores between different IP vendors are neglected in this paper.

\textcolor{cyan}{The \textbf{vendor conflict graph} ($VCFG=(V_c, E_{cf})$) is constructed from the performance-constrained clustering results, and it represents whether two clusters must be assigned to different vendors.} $V_c$ is the set of all clusters from $TG$ and $TG'$, and a cluster is determined by the following two situations: 1) a task that is not connected by any contracted edge is regarded as a cluster; 2) tasks that are connected to each other by contracted edges are in the same cluster, and the index of this cluster is decided by the minimum index of the tasks in this cluster. $E_{cf}$ is the edge set in $VCFG$, and if two tasks must be assigned to different IP vendors due to security constraints, the two clusters that contain these two tasks will be connected in $VCFG$.

\textcolor{cyan}{The \textbf{vendor compatible graph} ($VCPG=(V_c, E_{cp})$) is the complement graph of the $VCFG$, and an edge in $E_{cp}$ indicates that the connected clusters can be assigned to the same vendor.} Fig. \ref{subfig:vcg_c_1} gives examples of $VCFG$ and $VCPG$, which are constructed from the performance-constrained clustering result shown in Fig. \ref{subfig:EVG3}. Since the edges in $VCPG$ are too numerous to demonstrate, we use dash lines to represent the remaining edges connected to this cluster.

%The principle of vendor assignment is to iteratively cluster tasks into a number of $v_c$ (vendor constraint) clusters, and then assign each cluster with a IP vendor.



\begin{figure}[!t]
\centering
\begin{tabular}{c}
\hspace*{-0.5em}
\subfigure [] {
\includegraphics[width=8.6cm]{figure/vcg_c_1.pdf}\label{subfig:vcg_c_1}
}\\\hspace*{-1.2em}
\subfigure [] {
\includegraphics[width=8.8cm]{figure/vcg_c_2.pdf}\label{subfig:vcg_c_2}
}
\end{tabular}
\caption{Example of evaluating vendor compatible graph. \subref{subfig:vcg_c_1} $VCFG$ and $VCPG$ derived from task clustering results. \subref{subfig:vcg_c_2} Distributions of clusters.}
\label{fig:vc_c}
\end{figure}



\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\subfigure [] {
\hspace*{-1em}
\includegraphics[width=5.8cm]{figure/vcg1.pdf}\label{subfig:assign1}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg2.pdf}\label{subfig:assign2}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg3.pdf}\label{subfig:assign3}
} \\\hspace*{-1em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg4.pdf}\label{subfig:assign4}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg5.pdf}\label{subfig:assign5}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg6.pdf}\label{subfig:assign6}
}
\end{tabular}
\caption{Example of cluster merging procedure. \subref{subfig:assign1} $VCFG$ and $VCPG$ in 2nd iteration of cluster merging. \subref{subfig:assign2} $VCFG$ and $VCPG$ in 3th iteration of cluster merging. \subref{subfig:assign3} $VCFG$ and $VCPG$ in 4th iteration of cluster merging. \subref{subfig:assign4} $VCFG$ and $VCPG$ in 5th iteration of cluster merging. \subref{subfig:assign5} $VCFG$ and $VCPG$ in 6th iteration of cluster merging. \subref{subfig:assign6} $VCFG$ and $VCPG$ in 7th iteration of cluster merging.}
\vspace*{-0.9em}
\label{fig:assign}
\end{figure*}


%Then, the accumulated probability of task concurrency is introduced to estimate the number of cores required during vendor assignment. The \textbf{mobility} of a task $v_{i}$ is denoted as $M(v_i)$ and defined as a set of consecutive time periods $M(v_{i})=[t_{asap}(v_{i}),~t_{alap}(v_{i})]$.% where $t_{asap}(v_i)$ and $t_{alap}(v_i)$ are the ASAP scheduling and ALAP scheduling results, respectively.% Then, the \textit{mobilities} of all tasks are calculated and the \textit{distribution graph} \cite{article:PP} for each cluster is constructed to estimate the number of cores required during vendor assignment.

Then, the accumulated probability of task concurrency is calculated, and it is denoted as \textit{distribution graph} (DG). We assume that the probabilities of a task on its all possible scheduling results are the same \cite{article:PP}, and the probability that $v_i$ is executed in time $t_j$ is denoted as $prob(v_i,t_j)$. The summation of the probabilities of all tasks in a cluster $c$ for the time period $t_j$ is denoted as $DG(c, t_j)$ and calculated as follows:
\begin{equation}
DG(c, t_j) = \sum \limits_{v_i\in c} prob(v_i, t_j)
\end{equation}


The maximum of all $DG(c, t_j), ~\forall t_j\in[1, p_c]$ is denoted as $DG_{max}(c)$, which is used to estimate the number of cores required for all tasks in cluster $c$. Fig. \ref{subfig:vcg_c_2} presents the distribution graphs of all clusters, where the width of a task means the probability that this task will be conducted at the corresponding time period.

The number of cores required may be reduced by merging two clusters $c_i$ and $c_j$, which is denoted as $Merge(c_i, c_j)$, and it can be calculated as follows:
\begin{equation}
Merge(c_i, c_j) = DG_{max}(c_i) + DG_{max}(c_j) - DG_{max}(c_i+c_j)
\label{equ:weight_e2}
\end{equation}

\begin{algorithm}[!h]
\caption{Vendor-assignment with core minimization, $vendor\_assign(TC, TC', vc, pc)$.}
\label{alg:VA}
{Input:}
performance-constrained clustering results of task\\
\hspace*{2.4em}  graph and duplicated task graph, $TC$, $TC'$.\\
\hspace*{2.4em} performance and vendor constraints, $pc$, $vc$.\\
%\hspace*{2.4em}  core speeds of vendors.\\
{Output:} vendor assignment, $VA$.
\begin{algorithmic}[1]
%\STATE calculate the mobility of of each task.
\FOR{each cluster $c$}
    \STATE calculate $DG_{max}(c)$.
\ENDFOR
\STATE Construct $VCFG$ and $VCPG$;
\STATE Calculate the weights of edges in $VCPG$
\WHILE{$VCPG.node\_num > vc$}
\STATE Choose the edge $e_{max}=(c_i,c_j)$ with the maximum weight in $VCPG$, and merge $c_i$ and $c_j$ into one cluster.%, denoted as $c_{i}$.
\STATE Update $VCFG$ and weighted $VCPG$,
%\STATE Update the weights of edges that connect $c_i$ in $VCPG$.;
\ENDWHILE
%\STATE Count the number of timing critical tasks in each cluster;
\WHILE {Not all clusters are assigned with IP vendors}
    \STATE assign $c_i$ to vendor $vendor_j$, where $c_i$ is an unassigned cluster with the most timing critical tasks and $vendor_j$ is the available vendor with the fastest core speed.
\ENDWHILE
\STATE Update the distribution graphs of tasks with assigned core speeds;
%\STATE Sort security constraint-violated edges in descending order of security loss;
\STATE $E_{cv}$ is the set consists of all intra-core communications;
\WHILE {$E_{cv}\neq \emptyset$}
\STATE Find $e\in E_{cv}$ with the largest $risk(e)$;
\IF{Assigning $e$ with security constraints does not violate performance constraints}
\STATE Assign either $source(e)$ or $target(e)$ with another IP vendor;
\STATE Update the distribution graphs of tasks;
\ENDIF
\STATE Remove $e$ from $E_{cv}$;
\ENDWHILE
\end{algorithmic}
\end{algorithm}



A larger value of $Merge(c_i, c_j)$ means a higher probability that tasks in $c_i$ and $c_j$ can share the same cores, and therefore assigning these tasks to the same IP vendor reduces the number of cores. Examples of calculating $Merge(c_2, c_3)$ and $Merge(c_2, c_7)$ are presented in Fig. \ref{subfig:vcg_c_2}. $Merge(c_2, c_3)=1+0.5-1.5=0$, which means that core reduction cannot be achieved by merging $c_2$ and $c_3$. $Merge(c_2, c_7)=1+1-1=1$, indicating that merging $c_2$ and $c_7$ can reduce one IP core.



$Merge(c_i, c_j)$ is then set as the weight of edge $(c_i, c_j)$ in $VCPG$. The edge with maximum weight is chosen, and the connected clusters are merged into one; this procedure continues until the number of clusters equals the number of vendors available. Because $VCPG$ with $O(n)$ nodes has almost $O(n^2)$ edges, the maximum weight independent set of $VCPG$ is not introduced to determine the clusters to be merged due to its large time complexity.



An example of the cluster merging procedure is illustrated in Fig. \ref{fig:assign}, where the initial $VCFG$ and $VCPG$ are presented in Fig. \ref{subfig:vcg_c_1}, and the vendor constraint is 3. The maximum weight of all edges in $VCPG$ is 1, and $c_2$ and $c_6$ in Fig. \ref{subfig:vcg_c_1} are merged into one cluster, named $c_2$. All edges that once connected to $c_2$ and $c_6$ in $VCFG$ now connect to $c_2$ in the updated $VCFG$, and the weights of edges that connect to $c_2$ in $VCPG$ are also updated. Fig. \ref{subfig:assign1} shows the $VCFG$ and $VCPG$ after the 1st iteration of merging clusters. Then, $c_2'$ and $c_6'$ are merged in the 2nd iteration because the weight of their connecting edge is 1. Fig. \ref{subfig:assign2} presents the updated $VCFG$ and $VCPG$. With the corresponding $VCFGs$ and $VCPGs$ shown in Fig. \ref{subfig:assign2}-Fig. \ref{subfig:assign6}, the pairs of clusters ($c_1'$, $c_7$), ($c_3'$, $c_7'$), ($c_1$, $c_3$), ($c_2$, $c_3'$) and ($c_1$, $c_2'$) are iteratively merged. This procedure terminates when the number of clusters equals the vendor constraint, and Fig. \ref{fig:assign_result} gives the final results, where the total estimated number of cores is 5.5.

\begin{figure}[!t]
\centering
\hspace*{-0.8em}
\includegraphics[width=8.8cm]{figure/vcg_result.pdf}
\caption{Cluster merging results under vendor constraint.}
\label{fig:assign_result}
\end{figure}

Then, the number of timing-critical tasks in each cluster is countered, and the clusters containing more timing-critical tasks are assigned to the vendor with faster core speeds. Some timing-critical paths may be over optimized because all tasks are treated with the lowest core speed in the performance-constrained task clustering stage, and we need to adjust the vendor assignment to meet more security constraints. The slacks of tasks are updated with the assigned core speeds and every intra-core communication is checked in the descending order of $risk(e)$ whether this communication can be re-assigned with security constraints. A intra-core communication ($e$) can be re-assigned to inter-core communication to satisfy security constraints only when all tasks in the paths that pass though $e$ have slack times no smaller than $dly(e)$, and one of its connected tasks will be assigned to the IP vendor with the least core increment.% This procedure is named as vendor assignment adjustment in the following discussion.

% some data-dependent tasks that once assigned to the same core in performance-constrained task clustering stage can be re-assigned with different IP vendors to meet vendor diversity constraints. The slack time of each tasks is recalculated with the actual processing time, and a intra-core communication ($e$) can be reassigned to inter-core communication with a delay $delay(e)$ only when 1) all tasks in the paths that passing though $e$ have slack times no smaller than $delay(e)$; 2) exist other IP vendors that $source(e)$ or $target(e)$ node can be assigned, and either $source(e)$ or $target(e)$ will be assigned to the IP vendor with the least core increment. All intra-core communications will be checked in the descending order of $risk(e)$.%, and this process is denoted as $vendor\_adjust$ in the following discussion.

% Contracting the maximum weight edge in $VCPG$ means the maximization of cores charing, which can in turn minimize the number of cores required.





Algorithm \ref{alg:VA} demonstrates the proposed vendor assignment algorithm. Firstly (\textit{lines: 1-5}), the number of cores required by each cluster is estimated by $DG_{max}(c)$, and $VCFG$ and weighted $VCPG$ are constructed. Secondly (\textit{lines: 6-9}), the maximum weight edge in $VCPG$ is chosen, and the connected clusters are merged into one cluster. Both $VCFG$ and weighted $VCPG$ are then updated, and this procedure continues until the number of clusters equals the number of IP vendors available. Thirdly (\textit{lines: 10-13}), cluster containing more timing-critical tasks is assigned to the IP vendor with faster core speed. Finally (\textit{line: 14-22}), the unprotected edges are checked in the descending order of security risk, and the vendor assignments are adjusted under performance constraints to further reduce the system security risk.



%An example of the vendor assignment procedure is illustrated in Fig. \ref{fig:assign}, where the initial $VCFG$ and $VCPG$ are presented in Fig. \ref{subfig:vcg_c_1}, and the vendor constraint is 3. The maximum weight of all edges in $VCPG$ is 1, and $c_2$ and $c_6$ in Fig. \ref{subfig:vcg_c_1} are merged into one cluster, named $c_2$. All edges that once connected to $c_2$ and $c_6$ in $VCFG$ now connect to $c_2$ in the updated $VCFG$, and the weights of edges that connect to $c_2$ in $VCPG$ are also updated. Fig. \ref{subfig:assign1} shows the $VCFG$ and $VCPG$ after the 1st iteration of merging clusters. Then, $c_2'$ and $c_6'$ are merged in the 2nd iteration because the weight of their connecting edge is 1. Fig. \ref{subfig:assign2} presents the updated $VCFG$ and $VCPG$. With the corresponding $VCFG$ and $VCPG$ shown in Fig. \ref{subfig:assign2}-Fig. \ref{subfig:assign6}, the pairs of clusters ($c_1'$, $c_7$), ($c_3'$, $c_7'$), ($c_1$, $c_3$), ($c_2$, $c_3'$) and ($c_1$, $c_2'$) are iteratively merged. This procedure terminates when the number of clusters equals the vendor constraint, and Fig. \ref{fig:assign_result} gives the final results, where the total estimated number of cores is 5.5.
% After the cluster merging procedure, tasks in each cluster are assigned to the same IP vendor.







\subsection{Procedure of Our Proposed Task Scheduling Method}

With all security constraints satisfied, the number of IP vendors is always equal to the number of nodes in the maximum clique (denoted as \textit{maximum clique size}) of $VCFG$. However, performance-constrained task clustering and vendor assignment may potentially increase the number of vendors needed, and we need to check every contracted edge if the resulting maximum clique size exceeds the vendor constraint. Computing the maximum clique size of a graph is NP-complete, and an efficient heuristic approach \cite{article:CL} is introduced in this paper. Each time after determining a contracted edge, the impact on the maximum clique size of the corresponding $VCFG$ is evaluated, and the edge is not contracted if the vendor constraint is violated. Instead, the algorithm chooses the second-best solutions.


After vendor assignment, tasks with the same IP vendor are scheduled together using the force-directed scheduling (FDS) method \cite{article:PP}. FDS tends to schedule tasks evenly in each time period, and only a small number of cores is needed. Algorithm \ref{alg:PCTS} gives the whole procedure of the proposed task scheduling algorithm. Tasks in the task graph and duplicated task graph are clustered under the performance constraint $p_c$ (\textit{lines: 1-2}) and then assigned to IP vendors with a minimized number of cores required (\textit{line: 3}). Finally, tasks in each IP vendor are scheduled at the same time by FDS (\textit{lines: 4-7}). In this paper, we discussed the system risk optimization with two types of security constraints, and our method can be also applied when more types of security constraints are introduced.

\begin{algorithm}[!h]
\caption{Security-aware task scheduling with performance constraints, $task\_schedule(TG, pc, vc)$.}
\label{alg:PCTS}
{Input:} task graph, $TG$\\
\hspace*{2.4em} performance and vendor constraints, $pc$, $vc$.\\
%\hspace*{2.4em}  core speeds of vendors.\\
{Output:} scheduling results, $TS$.
\begin{algorithmic}[1]
\STATE $TC=task\_cluster(TG,pc)$;
\STATE $TC'=task\_cluster(TG',pc)$, where $TG'$ is the duplicate of $TG$;
\STATE $VA=vendor\_assign(TC, TC', vc, pc)$;
%\STATE $VA=vendor\_adjust(VA)$;
\FOR{each vendor $vendor_i$}
    \STATE $V_{vendor_i}$ is the set of all tasks assigned to $vendor_i$;
%    \STATE Calculate the mobilities of tasks in $V_{vendor_i}$;
    \STATE $FDS(V_{vendor_i}, pc)$;% using Force-directed scheduling;
\ENDFOR
\end{algorithmic}
\end{algorithm}

\textcolor{red}{There also exists some actual scenarios, and our proposed methods can be easily adopted. 1) The first scenario is that the number of vendors available might be less than the maximum clique size of the corresponding $VCFG$. In this situation, a vendor-constrained task clustering method \cite{article:NW} can be introduced before vendor assignment, so that the vendor constraint can be satisfied with a minimized number of contracted edges. 2) The second scenario is that application-specific IPs might not be able to support every tasks. For each type of IP, we first build its $VCFG$ and $VCPG$ according to the clustering results of tasks that belong to this type, and then perform the vendor assignment along with task scheduling individually.}

\subsection{Time Complexity Analysis}

\textcolor{blue}{The time complexity of our proposed method is analyzed as follows, and the input task graph has $n$ nodes and $m$ edges.}

\textcolor{blue}{In each iteration of the performance-constrained task clustering stage, constructing $ECCG$ from $TVG$ requires $O(m^2)$, and finding the MWIS in $ECCG$ also requires $O(m^2)$ \cite{conference:LC}. Only a constant number of iterations are conducted before reaching the performance constraint, and finding all contracted edges to meet the performance constraint totally needs $O(m^2)$. In addition, each time before contracting an edge, updating $VCFG$ and evaluating the impact on the maximum clique size of $VCFG$ need $O(n^2)$, and only a limited number of edges are contracted, making its computational cost $O(n^2)$. The total time complexity of performance-constrained task clustering is $O(m^2)$ (due to $O(n)\leq O(m)$).}

\textcolor{blue}{In the vendor assignment and task scheduling stage, constructing $VCFG$ and $VCPG$ requires $O(n^2)$. In each iteration of merging clusters, $O(m)$ is required to estimate the maximum clique size, and $O(n)$ is needed to update both $VCFG$ and $VCPG$. Vender assignment requires $O(n)$ iterations of merging clusters, and its time complexity is $O(mn)$. Performing the force-directed scheduling method to schedule all tasks needs $O(n^2)$, and the total time complexity of the vendor assignment and task scheduling stage is $O(mn)$.}

\textcolor{blue}{The sum of $O(m^2)$ and $O(mn)$ is $O(m^2)$, and it is the total time complexity of our proposed method.}


\section{Experimental Results}

\subsection{Experimental Setups}
All experiments were implemented in C on a Linux Workstation with an E5 2.6-GHz CPU and 32-GB RAM. We tested eight benchmarks from two sources\footnote{https://www.kasahara.cs.waseda.ac.jp/schedule/index.html.}: task graphs modeled from actual application programs, including robot control (robot), sparse matrix solver (sparse), and SPEC fpppp (fpppp); and randomly generated task graphs (rnc500, rnc1000, rnc2000, rnc3000 and rnc5000). To simplify the experiments, all intra-core communication delays were ignored, and we set the step of core speed differences equals to 5\% of the fastest core speed.

\begin{table}[!h]
\renewcommand{\arraystretch}{1.06}
\caption{Details of Benchmarks}
\centering
\begin{tabular}{c|c|c|c|c|c}
\hline
\hline

task    &\multicolumn{1}{c|}{\multirow{2}{*}{$n$}}     &\multicolumn{1}{c|}{\multirow{2}{*}{$m$}}     &\multicolumn{1}{c|}{\multirow{2}{*}{Para. }}  &ACC   &\multicolumn{1}{c}{\multirow{2}{*}{\textit{maxClique}}}  \\
graph   &                                            &           &        & ($ut$)          &       \\
\hline
\hline

robot   &88   &131     &4.4 &28.2   &3 \\

sparse  &96   &67    &16.0  &20.2   &3 \\

fpppp   &334   &1145    &6.7  &21.3    &3  \\

rnc500  &500   &1910    &27.7  &10.6    &3  \\

rnc1000  &1000   &3005   &60.2  &7.8  &3 \\

rnc2000   &2000   &3930   &151.9  &10.6  &3 \\

rnc3000   &3000   &39034    &34.2 &13.0   &4  \\

rnc5000   &5000   &55432   &90.8  &11.0  &4 \\

\hline
\hline
\end{tabular}
\label{table:detail}
\end{table}

%To test the performance of our proposed methods, a set of benchmarks is tested, and

Table \ref{table:detail} lists the details of these benchmarks. The column $n$ and $m$ give the numbers of tasks and communications in each task graph, respectively. Column Para. shows the parallelism of each task graph, which is the ratio of the total processing time of all tasks to the ASAP schedule length (without communication delay). Column ACC gives the averaged computational cost of each task. Considering that the maximum clique sizes of most task graphs modeled from actual application programs are no larger than 4\cite{article:CL}, the maximum clique sizes (see column \textit{maxClique}) of all randomly generated $TGs$ in Table \ref{table:detail} are 3 or 4, and the IP vendor constraint is set to be the maximum clique size of the benchmark.% The core speeds of different vendors may be different, and we set the step of speed differences equals to 5\% of the fastest core speed in our experiments.
%\begin{enumerate}
%\item Comparing the benchmarks with the same number of nodes, the benchmark with larger maximum clique size always indicates a larger number of edges. Therefore, too many edges have to be contracted to boost the performance, which is not practical in actual.
%\item The maximum clique sizes of most task graphs are no larger than 4\cite{article:CL}.
%\end{enumerate}


%To demonstrate the effectiveness of our proposed methods, the task scheduling results of our methods are compared with a Baseline method \cite{article:CL} which schedules task strictly following the security constraints.

\begin{table*}[!t]
\renewcommand{\arraystretch}{1.0}
\caption{Comparisons of Performance-Constrained Task Scheduling Results of Actual Applications.}
\centering
\begin{tabular}{c|c|c|c|ccc|ccc|ccc}
\hline
\hline
task                                      &\multicolumn{1}{c|}{\multirow{2}{*}{$CCR$}}     &SL       &$pc$      &\multicolumn{3}{c|}{$risk_s~(10^{-3})$}        &\multicolumn{3}{c|}{Num. of cores}    &\multicolumn{3}{c}{average runtime ($s$)}    \\ \cline{5-7} \cline{8-10} \cline{11-13}
graph                                                                               &                                                &($ut$)   &($ut$)    &C-B\cite{article:CL}   &MC-B\cite{article:NW}    &Our   &C-B\cite{article:CL}       &MC-B\cite{article:NW}  &Our    &C-B\cite{article:CL}       &MC-B\cite{article:NW}   &Our  \\

\hline
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{robot}}       &0.5 &839 &671 &353.68    &206.57    &155.35    &14    &12    &11    &3.9     &17.5    &18.7            \\
                                                                             &1.0  &1114  &892           &274.91   &185.62    &147.83    &14    &12    &10    &3.9     &17.6    &18.9             \\
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{sparse}}     &0.5 &179 &143 &146.75   &93.48    &76.07    &21    &18    &16    &5.3     &41.2    &33.8          \\
                                                                                       &1.0 &236  &189 &157.48   &98.47    &83.59    &19    &18    &15    &5.5     &42.3    &34.5            \\

\hline

\multicolumn{1}{c|}{\multirow{2}{*}{fpppp}}        &0.5 &1590  &1272  &15.23    &6.37    &4.52    &13    &12    &10    &7.5     &50.2    &47.6             \\
                                                    &1.0 &2119  &1695  &11.49    &6.85    &4.97    &12    &11    &10    &8.3     &53.5    &49.8            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{avg.}}      &0.5 &      &  &171.89  &102.14      &78.65  & &  &   &   &         \\
                                                &1.0 &     &  &147.96  &96.98      &78.80  & &  &   &   &         \\

\hline
\hline
\end{tabular}
\label{table:PCTS_A}
\end{table*}


\begin{table*}[!t]
\renewcommand{\arraystretch}{1.0}
\caption{Comparisons of Performance-Constrained Task Scheduling Results of Random Generated Task Graphs.}
\centering
\begin{tabular}{c|c|c|c|ccc|ccc|ccc}
\hline
\hline
task                                     &\multicolumn{1}{c|}{\multirow{2}{*}{$CCR$}}     &SL       &$pc$      &\multicolumn{3}{c|}{$risk_s~(10^{-3})$}        &\multicolumn{3}{c|}{Num. of cores}    &\multicolumn{3}{c}{average runtime ($s$)}    \\ \cline{5-7} \cline{8-10} \cline{11-13}
graph                                    &                                                &($ut$)   &($ut$)    &C-B\cite{article:CL}   &MC-B\cite{article:NW}    &Our   &C-B\cite{article:CL}       &MC-B\cite{article:NW}  &Our    &C-B\cite{article:CL}       &MC-B\cite{article:NW}   &Our  \\

\hline
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc500}}      &0.5 &280 &224  &25.13    &15.70    &12.46    &68    &65    &58    &18.9     &113.6    &95.4               \\
                                                  &1.0  &373  &300               &20.41    &16.35    &12.95    &67    &63    &56    &20.3     &121.3    &98.7               \\
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc1000}}     &0.5 &190 &152  &47.92    &33.94    &26.71    &95    &88    &78    &38.8     &259.3    &183.5             \\
                                                  &1.0 &254  &203     &48.73    &31.95    &23.69    &87    &81    &74    &42.1     &273.3    &189.7              \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc2000}}     &0.5 &199  &159  &20.61    &16.53    &12.37    &217    &184    &167    &57.5     &715.7    &553.6             \\
                                                  &1.0 &268  &214  &21.47    &14.51    &10.62    &206    &180    &164    &59.1     &748.2    &572.9            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc3000}}     &0.5 &1336  &1069  &56.41    &43.27    &35.58    &73    &67    &62    &182.5     &3582.6    &3014.9             \\
                                                  &1.0 &1779  &1423  &53.49    &37.74    &31.18    &68    &62    &56    &192.2     &3715.3    &3253.4            \\
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{rnc5000}}       &0.5 &850  &680  &48.13    &43.17    &34.52    &142    &132    &122    &384.9     &9004.5    &6764.2             \\
                                                    &1.0 &1146 &917  &54.84    &47.25    &36.55    &137    &125    &115    &395.4     &9528.3    &6816.1            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{avg.}}       &0.5 &      &  &39.64  &30.52      &24.33   &   &  &   &   &         \\
                                                 &1.0 &     &  &39.79  &29.56      &23.01  & &  &   &   &         \\
\hline
\hline
\end{tabular}
\label{table:PCTS_R}
\end{table*}




\textcolor{red}{\textbf{Our} proposed method is then compared with two other methods to demonstrate the effectiveness. The first approach is ``\textit{Cluster-based approach}'' (\textbf{C-B} for short) \cite{article:CL}. This approach optimizes the schedule length by placing critical tasks on a single core, and then colors the performance-driven schedule to fulfill security constraints. The second approach is ``\textit{Min-cut-based approach}'' (\textbf{MC-B} for short) \cite{article:NW}. This approach boosts performance by iteratively contracting the edges selected by the max-flow min-cut algorithm, then assigns tasks to IP vendor with traditional graph coloring method, and finally schedules tasks with the force-directed scheduling-based method.}

%The \textbf{PSO-B} method \cite{article:SR} uses a PSO-based method to find a solution with minimized resource requirements. The \textbf{C-B} method \cite{article:CL} optimizes the schedule length by placing critical tasks on a single core, and conducts IP vendor assignment using the traditional graph coloring method. The \textbf{MC-B} method \cite{article:NW} boosts performance by iteratively contracting the edges selected by the max-flow min-cut algorithm and schedules tasks with the force-directed scheduling-based method.% and assigns tasks% with IP vendors while considering% the core speed variation.



\subsection{Performance-Constrained Task Scheduling Results}

The performance-constrained task scheduling results are shown in Table \ref{table:PCTS_R}. The communication-to-computation ratio ($CCR$) is the ratio of the inter-core communication delay to the computational cost of the task, and two $CCRs$ (0.5 and 1.0) are tested. The performance constraint is set to \textit{pc}=0.8\textit{SL}, where $SL$ is the ASAP schedule length with all security constraints satisfied. The security risk variation among communications is also counted in this set of experiments, and we first assume that the task outputs may contain more confidential information and that the system damage caused by triggered hardware trojans becomes more serious when the application proceeds. Therefore, we set the security risk of $e_{ij}$ in $TG$ or $TG'$ as follows.

\begin{equation}
 risk(e_{ij})=\frac{2*dist(e_{ij})*pte}{SL*m}
\label{equ:risk_set1}
\end{equation}

\noindent where $dist(e_{ij})$ is the distance from $s$ to $v_i$. $pte$ is the \textit{possible trojan entries} \cite{article:SR}, and we set $pte$ to be 3 for all benchmarks.

Table \ref{table:PCTS_A} compares the task scheduling results of these methods on three real application graphs. The comparing results indicates that our proposed method obtained the lowest $risk_s$ for all benchmarks. MC-B tried to optimize the system risk by reducing the number of un-protected communications, but it ignored the security risk variation of communications, and it also might choose brother edges to contract, resulting its $risk_s$ larger than that of our proposed method. Furthermore, MC-B forgot to optimize the number of cores in vendor assignment stage, and it required more cores than our method. C-B ignored both the system risk and the number of cores required during task scheduling, and both the $risk_s$ and number of cores are the largest among the compared methods.

\textcolor{red}{Table \ref{table:PCTS_R} illustrates the comparison results of five random generated task graphs. The number of edges in these task graphs are much larger then the edges of robot, sparse, and fpppp, and therefore the risk of each communication is relatively much smaller (refer to Equ. \ref{equ:risk_set1}). The comparison results indicate that our proposed method also obtained the best results in reducing both the $risk_s$ and the number of cores.}

In terms of algorithm runtime, all the algorithms can produce solutions within 1 min for the benchmarks modelled from real applications (see Table \ref{table:PCTS_A}). For the benchmarks who contain many tasks and edges, such as \textit{rnc5000} which has 5000 tasks and 55432 communications (see Table \ref{table:PCTS_R}), our proposed method can output the solution with about 10 minutes, and this indicates that our proposed method is applicable for most of benchmarks in actual practice.

%and $ratio$ is the ratio of $scy_v$ to $scy$. The column $core$ gives the numbers of cores required by the scheduling results, and column $redu_{c}$ shows the percentage of reduced cores compared to the C-B method.






%%The comparison results show that our proposed method maintains most of the security constraints and requires the lowest number of cores. When \textit{CCR}=0.5, our method reduces $scy_v$ by $0.72\%$ compared to the C-B method, and the number of cores required is $19.14\%$ lower. When \textit{CCR}=1.0, $scy_v$ and $core$ of our method are 0.61\% and 18.97\% lower than those of the C-B method, respectively.

%\begin{figure}[!h]
%\centering
%\hspace*{-1.2em}
%\includegraphics[width=8.0cm]{figure/cpu_runtime.eps}
%\caption{CPU runtimes when performing 20 randomly generated task graphs.}
%\label{fig:cpu_runtime}
%\end{figure}



%In addition, we tested the runtimes of these three methods by conducting 20 randomly generated task graphs, and Fig. \ref{fig:cpu_runtime} gives the results. All of these task graphs have 1000 nodes, but their numbers of edges range from 5000 to 100000. The results show that the runtimes of MC-B and our methods increase exponentially with the increment of edges, but the runtimes of our method are still acceptable when conducting the task graphs whose maximum clique sizes are no larger than 4. This indicates the efficiency of our method in dealing with the task graphs modeled from actual application programs.



\subsection{Comparison of Security Risk Optimization Results}

Then, the effectiveness of our method is reducing the system security risk is tested. The $CCR$ is set to \textit{CCR}=1.0 for all benchmarks, and the performance constraint is set to $pc=0.9*SL$. \textcolor{blue}{Fig. \ref{fig:system_risk} gives the comparison results of security risks among C-B, MC-B, and our methods, with the following three sets of risk configurations, which are:}



\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\subfigure [] {
\hspace*{-1.5em}
\includegraphics[width=6.4cm]{figure/randomly_set.eps}\label{subfig:rand_risk}
} &\hspace*{-2.8em}
\subfigure [] {
\includegraphics[width=6.4cm]{figure/equally_set.eps}\label{subfig:equ_risk}
} &\hspace*{-2.8em}
\subfigure [] {
\includegraphics[width=6.4cm]{figure/linearly_set.eps}\label{subfig:linear_risk}
}
\end{tabular}
\caption{Comparison of system security risks. \subref{subfig:rand_risk} System security risk evaluations with risks \textit{randomly set}. \subref{subfig:equ_risk} System security risk evaluations with risks \textit{equally set}. \subref{subfig:linear_risk} System security risk evaluations with risks \textit{linearly set}.}
\vspace*{-0.9em}
\label{fig:system_risk}
\end{figure*}

\textcolor{blue}{
\begin{enumerate}
\item \textbf{Randomly Set}: the risk of each communication is randomly set with the value among [0, $\frac{2*pte}{m}$];
\item \textbf{Equally Set}: the risks of all communications are the same, with the value of $\frac{pte}{m}$;
\item \textbf{Linearly Set}: The communication closer to the source have higher security risk, and the risk of $e_{ij}$ is set as $risk(e_{ij})=\frac{2*(SL-dist(e_{ij}))*pte}{SL*m}$;
\end{enumerate}}



%Since both the C-B and MC-B methods ignore the security risk variation, the security risks of all unprotected communications are assumed to be the same in this set of experiments. Therefore, minimizing the system security risk is equivalent to minimizing the number of communications that are not protected by security constraints (denoted as $scy_v$). The \textit{communication-to-computation ratio} ($CCR$) is the ratio of the inter-core communication delay to the computational cost of the task, and it is set to \textit{CCR}=1.0.



%Table \ref{table:VPCTC} gives the experimental results, and the ratio of $scy_v$ to $scy$ (see column $ratio$) is used to evaluate the system security risk. The performance constraint $pc$ is set as $pc=\delta*\textit{SL}$, where $\textit{SL}$ is the ASAP schedule length with all security constraints satisfied. Two performance constraints are tested for each benchmark, with $\delta \in \{0.9, ~0.8\}$. The results show that the C-B method fails the $0.79\%$ and $1.98\%$ security constraints when $\delta$ is set to 0.9 and 0.8, respectively. The $scy_v$ optimization results of MC-B and our methods are almost the same for all benchmarks, and the ratios of $scy_v$ to $scy$ are $0.45\%$ and $1.36\%$ when $\delta$ is set to 0.9 and 0.8, respectively.

%The above results indicate that the number of unprotected communications is very limited if the schedule length is optimized to 0.9\textit{SL}, and this number significantly increases if the schedule length is further reduced from 0.9\textit{SL} to 0.8\textit{SL}. Therefore, the schedule length should not be over optimized; otherwise, the system will face large security risks.








\begin{table*}[t]
\renewcommand{\arraystretch}{1.0}
\caption{Comparisons of Cores Required.}
\centering
\begin{tabular}{c|c|cccc|ccccccc}
\hline
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{task}}        &\multicolumn{1}{c|}{\multirow{2}{*}{\textit{SL}}}           & \multicolumn{4}{c|}{Loose vendor constraints}        & \multicolumn{7}{c}{Tight vendor constraints}         \\  \cline{3-6} \cline{7-13}

\multicolumn{1}{c|}{\multirow{2}{*}{graph}}       &\multicolumn{1}{c|}{\multirow{2}{*}{($ut$)}}     &\multicolumn{1}{c}{\multirow{2}{*}{$vc$}}   & \multicolumn{3}{|c|}{Num. of cores}  &\multicolumn{1}{c}{\multirow{2}{*}{$vc$}}   & \multicolumn{3}{|c}{Num. of cores}    & \multicolumn{3}{|c}{Proportion of unprotected edges}    \\ \cline{4-6} \cline{8-10}  \cline{11-13}

                           &    &    & \multicolumn{1}{|c}{\multirow{1}{*}{C-B\cite{article:CL}}}         &MC-B\cite{article:NW}   &~~Our~~  &     &\multicolumn{1}{|c}{\multirow{1}{*}{C-B\cite{article:CL}}}        &MC-B\cite{article:NW}   &~~Our~~    &\multicolumn{1}{|c}{\multirow{1}{*}{C-B\cite{article:CL}}}        &MC-B\cite{article:NW}   &~~Our~~     \\
\hline
\hline

robot              &1114  &3 &10 &9 &8        &2     &10     &8     &7       &2.29\%     &1.53\%     &1.53\%  \\

sparse              &236  &3  &14 &12 &12     &2     &14     &11     &10     &8.96\%     &5.97\%     &5.97\%  \\

fpppp              &2119  &3   &10 &9 &8      &2     &9     &7     &6      &1.57\%     &0.96\%     &0.96\% \\

rnc500            &373    &3  &47 &45 &39     &2     &42     &38     &35      &4.50\%     &3.72\%     &3.72\% \\

rnc1000            &254   &3   &68 &63 &56    &2     &58     &51     &47       &1.73\%     &1.30\%     &1.30\%  \\

rnc2000           &268    &3  &156 &148 &130     &2     &139     &127     &116     &0.74\%     &0.46\%     &0.46\% \\

rnc3000           &1779   &4   &56 &51 &48       &2     &52     &48     &45     &58.52\%     &53.15\%     &53.15\% \\

rnc5000           &1146   &4   &106 &98 &88      &2     &97     &91     &83     &70.24\%     &67.89\%     &67.89\%  \\

\hline
\hline
\end{tabular}
\label{table:core_usage}
\end{table*}




The $pte$ is set to be 3 in this set of experiments. Because both C-B and MC-B ignore the security risk variation among communications, and for each benchmark, they produced the same task scheduling result for different risk configurations. However, different risk configurations assign communication with different value of risks, and therefore, the system security risk of the same task schedule are not the same under these three risk configurations. Our proposed method seeks the task scheduling result with the lowest system security risk, and produces different task scheduling results for different risk configurations.




Figs. \ref{subfig:rand_risk}, \ref{subfig:equ_risk}, and \ref{subfig:linear_risk} illustrate the system security risks with the risk of each communication \textit{randomly set}, \textit{equally set}, and \textit{linearly set}, respectively. For each tested benchmark, our proposed method beats both C-B and MC-B with different risk configurations, and the detailed comparisons are given as follows.


\begin{enumerate}
    \item When the risks are \textit{randomly set}, the averaged system security risk of C-B and MC-B are 36.72*$10^{-3}$, and 23.02*$10^{-3}$, respectively, and our proposed method obtained the lowest security risk, which is only 18.11*$10^{-3}$.
    \item If the risks are \textit{equally set}, our method and MC-B obtains almost equivalent results, and it is because that MC-B treats each communication equally when optimizing the system performance. The averaged system security risks of C-B, MC-B and our methods are 37.47*$10^{-3}$, 22.27*$10^{-3}$, and 20.94*$10^{-3}$, respectively.
    \item If the risks are \textit{linearly set}, our proposed method still show its advantage in reducing the system risks, and its average system risk is 18.68*$10^{-3}$, while the averaged system risk of C-B and MC-B are 41.08*$10^{-3}$ and 26.03*$10^{-3}$, respectively.
    \item For some benchmarks (robot, sparse), their system security risks are relatively high, and this is because the risks of communications are also determined by the number of edges in task graphs. These task graphs have much less edges, making the risks of communications in \textit{robot} and \textit{sparse} much larger than that in the other task graphs.
\end{enumerate}



%When the risks are \textit{randomly set}, the averaged system security risk of C-B and MC-B are 36.72*$10^{-3}$, and 23.02*$10^{-3}$, respectively, and our proposed method obtained the lowest security risk, which is only 18.11*$10^{-3}$.

%If the risks are \textit{equally set}, our method and MC-B obtains almost equivalent results, and it is because that MC-B treats each communication equally when optimizing the system performance. The averaged system security risks of C-B, MC-B and our methods are 37.47*$10^{-3}$, 22.27*$10^{-3}$, and 20.94*$10^{-3}$, respectively.

%If the risks are \textit{linearly set}, our proposed method still show its advantage in reducing the system risks, and its average system risk is 18.68*$10^{-3}$, while the averaged system risk of C-B and MC-B are 41.08*$10^{-3}$ and 26.03*$10^{-3}$, respectively.

%For some benchmarks (robot, sparse), their system security risks are relatively high, and this is because the risks communications are also determined by the number of edges in tasks graphs. These task graphs have much less edges, making the risks of communications in \textit{robot} and \textit{sparse} much larger than that in the other task graphs.



%\subsection{Performance Optimization Results With Security Risk Variation}

%Next, the security risk variation among communications is counted. We assume that the task outputs may contain more confidential information and that the system damage caused by triggered hardware trojans becomes more serious when the application proceeds. Therefore, the security risk of $e_{ij}$ in $TG$ or $TG'$ is set to be $risk(e_{ij})=dis(e_{ij})/m$, where $dis(e_{ij})$ is the distance from $s$ to $v_i$, and the performance constraint $p_c$ is set to 0.9\textit{SL}.


%Fig. \ref{fig:System_risk} shows the comparison results of system security risks. Because both C-B and MC-B ignore security risk variation, their task clustering results are the same as shown in Table \ref{table:VPCTC}. The averaged system security risks of C-B, MC-B, and our methods are 26.35*$10^{-3}$, 18.39*$10^{-3}$, and 14.84*$10^{-3}$, respectively, which indicates that our method maintains the highest security level among all three methods.





\subsection{Comparison of Cores Required}

To show the effectiveness of our method in saving the number of cores needed, the performance constraint is set to \textit{SL} so that the performance-constrained task clustering stage can be skipped. \textcolor{blue}{Table \ref{table:core_usage} shows the numbers of cores required, where two sets of vendor constraints are tested. The loose vendor constraints is first set for all benchmarks, and the vendor constraint is set to be the maximum clique size of the corresponding $TG$.} The results indicate that our proposed method needs the least numbers of cores in all benchmarks, and MC-B and our method reduce the numbers of cores by 8.44\% and 17.11\%, respectively, if compared to the C-B method. C-B ignores the core optimization, and MC-B only minimizes the number of cores when scheduling tasks. In our proposed method, reducing the number of cores is considered in both vendor assignment and task scheduling,
which enlarges the optimization space of saving cores.


\textcolor{blue}{Then, the tight vendor constraint is set because there might be not enough vendors for some specific IPs, and the vendor constraints of all benchmarks are set to be 2.} To meet the tight vendor constraints, the vendor-constrained task clustering method proposed in \cite{article:NW} is introduced to remove some of the security constraints from communications and allow the adjacent tasks to be executed on the cores from the same IP vendor. Therefore, a further number of communications become unprotected, and the proportions of the number of unprotected edges to the number of all edges are given in the last column of Table \ref{table:core_usage}. Because MC-B and our method use the same vendor-constrained task clustering, so the proportions of their unprotected edges are the same. C-B only ignored to reduce the number of unprotected edges to meet vendor constraints, and its numbers of unprotected edges are larger. For the benchmarks \textit{rnc3000} and \textit{rnc5000}, whose task graph contain many 3-cliques and 4-cliques, and therefore, many edges become unprotected to satisfy the vendor constraint. The number of cores required shows that our proposed method also obtained the least numbers of cores among these three methods, and the averaged numbers of cores of required by MC-B and our method are 13.47\%, 21.49\% less than that of C-B, respectively.



%When set with the loose vendor constraints, our proposed method needs the least numbers of cores in all benchmarks. MC-B, PSO-B and our methods reduce the numbers of cores by 7.55\%, 17.11\% and 17.92\%, respectively, if compared to the C-B method.%, and our proposed \textit{MWIS-based} needs the least number of cores.

%The runtimes of C-B, MC-B, PSO-B and our methods are also compared. In the benchmarks shown in Table I, $m$ can be regarded as \textit{m=cn}, where $c$ is a constant, and the time complexity of our method can be regarded as $O(n^2)$. The averaged comparison results show that the runtimes of MC-B, PSO-B and our methods are $11.12$, $115.35$ and $9.29$ times longer than the C-B method, respectively.





\section{Conclusions}

In this paper, a security-driven task scheduling method is proposed to reduce the performance and area overheads of implementing security constraints in the design process, and the desired performance is set as constraint. Communications are treated with different security importance due to the security risk variation, and a maximum weight independent set-based task clustering method is proposed to reduce the schedule length while maintaining a high security level. In addition, the numbers of cores required are optimized in both vendor assignment and task scheduling stages by assigning tasks that can share most cores to the same vendor and scheduling them evenly in each time period, and this enlarges the optimization space of cores. The experimental results demonstrate that our proposed method obtains the highest system security and the least number of cores among all compared methods.

%\bibliographystyle{ieicetr}% bib style
%\bibliography{}% your bib database

\begin{thebibliography}{99}% more than 9 --> 99 / less than 10 --> 9
\bibitem{conference:XW}
X. Wang and R. Karri, ``NumChecker: detecting kernel control-flow modifying rootkits by using hardware performance counters,'' \textit{Proc. Design Automation Conference}, pp. 1-7, May 2013.

%\bibitem{conference:XTN}
%X.T. Ngo, J.-L. Danger, S. Guilley, Z. Najm, and O. Emery, ``Hardware property checker for run-time hardware Trojan detection,'' \textit{Proc. European Conference on Circuit Theory and Design}, pp. 1-4, 2015.

\bibitem{article:SB}
S. Bhunia, M.S. Hsiao, M. Banga, and S. Narasimhan, ``Hardware Trojan attacks: threat analysis and countermeasures,'' \textit{Proceedings of the IEEE}, vol. 102, no. 8, pp. 1229-1247, Aug. 2014.

\bibitem{conference:MH}
M. Hussain, A. Malekpour, H. Guo, and S. Parameswaran, ``EETD: an energy efficient design for runtime hardware Trojan detection in untrusted network-on-chip,'' \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 345-350, 2018.


\bibitem{conference:AM1}
A. Malekpour, R. Ragel, A. Ignjatovic, and S. Parameswaran, ``DosGuard: protecting pipelined MPSoCs against hardware trojan based DoS attacks,'' \textit{Proc. International Conference on Applications-specific Systems, Architectures and Processors}, pp. 45-52, 2017

\bibitem{conference:FK}
F. Kounelis, N. Sklavos, and P. Kitsos, ``Run-time effect by inserting hardware trojans in combinational circuits,'' \textit{Euromicro Conference on Digital System Design}, pp. 287-290, 2017.




\bibitem{network:SS}
S. Swapp, \emph{Scanning Electron Microscopy (SEM)},\hskip 1em University of Wyoming.

\bibitem{conference:MM}
M. Banga and M.S. Hsiao, ``A novel sustained vector technique for the detection of hardware trojans,'' \textit{Proc. International Conference of VLSI Design}, pp. 327-332, 2009.

\bibitem{conference:BB}
B. Bilgic and S. Ozev, ``Guaranteed activation of capacitive Trojan triggers during post production test via supply pulsing,'' \textit{Proc. Design, Automation \& Test in Europe Conference}, pp. 993-998, 2022.

\bibitem{conference:KX}
K. Xiao and M. Tehranipoor, ``BISA: Built-in self-authentication for preventing hardware Trojan insertion,'' \textit{Proc. International Symposium on Hardware-Oriented Security and Trust}, pp. 45-50, 2013.

\bibitem{article:DD}
D. Deng, Y. Wang, and Y. Guo, ``Novel design strategy toward A2 Trojan detection based on built-in acceleration structure,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 12, pp. 4496-4509, Feb. 2020.

\bibitem{article:YH1}
Y. Huang, S. Bhunia, and P. Mishra, ``Scalable test generation for Trojan detection using side channel analysis,'' \textit{IEEE Transactions on Information Forensics and Security}, vol. 13, no. 11, pp. 2746-2760, Nov. 2018.

\bibitem{article:LN}
L. Nguyen, C. Cheng, M. Prvulovic, and A. Zaji\'{c}, ``Creating a backscattering side channel to enable detection of dormant hardware Trojans,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 27, no. 7, pp. 1561-1574, Apr. 2019.


\bibitem{article:SY}
S. Yang, T. Hoque, P. Chakraborty, and S. Bhunia, ``Golden-free hardware Trojan detection using self-referencing,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 30, no. 3, pp. 325-338, Mar. 2022.




\bibitem{conference:YH}
Y. Hou, H. He, K. Shamsi, Y. Jin, D. Wu, H. Wu, ``R2D2: runtime reassurance and detection of A2 Trojan,'' \textit{Proc. International Symposium on Hardware-Oriented Security and Trust}, pp. 195-200, 2018.

%\bibitem{article:SB}
%S. Bhunia, M. Abramovici, D. Agrawal, P. Bradly, M.S. Hsiao, J. Plusquellic, and M. Tehranipoor, \textit{IEEE Design \& Test}, vol. 30, no. 3, pp. 6-17, May 2013.


\bibitem{conference:JH}
J. He, X. Guo, H. Ma, Y. Liu, Y. Zhao, and Y. Jin, ``Runtime trust evaluation and hardware Trojan detection using on-chip EM sensors,'' \textit{Proc. Design Automation Conference}, pp. 1-6, Jun. 2020.

\bibitem{article:YH}
Y. Hou, H. He, K. Shamsi, Y. Jin, D. Wu and H. Wu, ``On-chip analog Trojan detection framework for microprocessor trustworthiness,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 38, no. 10, pp. 1820-1830, Oct. 2019.

%\bibitem{conference:AK}
%A. Kulkarni, Y. Pino, and T. Mohsenin, ``SVM-based real-time hardware Trojan detection for many-core platform,'' \textit{Proc. International Symposium on Quality Electronic Design}, pp. 362-367, 2016.

%\bibitem{article:AK}
%A. Kulkarni, Y. Pino, M. French, and T. Mohsenin, ``Real-time anomaly detection framework for many-core router through machine learning techniques,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 13, no. 1, pp. 10-22, Jan. 2017.

%\bibitem{article:HZ}
%H. Zhao, L. Kwiat, K.A. Kwiat, C.A. Kamhoua, and L. Njilla, ``Applying chaos theory for runtime hardware Trojan monitoring and detection,'' \textit{IEEE Transactions on Dependable and Secure Computing}, vol. 17, no. 4, pp. 716-729, Jul. 2020.

%\bibitem{conference:AM}
%A. Malekpour, R. Ragel, D. Murphy, A. Ignjatovic, and S. Parameswaran, ``Hardware Trojan detection and recovery in MPSoCs via on-line application specific testing,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 13, no. 1, pp. 10-22, Jan. 2017.

%\bibitem{article:BM}
%B.J. Mohd, S. Abed, T. Hayajneh, and M.H. Alshayeji, ``Run-time monitoring and validation using reverse funciton (RMVRF) for hardware Trojans detection,'' \textit{IEEE Transactions on Dependable and Secure Computing}, vol. 18, no. 6, pp. 2689-2704, Nov. 2021.

%\bibitem{article:CB}
%C. Bao, D. Forte, and A. Srivastava, ``Temperature tracking: toward robust run-time detection of hardware Trojans,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 34, no. 10, pp. 1577-1585, Oct. 2015.

\bibitem{article:JZ}
J. Zhu \textit{et al.}, ``Jintide: utilizing low-cost reconfigurable external monitors to substantially enhance hardware security of large-scale CPU clusters,'' \textit{IEEE Journal of Solid-State Circuits}, vol. 56, no. 8, pp. 2585-2601, Aug. 2021.

%\bibitem{article:FK}
%F. Khalid, S.R. Hasan, S. Zia, O. Hasan, F. Awwad, and M. Shafique, ``MacLeR: machine learning-based runtime hardware Trojan detection in resource-constrained IoT edge devices,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 11, pp. 3748-3761, Nov. 2020.




\bibitem{article:JR3}
J. Rajendran, O. Sinanoglu, and R. Karri, ``Building trustworthy systems using untrusted components: a high-level synthesis approach,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 24, no. 9, pp. 2946-2959, Apr. 2016.

\bibitem{article:SS}
S. Sethumadhavan, A. Waksman, M. Suozzo, Y. Huang, and J. Eum, ``Trustworthy hardware from untrusted components,'' \textit{Communications of the ACM}, vol. 58, no. 9, pp. 60-71, Sep. 2015.

\bibitem{article:TR}
T. Reece and W. H. Robinson, ``Detection of hardware Trojan in third-party intellectual property using untrusted modules,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 35, no. 3, pp. 357-366, Jul. 2015.

\bibitem{conference:MB}
M. Beaumont, B. Hopkins, and T. Newby, ``SAFER PATH: security architecture using fragmented execution and replication for protection against Trojaned hardware,'' \textit{Proc. Design, Automation \& Test in Europe Conference}, pp. 1000-1005, Mar. 2012.

\bibitem{conference:XC}
X. Cui et al., ``High-level synthesis for run-time hardware Trojan detection and recovery,'' \textit{Proc. Design Automation Conference}, pp. 1-6, Jun. 2014.

\bibitem{conference:MS}
M. Shatta, I. adly, H. Amer, G. Alkady, R. Daoud, S. Hamed, and S. Hatem, ``FPGA-based architectures to recover from hardware Trojan horses, single event upsets and hard failures,'' \textit{Proc. International Conference on Microelectronics}, pp. 1-4, 2020.

\bibitem{conference:JR2}
J. Rajendren, H. Zhang, O. Sinanoglu, and R. Karri, ``High-level Synthesis for Security and Trust,'' \textit{Proc. International On-Line Testing Symposium}, pp. 232-233, 2013.

\bibitem{article:SR}
S. Rajmohan, N. Ramasubramanian, and N. Naganathan, ``Hybrid evolutionary design space exploration algorithm with defence against third party IP vulnerabilities,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 10, pp. 2602-2614, May 2022.

\bibitem{conference:AS}
A. Sengupta and S. Bhadauria, ``Untrusted third party digital IP cores: power-delay trade-off driven exploration of hardware Trojan secuired datapath during high level synthesis,'' \textit{Proc. Great Lakes Symposium on VLSI}, pp. 167-172, May 2015.

\bibitem{article:YS}
Y. Sun, G. Jiang, S.-K. Lam, and F. Ning, ``Designing energy-efficient MPSoC with untrustworthy 3PIP cores,'' \textit{IEEE Transactions on Parallel and Distributed Systems}, vol. 31, no. 1, pp. 51-63, Jan. 2020.

\bibitem{article:XC}
X. Cui, X. Zhang, H. Yan, L. Zhang, K. Cheng, Y. Wu, and K. Wu, ``Toward building and optimizing trustworthy systems using untrusted components: a graph-theoretic perspective,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 41, no. 5, pp. 1386-1399, Oct. 2020.


\bibitem{article:CL}
C. Liu, J. Rajendran, C. Yang, and R. Karri, ``Shielding heterogeneous MPSoCs from untrustworthy 3PIPs through security-driven task scheduling,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 2, no. 4, pp. 461-472, Aug. 2014.

\bibitem{article:NW}
N. Wang, S. Chen, J. Ni, X. Ling, and Y. Zhu, ``Security-aware task scheduling using untrusted components in high-level synthesis,'' \textit{IEEE Access}, vol. 6, pp. 15663-15678, Jan. 2018.

\bibitem{conference:NW}
N. Wang, M. Yao, D. Jiang, S. Chen, and Y. Zhu, ``Security-driven task scheduling for multiprocessor system-on-chips with performance constraints,'' \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 545-550, 2018.




\bibitem{article:SB1}
S. Bhunia, M. Abramovici, D. Agrawal, P. Bradley, M.S. Hsiao, J. Plusquellic, M. Tehranipoor, ``Protection against hardware trojan attacks: towards a comprehensive solution,'' \textit{IEEE Design \& Test}, vol. 30, no. 3,  pp. 6-17, Jun. 2013.

\bibitem{conference:RC}
R.S. Chakraborty, S. Narasimhan, and S. Bhunia, ``Hardware trojan: threats and emerging solutions,'' \textit{Proc. IEEE International High Level Design Validation and Test Workshop}, pp. 166-171, 2009.











\bibitem{conference:SM}
S. Moulik, R. Devaraj, A. Sarkar, and A. Shaw,  ``A deadline-partition oritented heterogeneous multi-core schedule for periodic tasks,'' \textit{Proc. International Conference on Parallel and Distributed Computing, Applications and Technologies}, pp. 204-210, 2017.

\bibitem{conference:SM-SMC}
S. Moulik, Z. Das, and G. Saikia,  ``CEAT: A cluster based energy aware scheduler for real-time heterogeneous systems,'' \textit{Proc. International Conference on Systems, Man, and Cybernetics}, pp. 1815-1821, 2017.

%\bibitem{conference:YS}
%Y. Sharma and S. Moulik,  ``CETAS: A cluster based energy and temperature efficient real-time scheduler for heterogeneous platforms,'' \textit{Proc. The ACM/SIGAPP Symposium on Applied Computing}, pp. 501-509, 2017.

%\bibitem{article:YS1}
%Y. Sharma, S. Chakraborty, and S. Moulik,  ``ETA-HP: An energy and temperature-aware real-time scheduler for heterogeneous platforms,'' \textit{The Journal of Supercomputing}, vol. 78, pp. 10595-10619, 2022.

%\bibitem{article:YS2}
%Y. Sharma and S. Moulik, ``FATS-2TC: A fault tolerant real-time scheduler for energy and temperature aware heterogeneous paltforms with two types of cores,'' \textit{Microprocessors and Microsystems}, vol. 96, pp. 104744-104744, 2022.

\bibitem{article:SM1}
S. Moulik, ``RESET: a real-time scheduler for energy and temperature aware heterogeneous multi-core systems,'' \textit{Integration, the VLSI Journal}, vol. 77, pp. 59-69, 2021.

\bibitem{article:SM2}
S. Moulik, Z. Das, R. Devaraj, and S. Chakraborty, ``SEAMERS: A semi-partitioned energy-aware scheduler for heterogeneous multicore real-time systems,'' \textit{Journal of Systems Architecture}, vol. 114, pp. 101953-101953, 2021.



\bibitem{article:WH}
W. Hu, C.-H. Chang, A. Sengupta, S. Bhunia, R. Kastner, H. Li, ``An overview of hardware security and trust: threats, countermeasures, and design tools,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 40, no. 6, pp. 1010-1038, Jun. 2021.


\bibitem{article:YC}
Y. Cao, C.Q. Liu, and C.-H. Chang, ``A low power diode-clamped inverter-based strong physical unclonable function for robust and lightweight authentication,'' \textit{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol. 65, no. 11, pp. 3864-3873, Nov. 2018.

\bibitem{article:FP}
F. Pareschi, G. Setti, and R. Rovatti, ``Implementation and testing of high-speed CMOS true random number generators based on chaotic systems,'' \textit{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol. 57, no. 10, pp. 3124-3137, Dec. 2010.





\bibitem{article:QS}
Q. Shi, M.M. Tehranipoor, and D. Forte, ``Obfuscated built-in self-authentication with secure and efficient wire-lifting,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 38, no. 11, pp. 1981-1994, Nov. 2019.

\bibitem{article:DM}
D. Meng, R. Hou, G. Shi, B. Tu, A. Yu, Z. Zhu, X. Jia, Y. Wen, and Y. Yang, ``Built-in security computer: deploying security-first architecture using active security processor,'' \textit{IEEE Transactions on Computers}, vol. 69, no. 11, pp. 1571-1583, Nov. 2020.

\bibitem{conference:AA}
A. Ardeshiricham, Y. Takashima, S. Gao, and R. Kastner, ``VeriSketch: Synthesizing secure hardware designs with timing sensitive information flow properties,'' \textit{Proc. ACM SIGSAC Conference on Computer and Communications Security}, pp. 1623-1638, 2019.

\bibitem{book:TA}
T. Alves and D. Felton, TrustZone: Integrated hardware and soft ware security-enabling trusted computing in embedded systems, ARM, Cambridge, U.K., White Paper, 2014.


\bibitem{conference:HK}
H. Kim, S. Hong, B. Preneel, and I. Verbauwhede, ``STBC: Side channel attack tolerant balanced circuit with reduced propagation delay, \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 74-79, 2017.

\bibitem{article:SP}
S. Patranabis, A. Chakraborty, D. Mukhopadhyay, and P.P. Chakrabarti, ``Fault space transformation: a generic approach to counter differential fault analysis and differential fault intensity analysis on AES-like block ciphers,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 12, no. 5, pp. 1092-1102, May 2017.

\bibitem{article:AS0}
A. Sengupta, D. Roy, and S.P. Mohanty, ``Triple-phase watermarking for reusable IP core protection during architecture synthesis,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 37, no. 4, pp. 1092-1102, Apr. 2018.

\bibitem{article:AS1}
A. Sengupta and M.Rathor, ``IP core steganography for protecting DSP kernels used in CE systems,'' \textit{IEEE Transactions on Consumer Electronics}, vol. 65, no. 4, pp. 506-515, Nov. 2019.

\bibitem{conference:KH}
K. Hasegawa, M. Yanagisawa, N. Togawa, ``Trojan-feature extraction at gate-level netlists and its application to hardware-trojan detection using random forest classifer,'' \textit{Proc. IEEE Symposium on Circuits and Systems}, pp. 74-79, 2017.

\bibitem{article:WS}
W. Shan, S. Zhang, J. Xu, M. Lu, L. Shi, and J. Yang, ``Machine learning assisted side-channel-attack countermeasure and its application on a 28-nm AES circuit,'' IEEE Journal of Solid-State Circuits, vol. 55, no. 33, pp. 794-804, Mar. 2020.


\bibitem{conference:XZ}
X. Zhang and M. Tehranipoor, ``Case study: detecting hardware trojans in third-party deigital IP cores,'' \textit{International Symposium on Hardware-Oritented Security and Trust}, pp. 67-70, 2011.

\bibitem{article:KX}
K. Xiao, D. Forte, Y. Jin, R. Karri, S. Bhunia, and M. Tehranipoor, ``Hardware trojans: lessons learned after one decade of research,'' \textit{ACM Transactions on Design Automation of Electronic Systems}, vol. 22, no. 1, pp. 6-29, May 2016.















\bibitem{conference:DG}
D. Gizopoulos \textit{et al.}, ``Architectures for online error detection and recovery in multicore processors,'' \textit{Proc. Design, Automation and Test in Europe Conference}, pp. 533-538, 2011.

\bibitem{article:NV}
N. Veeranna and B.C. Schafer, ``Hardware Trojan detection in behavioral intellectual properties (IP's) using property checking techniques,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 5, no. 4, pp. 576-585, Oct. 2017.


\bibitem{article:PP}
P.G. Paulin and J.P. Knight, ``Force-directed scheduling for the behavioral synthesis of ASIC's,''  \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 8, no. 6, pp. 661-679, Jun. 1989.

\bibitem{conference:LC}
L. Chang, W. Li, and W. Zhang,  ``Computing a near-maximum independent set in linear time by reducing-peeling,'' \textit{Proc. ACM International Conference on Management of Data}, pp. 1181-1196, 2017.



\end{thebibliography}

% biography section
%
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:

\begin{IEEEbiography}{Nan Wang}
received a B.E. degree in computer science from Nanjing University, Nanjing, China, in 2009, and M.S and Ph.D. degrees from the Graduate School of IPS, Waseda University, Japan, in 2011, and 2014, respectively. He is currently an associate professor in School of Information Science and Engineering, East China University of Science and Technology, Shanghai, China. His current research interests include VLSI design automation, low power design techniques, network-on-chip and reconfigurable architectures. Dr. Wang is a member of IEEE and IEICE.
\end{IEEEbiography}

% if you will not have a photo at all:
\begin{IEEEbiography}{Song Chen}
received a B.S. degree in computer science from Xi'an Jiaotong University, Xi'an, China, in 2000, and M.S. and Ph.D. degrees in computer science from Tsinghua University, Beijing, China, in 2003 and 2005, respectively. From August 2005 to March 2009, he served as a research associate at the Graduate School of IPS, Waseda University, Japan, and from April 2009 to August 2012, he served the same university as an assistant professor. He is currently an associate professor at the Dept. of Electronic Sci. and Tech., University of Science and Technology of China (USTC). His current research interests include several aspects of VLSI physical design automation, on-chip communication system, and computer-aided design for emerging technologies. Dr. Chen is a member of IEEE and IEICE.
\end{IEEEbiography}

\begin{IEEEbiography}{Hongqing Zhu}
received the ph.D. degree from Shanghai Jiao Tong University, Shanghai, China, in 2000. From 2003 to 2005, she was a Post-Doctoral Fellow with the Department of Biology and Medical Engineering, Southeast University, Nanjing, China. She is currently a Professor at the East China University of Science and Technology, Shanghai. Her current research interests include deep learning, pattern recognition, and information security. She is a member of IEEE and IEICE.
\end{IEEEbiography}

\begin{IEEEbiography}{Yu Zhu}
received the B.S. and Ph.D. degrees in electronics and communication engineering from Nanjing University of Science and Technology, Nanjing, China, in 1995 and 1999 respectively. She is currently a professor of electronics and communication engineering in East China University of Science and Technology, Shanghai, P.R. China. In 2005, she was a research scholar in UIUC. Her current research interests include computer design automation, pattern recognition and machine learning.
\end{IEEEbiography}

% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

%\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}



\clearpage

\section*{Authors' Response}
$~~~~$We greatly appreciate the Editor's and the reviewers' insightful and scrupulous reviews of our paper. The comments provided have contributed substantially to the improvement of our manuscript. In what follows, we present the detailed explanations of how the manuscript has been revised to respond to the comments of the associate editor and the reviewers. In the previous pages, the sentences colored blue, red, and cyan are the modified parts.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\section*{Reviewer 1}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

There is no comment.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}





\section*{Reviewer 2}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
I believe the paper has left some major points unaddressed, and the most important one is the threat model.

The followings are missing questions related to this point:
What is the addressed threat model? How does a Trojan (defined at the gate/RTL level) is supposed to tamper tasks running on the cores without having the cores failed? What is the Trojans purpose in this paper? How the Trojan is activated? If one or more of the vendors are Trojan infected how can compromise the whole MPSoC/cluster?

\subsection*{Responses}


\textbf{Q1.} What is the addressed threat model?

\textbf{A1.} In this revised manuscript, we have included the threat model that we focused in this work. This threat model is presented in Section III-A \textit{Threat Model} (mid-right of page 3), which is also presented as follows..



\textcolor{cyan}{We adopt the same threat model in \cite{article:CL, article:YS}, which mainly focuses on detecting (or muting) malicious modifications. The trojan may cause the task running on the malicious 3PIP to either produce incorrect output or generate additional output to trigger trojans in another 3PIP core from the same vendor. As a result, the following two cases can occur at runtime: 1) Due to the insertion of the malicious logic into a 3PIP core, the outputs of the infected cores will be altered at some undetectable points, 2) Trojans distributed on multiple cores (in order to reduce the chance of being detected) can also form malicious communication paths where a malicious logic in one core triggers the trojans in another core using a secret communication channel.}

\vspace*{1em}

\textbf{Q2.} How does a Trojan (defined at the gate/RTL level) is supposed to tamper tasks running on the cores without having the cores failed?

\textbf{A2.} \textcolor{magenta}{Hardware trojan attacks are intended to affect normal circuit operation, potentially with catastrophic consequences in critical applications in the domains of communications, banking, space and military \cite{article:SB1}. They can also aim at leaking secret information from inside a chip through covert channels or affect the reliability of an IC through undesired process changes that cause device ware-out and long-term reliability issues \cite{conference:RC}. In addition, they can be used to assist software attacks by providing hardware back-door, and make the system operate in an incorrect way, such as modifying the scheduling results of a real-time system \cite{conference:SM,conference:SM-SMC,article:SM1,article:SM2}.}

The above explanations are also presented in the mid-right of page 3, magenta colored.

\vspace*{1em}

\textbf{Q3.} What is the Trojans purpose in this paper?

\textbf{A3.} The trojan's purpose we focused in this paper can be summarized as follows.

\textcolor{cyan}{The trojan may cause the task running on the malicious 3PIP to either produce incorrect output or generate additional output to trigger trojans in another 3PIP core from the same vendor.}

The above description on trojans can also be found in the lower-right of page 3, cyan colored.

\vspace*{1em}

\textbf{Q4.} How the Trojan is activated?

\textbf{A4.} Thanks for your comments, and we forgot to add discussions on how the trojan is activated in the previous. In this revised manuscript, we have added the following discussion, which shows how the trojans are activated.

\textcolor{blue}{From the perspective of the activation methods, hardware trojans can be classified as either \textit{always-on} or \textit{conditionally triggered}. An always-on trojan is inserted in rarely accessed places and its footprint is kept small. Conditionally triggered trojans hibernate initially, and are activated either by the trojan implanter or by on-chip triggers \cite{article:CL}.}

The above discussion can also be found in the mid-right of page 3, blue colored.

\vspace*{1em}

\textbf{Q5.} If one or more of the vendors are Trojan infected how can compromise the whole MPSoC/cluster?

\textbf{A5.} This depends on what type of the trojan is, and ``a small hardware modification by an adversary in the 3PIP cores can compromise the whole chip \cite{conference:MH}''.

In this work, the types of trojans we focused might cause the following two situations, which are given as follows.

\textcolor{cyan}{1) Due to the insertion of the malicious logic into a 3PIP core, the outputs of the infected cores will be altered at some undetectable points, 2) Trojans distributed on multiple cores (in order to reduce the chance of being detected) can also form malicious communication paths where a malicious logic in one core triggers the trojans in another core using a secret communication channel.}

The above descriptions can also be found in the lower-right of page 3, cyan colored.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 2}
There should be a clear discussion at the end of the introduction to clarify new contributions of the submitted paper with respect to the conference version. In the cover letter, the authors mentioned in a number of experiments are added.... The reader needs to clearly know what these new experiments are and why they are informative.

\subsection*{Responses}

\textbf{Q1.} There should be a clear discussion at the end of the introduction to clarify new contributions of the submitted paper with respect to the conference version.

\textbf{A1.} Thanks for your valuable suggestion. In this revised manuscript, we demonstrated the new contributions of the work if compared with our earlier conference version. This part is presented at the end of Section Introduction, which are red colored in the mid-left of page 2. This added new contributions are also given as follows.

\textcolor{red}{The earlier conference version of this paper appeared at \cite{conference:NW}. Compared with \cite{conference:NW}, this paper has a number of new contributions.}

\begin{enumerate}
\item \textcolor{red}{This work treats communications with different security importance, and provides a schedule with a minimized system security risk.}

\item \textcolor{red}{Rather than assigning one task to an IP vendor each time, this vendor assignment method groups all tasks into a number of $vc$ (vendor constraint) clusters and assigns an entire cluster to an IP vendor at a time. Furthermore, this vendor assignment method evaluates the number of cores saved when clustering tasks rather than estimating the number of cores required, which speeds up the process time and provides better results.}

\item \textcolor{red}{This work considers core speed variation in the design process. All tasks are first assumed to be performed with the slowest speed, and the vendor assignment will be adjusted after the exact core speeds are determined to further reduce the system security risk.}

\end{enumerate}


\vspace*{1em}

\textbf{Q2.} In the cover letter, the authors mentioned in a number of experiments are added.... The reader needs to clearly know what these new experiments are and why they are informative.

\textbf{A2.} In this revised manuscript, the Section Experimental Results is re-organized. Firstly, an overall evaluation of our method in reducing system risks and the number of cores is presented, which shows the effectiveness of our method. Then, the system risk optimization results under different risk configurations are also compared, and results show that our method obtains the least system security in all tested risk configurations; finally, the results of saving the number of cores with different vendor constraints are also presented, which show that our method obtains the least number of cores under both loose vendor constraints and tight vendor constraints.

The above explanation is also presented in the cover letter. 

\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\subsection*{Comment 3}
The authors have used a clustering method. However, it is not clear how much effective it is. For example, some IPs might be application-specific IPs and might not be able to support every task assigned to them. At least, clustering tasks to different vendors IPs seems not an effective decision.

\subsection*{Responses}
Thanks for your advise. The tasks we focused in this work are the application-specific tasks, and our method is also applicable with application-specific tasks. We forgot to give the task model and explain why our method is also suitable for application-specific tasks.

In this revised manuscript, the detailed task model is also discussed, which is presented in the upper-right of page 4, red colored. The follow paragraph also gives the task model.

\textcolor{red}{In this work, we target embedded platforms which executes application-specific tasks and have high security requirements. Such platforms cannot handle tasks that occur suddenly at runtime, and they are widely-used in auto-motive, safety-critical systems, etc. In such systems, designers always have the prior knowledge of the application and its runtime constraints, which requires designers to perform security-driven customizations to meet performance and area requirements \cite{article:YS}}.

To deal with the application-specific tasks in task clustering stage, our proposed method only clusters the tasks that can be performed in the same type of IP. For the data-dependent tasks that must be performed on different types of IP cores, they cannot be clustered, and the communications between them are always inter-core communications.

This explanation is presented in the mid-left of page 6, red colored, which is also given as follows.

\textcolor{red}{For the application-specific IPs, data-dependent tasks might have to be executed by different IP cores, resulting that the corresponding edge cannot be contracted. Therefore, we only focus the edges that can be contracted to reduce the schedule length. In the following discussion, we assume that all edges can be contracted for simplicity.}

%The following situation of contracting edges are added in this revised manuscript, which is presented in the mid-right of page 6, red colored.

%\textcolor{red}{The connected two tasks cannot be bound to the same type of IP cores;}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\subsection*{Comment 4}
In Formula (1), the alpha parameter is not clearly defined. Is that a normalized parameter and how it can be obtained? What is the minimum/maximum of alpha?

\subsection*{Responses}
In the previous manuscript, The following objective function is introduced.

\textit{The objective function of the above problem can be formulated as follows:
\begin{equation}
min:~\alpha*risk_s+core
\end{equation}
\noindent where $risk_s$ is the system security risk due to the unprotected communications, $core$ is the number of cores required by the schedule, and $\alpha$ is a parameter large enough to keep the minimization of system security risk as the first priority.}

Our purpose of introducing this objective function is to show that this work jointly optimize the system security risk and the number of cores. However, \textbf{these two optimization targets do not have trade-off relationships}, and therefore, we removed this objective function in this revised manuscript.





\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\subsection*{Comment 5}
The graph theory terms used in the paper need to be discussed based on their application in this paper.

\subsection*{Responses}
Thank you very much for your suggestions. In this revised manuscript, the discussions of graph theory terms are also presented, which are given as follows.

(1) $TVG$, cyan colored, lower-right of page 5.

\textcolor{cyan}{The \textbf{timing violated graph} ($TVG=(V_T, E_T)$) is then constructed by all paths from $s$ to $t$ whose lengths exceed the performance constraints, and it is an induced subgraph of $TG$}.

(2) $ECCG$, cyan colored, upper-right of page 6.

\textcolor{cyan}{Then, a weighted \textbf{edge contraction conflict graph} ($ECCG=(V_E,E_E)$) is constructed to represent whether every pair of edges in $TVG$ can be contracted simultaneously}.

(3) MWIS of weighted $ECCG$, cyan colored, mid-right of page 6.

\textcolor{cyan}{The maximum weight independent set (MWIS) of the weighted $ECCG$ is calculated by the method proposed in \cite{conference:LC}, and the target is to a set of edges with maximum weight that can be contracted simultaneously.}

(4) $VCFG$, cyan colored, lower-left of page 7.

\textcolor{cyan}{The \textbf{vendor conflict graph} ($VCFG=(V_c, E_{cf})$) is constructed from the performance-constrained clustering results, and it represents whether two clusters must be assigned to different vendors.}

(5) $VCPG$, cyan colored, mid-right of page 7.

\textcolor{cyan}{The \textbf{vendor compatible graph} ($VCPG=(V_c, E_{cp})$) is the complement graph of the $VCFG$, and an edge in $E_{cp}$ indicates that the connected clusters can be assigned to the same vendor.}


\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\subsection*{Comment 6}
Results shown in figure 10 do not show a breaking achievement for the proposed method, maybe, the method shows a better performance in a different benchmark. We still see that the system has a relatively high risk in many benchmarks. In several benchmarks, the numbers are very close except for robot and sparse benchmark.  Benchmarks can be categorized by their application for easier comparison.

\subsection*{Responses}

In this revised manuscript, the Section Experimental Results is re-organized. We first demonstrate the effectiveness of our method in reducing system risks and the number of cores, and then test the system risk optimization results under different risk configurations, and finally show the results of saving the number of cores with different vendor constraints. The benchmarks are categorized into two types, which are tasks graphs modelled from actual applications (the results are presented in Table IV), and random task graphs (the results are given in Table V). Furthermore, we also discussed the reasons why some task graphs still have a relatively high risk, which is red colored in the mid-left of page 11, and the explanation is also given as follows.

\textcolor{red}{Table \ref{table:PCTS_R} illustrates the comparison results of five random generated task graphs. The number of edges in these task graphs are much larger then the edges of robot, sparse, and fpppp, and therefore the risk of each communication is relatively much smaller (refer to Equ. \ref{equ:risk_set1}). The comparison results indicate that our proposed method also obtained the best results in reducing both the $risk_s$ and the number of cores.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 7}
This paper's English is poor and needs a proofread. I saw several grammatical errors here and there. For example, the very first sentence of the abstract says: ... and a set of
security-driven constraints is ($-->$ are) imposed...

\subsection*{Responses}
Thanks for the valuable comments, and I've improved the writings following your instructions.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}







\section*{Reviewer 3}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
There is a lack of clarity in the motivation of the work, especially when the problem is getting introduced in the first section. Although, I understood the problem but it will help the readers if the motivation is rewritten. It should be concise and clear.

\subsection*{Responses}
Thank you very much for your valuable suggestions. In this revised manuscript, we have made two modifications to better demonstrate our motivation.

The first modification is given in Section I Introduction, which is blue colored in the lower-right of page 1. This part of motivation is also given as follows.

\textcolor{blue}{The above mentioned works focused on area optimization mainly address the problem in task scheduling stage \cite{article:SR}, and it is because that the number of cores required can only be evaluated after vendor assignment. However, vendor assignment is a prior stage of task scheduling, whose results significantly affect the area optimization results in task scheduling, and ignoring the area optimization during vendor assignments limits the area optimization results. Furthermore, these researchers treated each communications equally when optimizing the system performance \cite{article:CL, article:NW, conference:NW}, but removing security constraints from different communications causes different security loss and communications with larger security importance should have higher protection priorities\cite{article:XC}}.

The second modification is given in Section III-C Motivations. This section is re-rewrote to briefly show our motivation, and this section is presented in the lower-left of page 4.




\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 2}
Although the paper proposes a security-aware task schedule, however scheduling aspects on heterogeneous multicore platforms have not been discussed at all. I understand that the work is security aware, but a discussion on recent task schedulers for heterogeneous multicore platforms is required.

\subsection*{Responses}

Thanks for your suggestions. In the Section II-B Related Work of this revised manuscript, we have discussed a number of researches that incorporate security constraints in task scheduling, and all these researches are for heterogeneous multicore platforms.

The discussion of these researches are given as follows, which is also presented in the mid-left of page 3, red colored.

\textcolor{red}{However, fulfilling the security constraints in task scheduling always incurs significant overheads of system performance, chip area and power of heterogeneous multicore platforms, and researchers have started to reduce these overheads of MPSoCs built from 3PIP cores through task scheduling. Rajmohan \textit{et al.} \cite{article:SR} proposed a PSO-based hybrid evolutionary algorithm, and Sengupta \textit{et al.} \cite{conference:AS} proposed a bacterial foraging optimization-based design space exploration method to achieve the task schedule with higher security and less hardware overheads. Sun \textit{et al.} \cite{article:YS} minimized the energy consumption while simultaneously protecting the MPSoC against the effects of hardware trojans with security constraints. Cui \textit{et al.} \cite{article:XC} solved the online hardware trojan detection and recovery problem with graph-theoretic models that minimize the implementation cost of the design budget and area overhead. Liu \textit{et al.}\cite{article:CL} proposed a set of task scheduling methods to reduce the increments of performance and hardware due to the security constraints. Wang \textit{et al.} \cite{article:NW, conference:NW} optimized the design budget and system performance with a minimized number of intra-core communications which are not protected by security constraints.}


\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 3}
A symbol table is required which the readers can consult throughout the paper.

\subsection*{Responses}
Thanks for your suggestion. We have added a table of notations in Section III, which is red colored in the lower-left of page 5, and this table is quoted in the mid-right of page 5, red colored.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 4}
In the objective function (Equation 1), explain about alpha more. It is not clear.

\subsection*{Responses}
In the previous manuscript, The following objective function is introduced.

\textit{The objective function of the above problem can be formulated as follows:
\begin{equation}
min:~\alpha*risk_s+core
\end{equation}
\noindent where $risk_s$ is the system security risk due to the unprotected communications, $core$ is the number of cores required by the schedule, and $\alpha$ is a parameter large enough to keep the minimization of system security risk as the first priority.}

Our purpose of introducing this objective function is to show that this work jointly optimize the system security risk and the number of cores. However, \textbf{these two optimization targets do not have trade-off relationships}, and therefore, we removed this objective function in this revised manuscript.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 5}
There are a few typos. For example, u.t.. on page 6, right column. Correct them.

\subsection*{Responses}
Thanks for the valuable comments, and I've improved the writings following your instructions.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 6}
The algorithms with whom the proposed work has been compared, need to be explained in a better way.

\subsection*{Responses}

In this revised manuscript, we have followed your suggestion, and explained the algorithms that compared with more details. This explanation is presented in the mid-right of page 10 with red color, which is also given as follows.

\textcolor{red}{\textbf{Our} proposed method is then compared with two other methods to demonstrate the effectiveness. The first approach is ``\textit{Cluster-based approach}'' (\textbf{C-B} for short) \cite{article:CL}. This approach optimizes the schedule length by placing critical tasks on a single core, and then colors the performance-driven schedule to fulfill security constraints. The second approach is ``\textit{Min-cut-based approach}'' (\textbf{MC-B} for short) \cite{article:NW}. This approach boosts performance by iteratively contracting the edges selected by the max-flow min-cut algorithm, then assigns tasks to IP vendor with traditional graph coloring method, and finally schedules tasks with the force-directed scheduling-based method.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 7}
 In Section - Performance-Constrained Task Scheduling Results, why is the proposed work is faring better results? Analyze in a better way. It is true for other results as well.

\subsection*{Responses}

In this revised manuscript, the Section Experimental Results is re-organized. We first demonstrate the effectiveness of our method in reducing system risks and the number of cores, and then test the system risk optimization results under different risk configurations, and finally show the results of saving the number of cores with different vendor constraints. The experimental results are compared, and the reasons behind the results are also discussed. We hope this version of Section Experimental Results can meet your requirements.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}





\section*{Reviewer 4}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
One of the problems is that the paper is a marginal paper compared to related work. Adding number of cores as a new objective is the main contribution which is not enough for being original for publication. Originality is limited.

\subsection*{Responses}

Thanks for your comments. However, we believe that our work obtained some contributions that worth to be published in IEEE TVLSI, and these contributions could be summarized as follows.

\begin{enumerate}
    \item There are a number of related work that optimize the system performance by clustering tasks, and some of them noticed that the attack to different communications causes different system loss \cite{article:SR, article:XC}. However, there is little consider this different system loss (we named as security risk) in the design process. As far as we know, this is the first work that optimize the system performance with security risk variation. Our work enables designers to provide a security-driven task schedule, where the communications that might cause larger system loss obtain higher protection priority.
    \item Incorporating security constraints in task scheduling incurs significant overheads of area, and reducing the number of cores is one of the effective method to reduce the chip area. There are some work focus on the area optimization in task scheduling \cite{article:SR, article:XC, article:NW}, but none of them tries to reduce the number of cores in vendor assignment stage, because it is inaccurate to estimate the number of cores during vendor assignment stage. which limits the optimization space of reducing cores. Our proposed method evaluates the number of cores saved when clustering tasks rather than estimating the number of cores required, and therefore, can help to reduce the number of cores during vendor assignment, which enlarges the optimization space of reducing cores.
    \item This work can also handle the following scenarios. 1) The core speed variation, and it is because cores from different IP vendors might have different speed. 2) Tight vendor constraint, and it is because that we do not always have sufficient IP vendors to buy IPs. Furthermore, purchasing IPs of the same function from many IP vendors increases the design cost, and might exceed the design budget. 3) Application-specific IPs. The application-specific IPs might not be able to support every task, and we build the $VCFG$ and $VCPG$ for each type of IP, and co
\end{enumerate}


\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 2}
Reasoning behind the work and motivations are not strong and not acceptable sometimes. For example, authors said in Introduction that "... the growing number of mission-critical applications (e.g., finance and military) that use MPSoCs means that security is the highest priority issue, whereas the increasing integration of third-party Intellectual Property (3PIP) and the outsourcing of fabrication indicate that most MPSoCs are not 100\% trustworthy" which brings some key questions: 1) Security is the highest priority in MPSoC-based mission-critical apps. Are you sure? How do you prove? Any references/evidences are required. 2) Although outsourcing of fabrication indicate MPSoCs are not 100\% trustworthy, why should mission-critical applications use them (because we know they are not trustworthy. They need to use from trusty vendors)?


\subsection*{Responses}
\textbf{Q1.} Security is the highest priority in MPSoC-based mission-critical apps. Are you sure? How do you prove? Any references/evidences are required.

\textbf{A1.} Thanks for your advise. In our previous manuscript, we used ``security is the highest priority'', and it is not proper. However, many applications, such as banking and military systems, have high security requirements \cite{conference:XZ}. This is also given in the lower-right of page 2, blue colored.


\vspace{1em}

\textbf{Q2.} Although outsourcing of fabrication indicate MPSoCs are not 100\% trustworthy, why should mission-critical applications use them (because we know they are not trustworthy. They need to use from trusty vendors)?

\textbf{A2.} The mission-critical applications still use the MPSoCs designed with 3PIPs. Similar comments can be found in \cite{conference:XZ, article:YS}. The reasons are summarized as follows:

(1) In practice, very seldom IPs are developed by the SoC integrator, and most of them are currently being designed offshore by 3PIP vendors \cite{conference:XZ}.

(2) Integrating 3PIP cores allows designers to quickly respond to the increasing demands in energy consumption, functionality as well as programmability without sacrificing design productivity \cite{article:YS}.

%\textcolor{blue}{However, many applications, such as banking and military systems, have high security requirements \cite{conference:XZ}}

To better describe the situations that 3PIP cores are used in many applications who have high security requirements, the follow discussion is also added in the lower-left of page 1, red colored.

\textcolor{red}{This raises security concerns \cite{article:SB} since a small hardware modification by an adversary in the 3PIP cores can compromise the whole chip \cite{conference:MH}. If such chips run time-critical applications (e.g. in autonomous vehicles), the hardware trojan attack may lead to catastrophic or life-threatening consequences \cite{conference:AM1}. Similarly, if these chips are used in information critical systems (eg. banking), the confidentiality and integrity of the user's data can be compromised \cite{conference:FK}.}


\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 3}
This work is under concept of hardware trojans that any security issues should be detected by the literature in hardware trojan detection methods. Detection at high level of abstraction (scheduling) is not smart enough and has false positive or false negative ratios. Moreover, diversity over cores and others, are conventional methods for reliability purposes. Consequently, core-level reliability models (that are also popular in mission-critical applications) can reduce sensitivity to hardware trojans.

\subsection*{Responses}

\textbf{Q1.} This work is under concept of hardware trojans that any security issues should be detected by the literature in hardware trojan detection methods.

\textbf{A1.} Actually, detecting all hardware trojans cannot be proposed by these security constraints. What we suppose is that the edge protected by the security constraints has less risk of being attacked by the hardware trojans. Therefore, the target of this work is to reduce these risk to reach the performance constraints.

To clearly describe this, we have added the following description is this revised manuscript, which is also presented in the upper-right of page 5, cyan colored.

\textcolor{cyan}{Although incorporating security constraints in the design process cannot guarantee the detection of all hardware trojan attacks, the risks caused by hardware trojans can be significantly reduced. In this paper, the security risk of a intra-core communication is regarded as the reduced risk after applying security constraints to this communication, and we assume that different communications face different security risks.}

\vspace*{1em}

\textbf{Q2.} Detection at high level of abstraction (scheduling) is not smart enough and has false positive or false negative ratios. Moreover, diversity over cores and others, are conventional methods for reliability purposes. Consequently, core-level reliability models (that are also popular in mission-critical applications) can reduce sensitivity to hardware trojans.

\textbf{A2.} Thanks for your comments. We think that incorporating security constraints at high-level synthesis is also an effective way to protect the MPSoCs, and there exist a number of recent work focusing on hardware trojan protection through task scheduling in context of security constraints \cite{article:JR3, conference:XC, conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}. 

Furthermore, the paper \cite{article:JR3} gives the conclusion ``A high-level synthesis is the ideal level for incorporating security constraints '', and this paper also gives the reasons, which are listed as follows.

\begin{enumerate}
    \item The 3PIPs are typically designed and delivered as RTL. Furthermore, the targeted trojans enter the trustworthy SoC through these potentially untrusted 3PIPs.
    \item security constraints are independent of the gate-level libraries and the implementation technology are structured as interactions between the 3PIPs.
    \item Several high-level synthesis tools are available, thereby enabling incorporation of these constraints.
\end{enumerate}

In this revised manuscript, the following description is also added to explain the reason why we incorporating security constraints in the high-level of abstraction. This description can also be found in the lower-left of page 3, blue colored.


\textcolor{blue}{Security constraints for duplication, 3PIP vendor diversity have been recently proposed for hardware trojan protection, and high-level synthesis is the ideal level for incorporating security constraints \cite{conference:JR2}}.

\vspace*{1em}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 4}
The level of abstraction of the proposed solution i.e., scheduling method, is far away of scope of this journal (Trans. On VLSI).



\subsection*{Responses}

The following three reasons make us believe that our work, which focus on the task scheduling in context of security constraints, belongs to the scope of this journal (IEEE TVLSI).

(1) IEEE TVLSI has published a number of papers that incorporated security constraints in high-level synthesis, such as:

--J. Rajendran, O. Sinanoglu, and R. Karri, ``Building trustworthy systems using untrusted components: a high-level synthesis approach,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 24, no. 9, pp. 2946-2959, Apr. 2016.

\vspace*{1em}

(2) IEEE TVLSI has published a number of papers that focus on Task scheduling algorithms, such as:

-- J. Li, Y. Liu, H. Li, Z. Yuan, C. Fu, J. Yue, X. Feng, C.J. Xue, J. Hu, and H. Yang, ``PATH: performance-aware task scheduling for energy-harvesting nonvolatile processors,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 26, no. 9, pp. 1671-1684, Sep. 2018.

-- Y. Wang, J. Liu, and J. Hu, ``Communication-aware task scheduling for energy-harvesting nonvolatile processors,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 28, no. 8, pp. 1796-1806, Aug. 2020.


\vspace*{1em}

(3) One of the Topics listed in the ``\textbf{aims \& scope}'' of IEEE TVLSI is ``\textbf{Cost, Performance Tradeoffs of VLSI/ULSI Systems}'', and scheduling is one of the methods to realize the cost,performance tradeoffs. Therefore, we think that our work is within the scope of IEEE TVLSI.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 5}
Verification of the method is weak. How do authors ensure the method is effective against hardware trojans? What type of trojans is the main concern? How much effective is the method?

\subsection*{Responses}

\textbf{Q1.} How do authors ensure the method is effective against hardware trojans?

\textbf{A1.} The effectiveness of the security constraints in protecting MPSoC were demonstrated by the related works which also discuss the necessity of introducing security constraints in task scheduling during the design process. These constraints were proposed to enable MPSoC to (1) detect trojans that maliciously alter task outputs, and (2) mute trojan effects or prevent collusion between 3PIP cores from the same vendor.\cite{article:CL}.

In addition, these security constraints cannot guarantee that the system is 100\% save, but we the communication without security constraints faces larger security risk. Our target is to minimize the total increased security risks of all un-protected communications, and the effectiveness of minimizing the increased security risk can be demonstrated by the results showed in columns $ratio$ in Table III and V.

\vspace*{1em}

\textbf{Q2.} What type of trojans is the main concern?

\textbf{A2.} In this revised manuscript, the threat model is also presented, which can be found in Section III-A, mid right of page 3. The trojan's type and its purpose we focused in this paper are also included in this section, which can be summarized as follows (also cyan colored in the mid-right of page 3).

\textcolor{cyan}{The trojan may cause the task running on the malicious 3PIP to either produce incorrect output or generate additional output to trigger trojans in another 3PIP core from the same vendor.}

\vspace*{1em}

\textbf{Q3.} How much effective is the method?

\textbf{A3.} To better illustrate the effectiveness of our proposed method, the whole Section Experimental Results is re-organized in the revised manuscript. We first demonstrate the effectiveness of our method in reducing system risks and the number of cores (please see Tables IV and V in page 11), and then test the system risk optimization results under different risk configurations (please see Fig. 9 in page 12), and finally show the results of saving the number of cores with different vendor constraints (please see Table VI in page 12).% Furthermore, we also discussed the reasons why some task graphs still have a relatively high risk, which is red colored in the mid-left of page 11, and the explanation is also given as follows.




\vspace*{1em}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 6}
How is security risk evaluated (Fig. 4(C) red values)?

\subsection*{Responses}
The security risk of each communication is the input of our problem, and our proposed method enables designers to treat communications with different security risks. We have stated this in the Section III-D Problem Description, which is blue colored in the mid-right of page 5.

Traditional methods ignore the security risk variation, and treat each communication equally. However, attackers always choose the interested targets to attack, meaning that the security risk of communications are different in most situations, and MPSoC designers can set communications with relative larger risk if they want these communications get higher priority of protection.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 7}
Problem definition which is done in Section III is clear, however, the method of optimization is to solve dual objective problem with only one single objective optimization. As authors may know, this approach finds only one of possible solutions not all the cases. Moreover, this is the first time that I see performance parameter does not have more interested compared to security. Also, why are not there any defined constraints?

\subsection*{Responses}
\textbf{Q1.} Problem definition which is done in Section III is clear, however, the method of optimization is to solve dual objective problem with only one single objective optimization

%\textbf{A1.} Introducing security constraints in task scheduling now becomes one of the popular method to protect the MPSoC, but this causes significant overheads of area (because every task have to be executed twice) and performance (all the communications are the inter-core communications). Since both area and performance are sensitive to MPSoC designers, and we can sacrifice a litter security to significantly reduce both the performance and area. In this work, The performance is treated as a constraint, and the targets are both system risk optimization and area optimization.

\textbf{A1.} Thank you very much for your suggestion, and we are sorry that the objective function in the previous manuscript make you confused. In the previous manuscript, The following objective function is introduced.

\textit{The objective function of the above problem can be formulated as follows:
\begin{equation}
min:~\alpha*risk_s+core
\end{equation}
\noindent where $risk_s$ is the system security risk due to the unprotected communications, $core$ is the number of cores required by the schedule, and $\alpha$ is a parameter large enough to keep the minimization of system security risk as the first priority.}

Our purpose of introducing the above objective function is to show that this work jointly optimize the system security risk and the number of cores. However, \textbf{these two optimization targets do not have trade-off relationships}, and therefore, we removed the above objective function in this revised manuscript. Instead, we use the problem description (blue colored in the mid-right of page 5) to show the targets of this work, which is given as follows.

\textcolor{blue}{The inputs of this problem are task graph $TG$, vendor and performance constraints, core speeds of vendors, and security risk of each communication. The target is to find a schedule with the least system security risk, and the number of cores required is also optimized.}


\vspace{1em}

\textbf{Q2.} This is the first time that I see performance parameter does not have more interested compared to security

\textbf{A2.} We set performance as constraint in this work, and this shows that performance is also a key consideration of our work. Besides, one of the targets in this work is to sacrifice least security to meet the desired system performance, which also indicates the importance of performance.

\vspace{1em}

\textbf{Q3.} Why are not there any defined constraints?

\textbf{A3.} Vendor constraints are also considered in this work, it is because that we do not always have sufficient IP vendors to buy IPs, and purchasing IP of the same function from many IP vendors significantly increases the design cost. The vendor constraints are also described in the problem description, which is blue colored in the mid-right of page 5.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\subsection*{Comment 8}
Equation (3) means that how much in total $e_{ij}$ will decrease time, however only critical path (longest path) is more important.

\subsection*{Responses}
The edge $e_{ij}$ we discussed in equation (4) is the edge in timing violated graph ($TVG$), which consists of all tasks with negative slack time. The edges in $TVG$ are in the paths whose delay exceeds the performance constraints. Optimizing the critical path length can reduce the current schedule length, but if we try to reduce the schedule length to meet the performance constraints, all the paths in $TVG$ have to be optimized sooner or later. Therefore, all the edges in $TVG$ are equally treated when optimizing the performance constraints.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 9}
Equation (4) which divides delay by security does not have reasons and is strange (why are not differentiation or any other functions used? For example, root function with one as radicand and the other as index?).

\subsection*{Responses}

Equation (4) is presented as follows.

\textit{The total weight that evaluates an edge $e_{ij}$ contraction in $TVG$ is denoted as $w(e_{ij})$, which is calculated as follows:
\begin{equation}
w(e_{ij}) = \frac{w_{dly}(e_{ij})}{risk(e_{ij})}
\end{equation}
\noindent where $risk(e_{ij})$ denotes the security risk if $e_{ij}$. Fig. \ref{subfig:tvg1-2} illustrates the $w_{dly}(e_{ij})$ and $risk(e_{ij})$ in $TVG$, which are indicated next to the edges.}


The purpose of Equation (4) is to calculate the weight of an edge, which evaluates the affections of contracting this edge. The effectiveness after an edge contraction can be summarized into the following two categories:

1) the lengths of paths that passing though this edge is reduced, which is evaluated by $w_{dly}(e_{ij})$;

2) The system security risk increases because the security constraint (isolation-with-diversity) is removed, which is denoted as $risk(e_{ij})$.

In the performance optimization stage, we hope to choose the edge with larger $w_{dly}(e_{ij})$, while the increased security risk is smaller, and therefore, Equation (4) is introduced to evaluate the weight of contracting an edge.

In addition, we also added the discussion before introducing Equation (4) (please see the lower-left of page 6, blue colored), and it is given as follows.

\textcolor{blue}{Our target is to contract the edges with larger $w_{dly}(e_{ij})$, while the increased security risk is smaller, and the total weight that evaluates an edge $e_{ij}$ contraction in $TVG$ is denoted as $w(e_{ij})$, which is calculated as follows:}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\subsection*{Comment 10}
The constraint said as ``If an edge is contracted during performance optimization, all its brother edges can no longer be contracted" is also hold for contacting a candidate edge. This constraint is not normal. Moreover, the reason said for this constraint did not consider that communication could be reduced for brother edge.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\begin{figure*}[!t]
\centering
\begin{tabular}{cccc}
\subfigure [] {
%\hspace*{-1em}
\includegraphics[width=2.8cm]{figure/revised_paper/bro_edge0.pdf}\label{subfig:bro_edge0}
} &
\subfigure [] {
\includegraphics[width=2.5cm]{figure/revised_paper/bro_edge1.pdf}\label{subfig:bro_edge1}
} &
\subfigure [] {
\includegraphics[width=2.46cm]{figure/revised_paper/bro_edge2.pdf}\label{subfig:bro_edge2}
} &
\subfigure [] {
\includegraphics[width=2.5cm]{figure/revised_paper/bro_edge3.pdf}\label{subfig:bro_edge3}
}
\end{tabular}
\caption{Example of brother edge contraction. \subref{subfig:bro_edge0} Example of task graph. \subref{subfig:bro_edge0} ASAP schedule of the task graph. \subref{subfig:bro_edge2} ASAP schedule if $e_{1,3}$ is contracted. \subref{subfig:bro_edge3} ASAP schedule if $e_{1,3}$ and $e_{2,3}$ are both contracted.}
%\vspace*{-0.9em}
\label{fig:bro_edge}
\end{figure*}






\subsection*{Responses}
Thanks for your advise. Our un-proper writing in the previous manuscript confused you. It is possible that contracting brother edges can still reduce the schedule length, and its our mistake that we forgot to state this pre-condition.

The reason of introducing the constraint ``If an edge is contracted during performance optimization, all its brother edges can no longer be contracted" can be explained as follows.

Suppose $e_{ij}$ is an brother edge of a contracted edge $e_{kj}$, which points from task $v_i$ to task $v_j$, and this $e_{ij}$ is in the critical path. Contracting $e_{ij}$ reduces the communication delay in the critical path by $dly(e_{ij})$, but tasks $v_k$ and $v_i$ may both in the current critical path, meaning that the schedule length reduction $SL_{re}$ to be.
\begin{equation}
SL_{re} = dly(e_{ij}) - dly(v_k)
\end{equation}

The above equation means:
1) $SL_{re}$ may likely be negative, indicating the schedule length is increased after contracting a brother edge.
2) The schedule length reduction cannot be accurately evaluation because not all brother tasks are in the critical path after edge contraction.

The above explanation is also demonstrated by the following example:

Fig. \ref{subfig:bro_edge0} gives the task graph, and the communication-to-computational ratio is 0.5, and Fig. \ref{subfig:bro_edge1} shows its ASAP schedule, whose schedule length is 7 $ut$. The critical path is $e_{1,3}$, and the ASAP schedule length can be reduced to 5 $ut$ by contracting $e_{1,3}$ (see Fig. \ref{subfig:bro_edge2}). Then, the critical path becomes $e_{2,3}$, which is also a brother edge of contracted edge $e_{1,3}$. Contracting $e_{2,3}$ means that all these three tasks are executed sequentially in the same IP core, and the ASAP schedule increases to 6 $ut$ (see Fig. \ref{subfig:bro_edge2}).

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 11}
Constraints listed as (1) and (2) in lines 42 and 44, respectively, do not make sense. It suppresses optimization solutions radically.

\subsection*{Responses}

The constraints used in the previous manuscript when constructing $ECCG$ is listed as follows.


\textit{Two vertices in $V_E$ are connected when their corresponding edges cannot be contracted simultaneously, under one of the following three situations:
\begin{enumerate}
\item These two edges are brother edges;
\item These two edges belong to the same path in $TVG$.
\end{enumerate}}


The purpose of introducing these two constraints is to minimize the induced security risk due to edge contraction under the performance constraints.


(1)The reason of introducing the first constraint : The reason is explained by the example shown in Fig. \ref{fig:bro_edge}.


(2)The reason of introducing the second constraint (which is constraint (3) in the above description): We hope that the path length is not over optimized, because it causes additional system security risk. The following example explains the reason. Suppose that edges $e_1$ and $e_2$ belong to the same path in $TVG$, and contracting either $e_1$ or $e_2$ will make the path length smaller than the performance constraint. However, if $e_1$ and $e_2$ are both contracted, the path length is over optimized, and this causes additional system risk increment. This constraint is used to avoid the above situation,

To better describe our purposes of introducing these constraints in the revised paper, we also added some descriptions behind these two constraints (in the mid-right of page 6, red colored), which are also given as follows.

\textcolor{red}{Two vertices in $V_E$ are connected when their corresponding edges cannot be contracted simultaneously, under one of the following two situations:
\begin{enumerate}
\item Two edges that share the same source or target node (with respect to the multicore parallel execution);
\item These two edges belong to the same path in $TVG$ (to prevent the over optimization of path length).
\end{enumerate}}

Further, explanations of introducing these two constraints are also included in this revised manuscript (in the upper-right of page 6, blue colored), which are presented as follows.

\textcolor{blue}{However, not all edges can be contracted with respect to the multicore parallel execution. Let $in\_edge(v)$ be the set of edges that end with $v$, and let $out\_edge(v)$ be the set of edges that start from $v$. Edges in $TG$ that belong to the same $in\_edge(v)$ or $out\_edge(v)$ are called \textbf{brother edges}. If an edge is contracted during performance optimization, all its brother edges can no longer be contracted. The reason is that contracting brother edges means the tasks that once could be executed parallel in different cores now must be executed sequentially in the same core, and this may result in an increased schedule length. For example, contracting the brother edges $e_{4,6}$ and $e_{4,7}$ in Fig. \ref{subfig:tvg1-2} makes $v_6$ and $v_7$ must be conducted sequentially in the same core, but they once can be computed at the same time in different cores.}

\textcolor{blue}{In addition, two edges belong to the same path in $TVG$ should not be contracted simultaneously, and this avoids the over optimization of path length, which causes additional system security risk. The following example explains the reason. Suppose that edges $e_1$ and $e_2$ belong to the same path in $TVG$, and contracting either $e_1$ or $e_2$ will make the path length smaller than the performance constraint. However, if $e_1$ and $e_2$ are both contracted, the path length is over optimized, and this causes additional system risk increment.}



\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 12}
All instances of trojan are written with capital $<$T$>$.

\subsection*{Responses}
Thanks for your suggestion, and we correct these un-proper writings in this revised manuscript.

The reason of we wrote trojan as ``Trojan" in the previous manuscript is that:
We found that some of the researchers wrote ``Trojan" throughout their papers, such as ``Run-time monitoring and validation using reverse function (RMVRF) for hardware trojans detection, IEEE Transactions on Dependable and Secure Computing, 2021", ``Applying chaos theory for runtime hardware trojan monitoring and detection, IEEE Transactions on Dependable and Secure Computing, 2020", ``Toward building and optimizing trustworthy systems using untrusted components: a graph-theoretic perspective, IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 2020". Therefore, we wrote trojan with capital $<$T$>$ in our previous manuscript.

Examples of ``Trojan" writings in the above papers are also presented in Fig. \ref{fig:trojan_write}



\begin{figure}[!h]
\centering
\begin{tabular}{c}
\subfigure [] {
\hspace*{-1.5em}
\includegraphics[width=6.6cm]{figure/revised_paper/trojan_1.png}\label{subfig:trojan_1}
} \\
\subfigure [] {
\includegraphics[width=6.6cm]{figure/revised_paper/trojan_2.png}\label{subfig:trojan_2}
} \\
\subfigure [] {
\includegraphics[width=6.6cm]{figure/revised_paper/trojan_3.png}\label{subfig:trojan_3}
}
\end{tabular}
\caption{Examples of ``Trojan'' writings. \subref{subfig:trojan_1} ``Trojan'' writings in ``Run-time monitoring and validation using reverse function (RMVRF) for hardware trojans detection''. \subref{subfig:trojan_2} ``Trojan'' writings in ``Applying chaos theory for runtime hardware trojan monitoring and detection''. \subref{subfig:trojan_3} ``Trojan'' writings in ``Toward building and optimizing trustworthy systems using untrusted components: a graph-theoretic perspective''.}
\vspace*{-0.9em}
\label{fig:trojan_write}
\end{figure}


\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 13}
In the following descriptions, the duplicated task of $v_i$ is denoted as $v_i'$ is meaningless.

\subsection*{Responses}
Thanks for your suggestion, and we have removed this sentence in this revised manuscript.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 14}
Fulfills security constraints at the finest granularity, but this incurs significant overheads of system performance and area What does the sentence mean?

\subsection*{Responses}
``Fulfills security constraints at the finest granularity" is the conclusion of a reference "Shielding Heterogeneous MPSoCs From Untrustworthy 3PIPs Through Security Driven Task Scheduling, 2017'' \cite{article:CL}. Sorry for our proper writings, and the readers might get confused without the context of that paper.

Therefore, This sentence is modified as follows. \textcolor{cyan}{``Fulfilling security constraints incurs significant overheads of performance and area''}. which is also presented in the mid-left of page 4, cyan colored.



\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}












\section*{Reviewer 5}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
The biggest concern is that some of the key experimental configurations are overly simplified, which make the contribution claim of the manuscript weaker. For example, vendor count is a new input that is added to the scheduling process, compared to the conference version. However, in experiments all vendor counts are just set to be the same as the maximum clique size of the benchmark. This setting simplifies the problem as the maximum clique size should just be a loose upper bound of vendor requirement. I will expect the scheduling scheme to deal with more restricted vendor constraint, which is also more realistic: 6 or 7 vendors as shown in Fig. 9 is just impossible.

\subsection*{Responses}


Thank you very much for your valuable suggestion. In the Section V-D \textit{Comparison of Cores Required} (please see page 12), The effectiveness of our method in saving the number of cores is presented under both loose vendor constraints and tight vendor constraints. When the loss vendor constraint is set, the vendor constraint equals the maximum clique size of the task graph. When the tight vendor constraint is set, the vendor constraint is set to be 2 for all benchmarks. The description of two kinds of vendor constraints are also given in the mid-right of page 12. blue colored

The results demonstrated in Tables VI show that our proposed method beats C-B \cite{article:CL} and MC-B \cite{article:NW} under both loose vendor constraints and tight vendor constraints.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 2}
Another example of the overly simplified setting is the assignment of security risk. The variance of security risk is a main differential point compared to the conference paper. However, this manuscript just assumes the security risk of a communication is linearly proportional to the distance from source. This claim appears to be quite baseless. Is there a reference to support such an assumption? If not, would it be better to test different ways of assigning security risks to edges, for example the edged closer to the source have higher security risk, or randomly assign security risk to all edges. Then we will see how well the proposed scheme works under different settings.

\subsection*{Responses}

In the Section V-C \textit{Comparison of Security Risk Optimization Results} (please see page 11) of this revised manuscript, the comparison of security risks with three sets of risk configurations are presented. These three risk configurations are given as follows.
\textcolor{blue}{
\begin{enumerate}
\item \textbf{Randomly Set}: the risk of each communication is randomly set with the value among [0, $\frac{2*pte}{m}$];
\item \textbf{Equally Set}: the risks of all communications are the same, with the value of $\frac{pte}{m}$;
\item \textbf{Linearly Set}: The communication closer to the source have higher security risk, and the risk of $e_{ij}$ is set as $risk(e_{ij})=\frac{2*(SL-dist(e_{ij}))*pte}{SL*m}$;
\end{enumerate}}

The experimental results given in Fig. \ref{fig:system_risk} indicate that our proposed method is effective under different risk configurations.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 3}
Section V.C and V.D appear to be somewhat redundant compared to Section V.B. Security risk, core counts, and CPU runtime are already compared in Table II and Fig. 9. Why not just discuss based on the existing data instead of padding data with very similar experiment configurations?

\subsection*{Responses}

Thank you very much for your valuable suggestion. In this revised manuscript, the Section V \textit{Experimental Results} is re-organized. We first demonstrate the effectiveness of our method in reducing system risks and the number of cores, and then test the system risk optimization results under different risk configurations, and finally show the results of saving the number of cores with different vendor constraints.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 4}
Scheme PSO-B is mentioned as one of the previous works for comparison, but it is only compared in Table IV. I will suggest removing it instead of performing incomplete comparison here.


\subsection*{Responses}
Thanks for your suggestion, and we have removed the PSO-B method in this revised manuscript.


\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 5}
Equation (1) shows the security risk and core count are linearly combined as a single objective function. However, there is no discussion of what value is selected as alpha, and Table II only compares the reduction of core count instead of the optimization objective.

\subsection*{Responses}
In the previous manuscript, The following objective function is introduced.

\textit{The objective function of the above problem can be formulated as follows:
\begin{equation}
min:~\alpha*risk_s+core
\end{equation}
\noindent where $risk_s$ is the system security risk due to the unprotected communications, $core$ is the number of cores required by the schedule, and $\alpha$ is a parameter large enough to keep the minimization of system security risk as the first priority.}

Our purpose of introducing this objective function is to show that this work jointly optimize the system security risk and the number of cores. However, \textbf{these two optimization targets do not have trade-off relationships}, and therefore, we removed this objective function in this revised manuscript.



\noindent\rule[0.25\baselineskip]{252pt}{1pt}



\section*{Reviewer 6}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 1}
The authors must provide more references, as they miss out several important ones in Section I and II (like authentication techniques, etc.).

\subsection*{Responses}
Thanks for the suggestions. The main kinds of hardware trojan countermeasures are also discussed in the Section II-A \textit{Hardware Trojans and Countermeasures}, mid-right of page 2, red colored. These discussions are also presented as follows.

\textcolor{red}{Numerous and various functional and parametric tests are required to verify whether a 3PIP contains hardware trojans. However, testing a black-box component is very difficult and time-consuming, and it is impractical to do such an exhaustive test for a large and complex design. Therefore, a number of countermeasures have been developed against hardware Trojans at design stage \cite{article:WH}. Hardware security primitives use random number generator (TRNG) \cite{article:YC} or physical unclonable function (PUF) \cite{article:FP} to provide built-in self authentication against various threats and vulnerabilities arising at different phases of IC life cycle \cite{article:QS, article:DM}. System and architectural protection techniques prevent information leakage through shared resource \cite{conference:AA} and build trusted execution environment \cite{book:TA}. Side-channel protection techniques introduces noise or randomization in the software implementation to eliminating side-channel leakage \cite{conference:HK, article:SP}. IP protection techniques use hardware watermarking or steganography to protect an IP against threats \cite{article:AS0, article:AS1}. Machine learning-assisted designs provide defenses against hardware security threats or enhance the systems robustness \cite{conference:KH, article:WS}.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 2}
In Section II, the authors need to include another sub-section related to hardware trojan attacks on real time systems, which includes hardware trojan attacks on real time task schedules, etc and their related security strategies. This will provide a completeness to the literature survey.


\subsection*{Responses}

In this revised manuscript, the way that hardware trojan attacks are also included in Section III-A \textit{Threat Model}, mid-right of page 3, magenta colored. This threat model includes how hardware trojan attack real time systems, and the description of threat model is also given as follows.

\textcolor{magenta}{Hardware trojan attacks are intended to affect normal circuit operation, potentially with catastrophic consequences in critical applications in the domains of communications, banking, space and military \cite{article:SB1}. They can also aim at leaking secret information from inside a chip through covert channels or affect the reliability of an IC through undesired process changes that cause device ware-out and long-term reliability issues \cite{conference:RC}. In addition, they can be used to assist software attacks by providing hardware back-door, and make the system operate in an incorrect way, such as modifying the scheduling results of a real-time system \cite{conference:SM,conference:SM-SMC,article:SM1,article:SM2}.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 3}
The authors need to present a table on how their methodology surpasses the others in Section II.

\subsection*{Responses}
In this revised manuscript, we present a table (Table I in page 3) in Section II \textit{Related Work}, which illustrates the comparison between our proposed technique and other runtime design-for-trust techniques. The comparison is discussed in the lower-right of page 3, cyan colored, and it is also presented as follows.

\textcolor{cyan}{The comparison between the proposed technique and other techniques that implement security constraints is summarized in Table I. The security constraints cause significant overheads of power, delay, and area \cite{article:JR3, conference:XC}, and a number of techniques were developed to optimized these overheads, but the optimization space turns to be very limited \cite{article:SR, conference:AS, article:YS, article:XC}. Recent researchers treat security constraints as loose constraints (some constraints that can be violated) to achieve tight design targets, but they forget to minimize the induced security risks \cite{article:CL, article:NW, conference:NW}. In this work, our proposed method can provide solutions with smaller circuit area under tight delay constraints. Moreover, our approach optimized system security risk, which is always ignored by the conventional approaches.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 4}
The authors claim to work with tasks. Hence, give a proper task description. They must explicitly state their task model, which is not present in the current work. Tasks may be of several types, periodic, non-periodic...

\subsection*{Responses}
In this work, we target embedded platforms which executes application-specific tasks. This explanation is also added in the revised manuscript (lower-left of page 4, red colored), which is also given as follows.

\textcolor{red}{In this work, we target embedded platforms which executes application-specific tasks and have high security requirements. Such platforms cannot handle tasks that occur suddenly at runtime, and they are widely-used in auto-motive, safety-critical systems, etc. In such systems, designers always have the prior knowledge of the application and its runtime constraints, which requires designers to perform security-driven customizations to meet performance and area requirements \cite{article:YS}}.

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 5}
The authors need to present the difference from their conference version in the main text of the paper (In Introduction section), and cite their previous work.

\subsection*{Responses}
Thank you very much for your valuable suggestion. In this revised manuscript, we presented the differences from our conference version in Section I \textit{Introduction} (in the mid-left of page 2, red colored), and cited the previous work. These discussions are also presented as follows.

\textcolor{red}{The earlier conference version of this paper appeared at \cite{conference:NW}. Compared with \cite{conference:NW}, this paper has a number of new contributions.}
\begin{enumerate}
\item \textcolor{red}{This work treats communications with different security importance, and provides a schedule with a minimized system security risk.}
\item \textcolor{red}{Rather than assigning one task to an IP vendor each time, this vendor assignment method groups all tasks into a number of $vc$ (vendor constraint) clusters and assigns an entire cluster to an IP vendor at a time. Furthermore, this vendor assignment method evaluates the number of cores saved when clustering tasks rather than estimating the number of cores required, which speeds up the processing time and provides better results.}
\item \textcolor{red}{This work considers core speed variation in the design process. All tasks are first assumed to be performed with the slowest speed, and the vendor assignment will be adjusted after the exact core speeds are determined to further reduce the system security risk.}
\end{enumerate}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}


\subsection*{Comment 6}
The authors need to state the complexities of their proposed algorithms.

\subsection*{Responses}
In this revised manuscript, the detailed time complexities are presented in Section IV \textit{Time Complexity Analysis}, which is also given as follows.


\textcolor{blue}{The time complexity of our proposed method is analyzed as follows, and the input task graph has $n$ nodes and $m$ edges.}

\textcolor{blue}{In each iteration of the performance-constrained task clustering stage, constructing $ECCG$ from $TVG$ requires $O(m^2)$, and finding the MWIS in $ECCG$ also requires $O(m^2)$ \cite{conference:LC}. Only a constant number of iterations are conducted before reaching the performance constraint, and finding all contracted edges to meet the performance constraint totally needs $O(m^2)$. In addition, each time before contracting an edge, updating $VCFG$ and evaluating the impact on the maximum clique size of $VCFG$ need $O(n^2)$, and only a limited number of edges are contracted, making its computational cost $O(n^2)$. The total time complexity of performance-constrained task clustering is $O(m^2)$ (due to $O(n)\leq O(m)$).}

\textcolor{blue}{In the vendor assignment and task scheduling stage, constructing $VCFG$ and $VCPG$ requires $O(n^2)$. In each iteration of merging clusters, $O(m)$ is required to estimate the maximum clique size, and $O(n)$ is needed to update both $VCFG$ and $VCPG$. Vender assignment requires $O(n)$ iterations of merging clusters, and its time complexity is $O(mn)$. Performing the force-directed scheduling method to schedule all tasks needs $O(n^2)$, and the total time complexity of the vendor assignment and task scheduling stage is $O(mn)$.}

\textcolor{blue}{The sum of $O(m^2)$ and $O(mn)$ is $O(m^2)$, and it is the total time complexity of our proposed method.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 7}
Can this mechanism handle tasks which occurs suddenly at runtime? If not, the authors must state this.

\subsection*{Responses}
\textbf{Q1.} Can this mechanism handle tasks which occurs suddenly at runtime?

\textbf{A1.} This mechanism only handle application-specific tasks, and therefore, cannot handle tasks that occurs suddenly at runtime.

\vspace*{1em}

\textbf{Q2.} If not, the authors must state this.

\textbf{A2.} We have stated that our mechanism cannot handle tasks that occurs suddenly at runtime. This statement is given in upper-right of page 4, cyan colored, and it is also presented as follows.

\textcolor{cyan}{Such platforms can not handle tasks that occur suddenly at runtime, and they are widely-used in auto-motive, safety-critical systems, etc.}

\noindent\rule[0.25\baselineskip]{252pt}{1pt}

\subsection*{Comment 8}
Duplication with diversity mechanism can guarantee full proof results and can handle any fault related issues at runtime. The authors must also state whether their proposed mechanism can mitigate errors and bypass faults, if any occur at runtime. If so, how?

\subsection*{Responses}
Q1. Duplication with diversity mechanism can guarantee full proof results and can handle any fault related issues at runtime.

A1. The duplication with diversity mechanism cannot handle fault related issues at runtime, and this mechanism can only be used to detect the faults caused by hardware trojan.

\vspace*{1em}

Q2. The authors must also state whether their proposed mechanism can mitigate errors and bypass faults, if any occur at runtime. If so, how?

A2. In the column 'Recovery' of table I (page 3), we have stated that our proposed method has ''No" ability to recover from the errors.



\noindent\rule[0.25\baselineskip]{252pt}{1pt}
\noindent\rule[0.25\baselineskip]{252pt}{1pt}



% that's all folks
\end{document}




%% bare_jrnl_compsoc.tex
%% V1.4a
%% 2014/09/17
%% by Michael Shell
%% See:
%% http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8a or later) with an IEEE
%% Computer Society journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE!
%% User assumes all risk.
%% In no event shall IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%
%% File list of work: IEEEtran.cls, IEEEtran_HOWTO.pdf, bare_adv.tex,
%%                    bare_conf.tex, bare_jrnl.tex, bare_conf_compsoc.tex,
%%                    bare_jrnl_compsoc.tex, bare_jrnl_transmag.tex
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. IEEE's font choices and paper sizes can       ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/


\documentclass[10pt,journal]{IEEEtran}
\usepackage{savesym}
\usepackage{amsmath}
\savesymbol{iint}
\usepackage{txfonts}
\usepackage{graphicx}
%\usepackage{amssymb}
%\usepackage{verbatim}
\usepackage{algorithm} %format of the algorithm
\usepackage{algorithmic}
%\usepackage{algorithmic2e}
\usepackage{color}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{makecell}
%\usepackage[numbers,sort&compress]{natbib}
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[10pt,journal,compsoc]{../sty/IEEEtran}


\newtheorem{definition}{\textbf{Definition}}
\newtheorem{lemma}{\textbf{Lemma}}
\newtheorem{property}{\textbf{Property}}
\newtheorem{proof}{Proof}
\newtheorem{problem}{\textbf{Problem}}



\hyphenpenalty=7000


% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/tex-archive/macros/latex/contrib/oberdiek/
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
%\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
%  \usepackage[nocompress]{cite}
%\else
  % normal IEEE
%  \usepackage{cite}
%\fi
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/cite/
% The documentation is contained in the cite.sty file itself.
%
% Note that some packages require special options to format as the Computer
% Society requires. In particular, Computer Society  papers do not use
% compressed citation ranges as is done in typical IEEE papers
% (e.g., [1]-[4]). Instead, they list every citation separately in order
% (e.g., [1], [2], [3], [4]). To get the latter we need to load the cite
% package with the nocompress option which is supported by cite.sty v4.0
% and later. Note also the use of a CLASSOPTION conditional provided by
% IEEEtran.cls V1.7 and later.





% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  % \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/graphics/
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/tex-archive/info/epslatex/
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex






% *** MATH PACKAGES ***
%
%\usepackage[cmex10]{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics. If using
% it, be sure to load this package with the cmex10 option to ensure that
% only type 1 fonts will utilized at all point sizes. Without this option,
% it is possible that some math symbols, particularly those within
% footnotes, will be rendered in bitmap form which will result in a
% document that can not be IEEE Xplore compliant!
%
% Also, note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/amslatex/math/





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithms/
% There is also a support site at:
% http://algorithms.berlios.de/index.html
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/tex-archive/macros/latex/contrib/algorithmicx/




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=footnotesize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a sans serif font rather
% than the serif font used in traditional IEEE formatting and thus the need
% to invoke different subfig.sty package options depending on whether
% compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Do not use the stfloats baselinefloat ability as IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/dblfloatfix/




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and
% Axel Sommerfeldt. This package may be useful when used in conjunction with
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/endfloat/
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/url/
% Basically, \url{my_url_here}.





% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{Security-Driven Task Scheduling under Performance Constraints for MPSoCs with Untrusted 3PIP Cores}
%\title{Security-Aware Task Scheduling for MPSoCs with Performance and Area Optimization}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%
%
%\IEEEcompsocitemizethanks is a special \thanks that produces the bulleted
% lists the Computer Society journals use for "first footnote" author
% affiliations. Use \IEEEcompsocthanksitem which works much like \item
% for each affiliation group. When not in compsoc mode,
% \IEEEcompsocitemizethanks becomes like \thanks and
% \IEEEcompsocthanksitem becomes a line break with idention. This
% facilitates dual compilation, although admittedly the differences in the
% desired content of \author between the different types of papers makes a
% one-size-fits-all approach a daunting prospect. For instance, compsoc
% journal papers have the author affiliations above the "Manuscript
% received ..."  text while in non-compsoc journals this is reversed. Sigh.

\author{Nan~Wang,~\IEEEmembership{Member,~IEEE,}
%        ~Manting~Yao,%~\IEEEmembership{Member,~IEEE,}
        ~Song~Chen,~\IEEEmembership{Member,~IEEE,}
   %     ~Hongqin~Zhu, ~\IEEEmembership{Member,~IEEE,}
        and~Yu~Zhu,~\IEEEmembership{Member,~IEEE,}

\thanks{This work was supported by the National Key R\&D Program of China under Grant 2022YFD2000400.}
\thanks{Nan Wang and Yu Zhu are with the School of Information Science and Engineering, East China University of Science and Technology, Shanghai, 200237, China.}% <-this % stops a space
\thanks{Song Chen is with the School of Information Science and Technology, University of Science and Technology of China, Hefei, 230026, China.}
%\thanks{Cong Hao and Takeshi Yoshimura are with the Graduate School of Information, Production and Systems, Waseda University, 808-0135, Japan.}% <-this % stops a space
}

% note the % following the last \IEEEmembership and also \thanks -
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
%
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
\markboth{Journal of \LaTeX\ Class Files,~Vol.~13, No.~9, September~2014}%
{Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for Computer Society Journals}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
%
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.



% The publisher's ID mark at the bottom of the page is less important with
% Computer Society journal papers as those publications place the marks
% outside of the main text columns and, therefore, unlike regular IEEE
% journals, the available text space is not reduced by their presence.
% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2014 IEEE}
% or like this to get the Computer Society new two part style.
%\IEEEpubid{\makebox[\columnwidth]{\hfill 0000--0000/00/\$00.00~\copyright~2014 IEEE}%
%\hspace{\columnsep}\makebox[\columnwidth]{Published by the IEEE Computer Society\hfill}}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark (Computer Society jorunal
% papers don't need this extra clearance.)



% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}



% for Computer Society papers, we must declare the abstract and index terms
% PRIOR to the title within the \IEEEtitleabstractindextext IEEEtran
% command as these need to go into the title area created by \maketitle.
% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\IEEEtitleabstractindextext{%
\begin{abstract}
The high penetration of third-party intellectual property (3PIP) brings a high risk to MPSoCs, and a set of security-driven constraints are imposed on task scheduling to protect MPSoCs against malicious modifications. Due to the significant performance and area overheads incurred, designers often treat these security-driven constraints as loose constraints during the design process, and achieve the design goals within a predefined permissible security risk. In this study, a security-driven task scheduling method is proposed to achieve a high security level under performance constraints, and the number of cores required is also optimized. First, the schedule length is iteratively optimized by assigning sets of data-dependent tasks in the performance constraint-violated paths to the same core, with a maximum weight independent set-based method. Second, the number of cores required is analyzed during vendor assignment according to the distributions of tasks and optimized by maximizing the core sharing of tasks. Finally, tasks are scheduled to time periods using the force-directed scheduling method. Experimental results demonstrate the effectiveness of the proposed method in reducing the number of cores while maintaining system security under performance constraints.
\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
MPSoC, hardware Trojan, task scheduling, security, third-party IP core.
\end{IEEEkeywords}}


% make the title area
\maketitle


% To allow for easy dual compilation without having to reenter the
% abstract/keywords data, the \IEEEtitleabstractindextext text will
% not be used in maketitle, but will appear (i.e., to be "transported")
% here as \IEEEdisplaynontitleabstractindextext when the compsoc
% or transmag modes are not selected <OR> if conference mode is selected
% - because all conference papers position the abstract like regular
% papers do.
\IEEEdisplaynontitleabstractindextext
% \IEEEdisplaynontitleabstractindextext has no effect when using
% compsoc or transmag under a non-conference mode.



% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}

The increased design productivity requirements for heterogeneous multiprocessor System-on-Chip (MPSoC) require the industry to procure and use the latest commercial-off-the-shelf (COTS) electronic components to track the most cutting edge technology while reducing manufacturing costs. This has given rise to the trend of outsourcing the design and fabrication of 3PIP components, which may not be trustworthy, and the hardware Trojans in these 3PIP components present high risks of malicious inclusions and data leakage in products \cite{conference:XW}. This raises security concerns \cite{article:SB} because a small hardware modification by an adversary in the 3PIP cores can compromise the whole chip \cite{conference:MH}. If such chips run time-critical applications (e.g., in autonomous vehicles), the hardware Trojan attack may lead to catastrophic or life-threatening consequences \cite{conference:AM1}. Similarly, if these chips are used in information critical systems (e.g., banking), the confidentiality and integrity of the user's data can be compromised \cite{conference:FK}.

%In particular, the growing number of mission-critical applications (e.g., finance and military) that use MPSoCs means that security is the highest priority issue \cite{article:CL, article:DM}, whereas the increasing integration of third-party Intellectual Property (3PIP) and the outsourcing of fabrication indicate that most MPSoCs are not 100\% trustworthy.



Emerging security problems bring an urgent need to detect possible hardware Trojan attacks or mitigate their effects. Methods for detecting hardware Trojans can primarily be classified into the following groups: physical inspection \cite{network:SS}, functional testing \cite{conference:BB}, built-in tests \cite{article:DD}, and side-channel analyses \cite{article:YH1}. However, it is impossible to detect advanced hardware Trojans, such as A2, due to its insertion stage and software triggered mechanism \cite{conference:YH}. To safeguard against potentially undetected Trojans, runtime validation approaches provide a last line of defense against Trojan attacks and attempt to contain the effect of an activated Trojan \cite{article:SB}.


Runtime monitoring techniques always insert hardware sensors in circuits to check abnormal runtime behaviors by monitoring side channel signals or circuit operations \cite{conference:JH, article:YH}. The main challenge in runtime monitoring is that many extra circuit overheads must be added to ensure the monitoring effectiveness and accuracy even though many studies have been proposed to reduce these overheads \cite{ article:JZ, conference:MH}. Besides, hardware Trojans may still escape these runtime monitoring techniques because too few gates are used, and hardware Trojans will not cause any thermal or power fluctuations.

Design-for-trust techniques also provide comprehensive protections to circuits and verify the correctness of system functionality at runtime. Incorporating security constraints in the MPSoC design process is one of the most popular design-for-trust techniques, which can mitigate the effects of the hardware Trojans and enable trustworthy computations using untrusted 3PIP cores \cite{article:JR3, article:TR, conference:MB, conference:XC, conference:JR2, conference:MS}. This is achieved by duplicating tasks and mapping them on 3PIP cores of different vendors to detect Trojans that alter task outputs or mute potential Trojan effects by preventing collusion between malicious 3PIP cores from the same vendor. Designing MPSoCs with these security constraints brings significant design overheads, and researchers have developed a number of solutions and created trusted designs with minimum resource overhead, performance degradation and energy consumption \cite{article:SR, conference:AS, article:YS}. Some researchers have also started to consider security constraints as loose constraints to satisfy the design goals while maximizing system security \cite{article:XC, article:CL, article:NW, conference:NW}.

Existing studies focused on area optimization primarily address the problem in the task scheduling stage \cite{article:SR} because the number of cores required can only be evaluated after vendor assignment. However, vendor assignment is a prior stage of task scheduling, whose results strongly affect area optimization results of task scheduling, and ignoring the area optimization during vendor assignments limits the area optimization results. Also, researchers have treated each communication equally when optimizing the system performance \cite{article:CL, article:NW, conference:NW}, but the vulnerability analysis at the behavioral level reveals parts of a circuit that are more vulnerable to Trojan insertion \cite{conference:HS}, and removing security constraints from different tasks or communications yields different security losses \cite{article:XC}.% indicating that the vulnerability of .


In this study, we focus on the design of MPSoCs though security-driven task scheduling, and set the desired performance as constraints. The goal of this study is to find a schedule with a minimized vulnerability to hardware Trojans and a small number of cores required. A three-step design method that consists of task clustering, vendor assignment and task scheduling is proposed to enable MPSoC designers to achieve the desired performance, and obtain a high-security design with a small number of cores. Experimental results demonstrate the high quality of the task scheduling results in reducing both the design's vulnerability and the number of cores under performance constraints. The contributions of the paper are summarized as follows:

%Firstly, a maximum weight independent set-based method iteratively selects inter-core communications and assigns the connected tasks to the same core to reduce the performance with minimized security risks. Secondly, the numbers of cores are estimated and optimized during vendor assignment by the cluster merging-based method. Finally, tasks from the same IP vendor are scheduled together using the force-directed scheduling method \cite{article:PP}. The experimental results demonstrate the high quality of the task scheduling results in reducing both system security risks and the number of cores under performance constraints. The contributions of the paper are summarized as follows:
%\begin{enumerate}

%\item We propose a design methodology that enables MPSoC designers to make trade-offs between system security and performance. The designers can achieve the desired performance by setting it as a constraint, and obtain a high-security design with a small number of cores.

%\item To satisfy the performance constraints, a maximum weight independent set-based method is proposed to minimize the induced system security risk by iteratively assigning edges to intra-core communications. In addition, some intra-core communications will be reassigned with security constraints after the exact core speeds are determined to further reduce the system security risk.

%\item The numbers of cores are optimized in both vendor assignment and task scheduling stages, by iteratively assigning tasks that share the most common cores to the same vendor and scheduling these tasks evenly in each time period, and this enlarges the optimization space of reducing cores.

%\end{enumerate}



%The earlier conference version of this paper appeared at \cite{conference:NW}. Compared with \cite{conference:NW}, this paper has the following new contributions.

\begin{enumerate}

\item This study treats communications between tasks with different vulnerabilities to hardware Trojans, and a maximum weight independent set-based method is proposed to minimize the design's vulnerability while meeting performance constraints, by iteratively selecting a set of maximum weighted edges and assigning them to intra-core communications.

\item The numbers of cores are optimized in both the vendor assignment and task scheduling stages, by iteratively assigning tasks that share the most common cores to the same vendor and scheduling these tasks evenly in each time period. Furthermore, the proposed vendor assignment method evaluates the number of cores saved when clustering tasks rather than estimating the number of cores required, which speeds up the processing and provides better results.

\item This study considers core speed variation in the design process. All tasks are first assumed to be performed with the slowest speed, and after the exact core speeds are  determined, the vendor assignment will be adjusted to assign the unprotected communications with security constraints in descending order of vulnerability, which further reduces the total design's vulnerability.

\end{enumerate}



The remainder of this paper is organized as follows. Section II describes the related literature, and Section III demonstrates the motivations and describes the optimization problem. Section IV presents the details of the proposed task scheduling method. Section V illustrates the experimental results, and Section VI provides the conclusions.



\begin{figure}[!t]
\centering
\hspace*{-0.8em}
\includegraphics[width=7.8cm]{figure/HT_insert.pdf}
\caption{Hardware Trojans inserted at different stages of IC life cycle \cite{article:SB}.}
\label{fig:3PIP_threats}
\end{figure}



\section{Related Work}




In general, the IPs procured from third-party vendors are usually not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert Trojan logic in 3PIPs coming out of the IP house, and the outsourced design and test services, as well as electronic design automation software tools supplied by different vendors, also make ICs vulnerable to malicious implants (see Fig. \ref{fig:3PIP_threats})\cite{article:SB}.



\begin{table*}[!t]
\renewcommand{\arraystretch}{1.0}
\caption{Comparison with Related Work}
\centering
\begin{tabular}{c|c|c|c|c|c|c}
\hline
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{Technique}}    & \multicolumn{1}{c|}{\multirow{2}{*}{Detect Trojans}}           &Prevent collusion  &\multicolumn{1}{c|}{\multirow{2}{*}{Recovery}}     &\multicolumn{1}{c|}{\multirow{2}{*}{Optimize area}}  & \multicolumn{1}{c|}{\multirow{2}{*}{Optimize delay}}  & Optimize power    \\
    &    &between 3PIPs  &   &  &   &or energy   \\
\hline
\hline

%\cite{conference:JR2}     &Yes   &Yes    &No   &No     &No   &No    &No     \\


\cite{article:JR3}        &Yes      &Yes   &No     &No   &No    &Yes    \\

\cite{conference:XC}      &Yes       &No   &Yes    &No   &No    &No    \\

\cite{article:SR}        &Yes       &Yes   &No     &Yes   &Loose delay constraints    &Loose power constraints    \\

\cite{conference:AS}      &Yes      &Yes   &No     &No   &No    &Yes   \\

\cite{article:YS}        &Yes       &Yes   &No     &No   &Loose delay constraints    &Yes   \\

\cite{article:XC}        &Yes       &Yes   &Yes     &Loose area constraints   &Loose delay constraints    &No     \\

\cite{article:CL}        &Yes       &In most cases   &No     &No   &Tight delay constraints    &No     \\




This work                &Yes       &In most cases   &No     &Yes   &Tight delay constraints    &No     \\

\hline
\hline
\end{tabular}
\label{table:comparison_related_works}
\end{table*}

%\subsection{Runtime Monitoring}

%Runtime monitoring detects hardware trojans by continuously checking and verifying the behavior of side-channel signals or circuit operations, and recent researchers have focused on improving runtime hardware trojan detection accuracy. He \textit{et al.} \cite{conference:JH} developed a runtime trust evaluation framework based on on-chip electron magnetic sensors and achieved a high hardware trojan detection accuracy. Hou \textit{et al.} \cite{article:YH} guarded the concerned signals and initiated a hardware interrupt request when abnormal toggling events occurred. Kulkarni \textit{et al.} \cite{conference:AK, article:AK} proposed real-time anomaly detection frameworks based on support vector machines and K-nearest neighbors for many-core architecture. Zhao \textit{et al.} \cite{article:HZ} proposed a runtime trojan detection model that applied chaos theory to characterize side-channel parameters. Malekpour \textit{et al.} \cite{conference:AM} focused on mitigating hardware trojans with a permanent impact on the system and successfully detected hardware trojans with a slightly higher area and performance overheads.

%Researchers also observed the significant increment of resources, power and performance caused by runtime monitoring, and many solutions have been proposed to reduce these increments while maintaining high accuracy of trojan detection. Mohd \textit{et al.} \cite{article:BM} developed a low-power, low-energy and trusted design based on a smart runtime monitoring algorithm. Bao \textit{et al.} \cite{article:CB} demonstrated approaches with low hardware resource overhead for runtime trojan detection with thermal sensors. Zhu \textit{et al.} \cite{article:JZ} obtained a high effectiveness in detecting pervasive hardware security issues with little performance loss. Khalid \textit{et al.} \cite{article:FK} proposed a single power-port current acquisition block using current sensors in time-division multiplexing, which increases detection accuracy with a reduced area overhead.% Hussain \textit{et al.} \cite{conference:MH} demonstrated a runtime energy-efficient hardware trojan localization design for network-on-chips, where the authentication was activated only when the hardware trojans were triggered.

%The main advantage of security monitors is the reconfigurability to various checks without the ``golden model", but these checks are simple, and do not cover the entire circuit \cite{article:SB}. Therefore, finding all hidden trojans using security monitors still cannot be guaranteed although many studies have been proposed to improve the detection efficiency.



\subsection{Security Countermeasures}


%hardware security threats can results from unintentional design flaws [1-3], system side effects [4-7], and intended malicious design modifications [8]-[10]. They usually target security assets, such as cryptographic functions, secure architecture,


%It is extremely difficult to detect all hardware trojans in 3PIPs since there is no known golden model for 3PIPs. IP vendors usually provide source code, which may contain trojans, and a trojan can be very well hidden during normal functional operations. Besides, an attacker may distribute few codes to reduce the trojan footprint, and a large industrial-strength IP can include thousands of lines of code.



Numerous and various functional and parametric tests are required to verify whether a 3PIP contains hardware Trojans. However, testing a black-box component is difficult and time-consuming, and it is impractical to perform such an exhaustive test for a large and complex design. Therefore, a number of countermeasures have been developed against hardware Trojans at the design stage \cite{article:WH}. Hardware security primitives provide built-in self-authentication against various threats and vulnerabilities arising at different phases of the IC life cycle \cite{article:DM}. System and architectural protection techniques prevent information leakage through shared resources and build trusted execution environments \cite{conference:AA}. Side-channel protection techniques introduce noise or randomization in the software implementation to eliminate side-channel leakage \cite{conference:HK}. IP protection techniques use hardware watermarking or steganography to protect an IP against threats \cite{article:AS1}. Machine learning-assisted designs provide defenses against security threats or enhance system robustness \cite{conference:KH}.

Although hardware Trojan detection methods are implemented in different design stages, finding all hardware Trojans cannot be guaranteed even with the most cutting-edge technologies. However, many applications, such as banking and military systems, have high security requirements \cite{conference:XZ}. Therefore, Trojan-tolerant design methodologies are another way to protect designs from Trojan attacks \cite{article:KX}.


\subsection{Design-for-Trust}



The design-for-trust techniques use strategies at design time to help detect hardware Trojans or mute the attack effects at runtime \cite{article:JR3}. Many studies have attempted to detect malicious outputs by duplicating 3PIPs and comparing their results and to avoid collusion between parent and child tasks from the same vendor. Incorporating the above design constraints (i.e., security constraints) in the MPSoC design process has attracted the attention of researchers.

Reecee \textit{et al.} \cite{article:TR} identified hardware Trojans through comparisons of two similar untrusted designs by testing functional differences for all possible input combinations. Beaumont \textit{et al.} \cite{conference:MB} developed an online Trojan detection architecture that implements fragmentation, replication, and voting. Cui \textit{et al.} \cite{conference:XC} implemented both Trojan detection and fast recovery at runtime for mission-critical applications, using recomputation with IP cores from different vendors. Shatta \textit{et al.} \cite{conference:MS} presented methodologies that detect the errors triggered by hardware Trojans in 3PIPs using voters, and recover the system by replacing the error.

Security constraints, including duplication and 3PIP vendor diversity, have been recently proposed for hardware Trojan protection, and high-level synthesis is the ideal level for incorporating security constraints \cite{conference:JR2}. However, fulfilling the security constraints in task scheduling on heterogeneous multicore platforms always results significant overheads in system performance, chip area and power, and researchers have started to reduce these overheads. Rajmohan \textit{et al.} \cite{article:SR} proposed a PSO-based hybrid evolutionary algorithm, and Sengupta \textit{et al.} \cite{conference:AS} proposed a bacterial foraging optimization-based design space exploration method to achieve a task schedule with higher security and less hardware overhead. Sun \textit{et al.} \cite{article:YS} minimized the energy consumption while simultaneously protecting the MPSoC against the effects of hardware Trojans with security constraints. Cui \textit{et al.} \cite{article:XC} solved the online hardware Trojan detection and recovery problem with graph-theory models that minimize the implementation cost of the design budget and area overhead. Liu \textit{et al.}\cite{article:CL} proposed a set of task scheduling methods to reduce the increments of performance and hardware due to security constraints. Wang \textit{et al.} \cite{article:NW, conference:NW} optimized the design budget and system performance with a minimized number of unprotected communications.

The comparison between the proposed technique and other techniques that implement security constraints is provided in Table I. Security constraints cause significant power, delay, and area overheads \cite{article:JR3, conference:XC}, and many techniques were developed to optimize these overheads when adopting these security constraints, but the optimization space is limited \cite{article:SR, conference:AS, article:YS, article:XC}. Some researchers also treat security constraints as loose constraints (some constraints that can be violated) to achieve tight design targets, but they forget to minimize the induced design's vulnerability \cite{article:CL, article:NW, conference:NW}.
 
The analysis of vulnerability to hardware Trojan insertion at behavioral level consists of \textit{statement analysis} which measures the statement execution conditions, \textit{observerability analysis} which evaluates reachability of signals and observability through circuit primary output, and \textit{detectability analysis} which gauges the detection of a malicious change or a inclusion of a statement based on the target signal \cite{conference:HS}, and their experimental results reveal that the maximum and minimum values of vulnerabilities can be $\times10^3$ times in the tested benchmarks. This indicates that the design's performance and area can be significantly reduced with a small penalty of increased vulnerability by removing some ``proper'' security constraints. Therefore, we try to minimize both the circuit vulnerability to hardware Trojan insertion and the circuit area under the performance constraints in this paper.% Moreover, the proposed approach optimizes the induced vulnerabilities, which are ignored by most existing approaches.

%In this work, we provide a method that enables designers to make trade-offs between security and system performance by setting the required performance as constraints, and both the security risks and the number of cores are optimized under the given performance constraints.






\section{Preliminaries and Problem Description}

In this section, we present preliminaries and describe the problem considered in this study.
%At present, industry needs to procure and use the latest COTS 3PIPs to track the most cutting-edge technology while reducing the manufacturing costs, but this brings a high risk to the systems.

%\subsection{Threat Model}

%3PIP cores fall into one of the three categories: soft, firm, and hard, depending on their format when they are supplied. \textcolor{blue}{Soft IP cores are described using VHDL or Verilog, and hardware Trojans can be inserted into soft IP cores by IP vendors during IP design}.


%In general, the Register Transfer-Level (RTL) files of IPs might have been imported from third party vendors, and 3PIPs procured from IP vendors are usually not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert Trojan logic in 3PIPs coming out of the IP house, and the Trojans may modify function, deny service, or create a backdoor to leak information.% and therefore, hardware Trojan protection strategy during HLS requires attation.



%It is extremely difficult to detect all of the hardware Trojans in 3PIPs since there is no known golden model for 3PIPs. IP vendors usually provide source code, which may contain Trojans. A Trojan can be very well hidden during the normal functional operation of the 3PIP supplied as RTL code. An attacker may distribute few RTL codes so as to reduce Trojan footprint, and a large industrial-strength IP can include thousands of lines of code, resulting in identifying the Trojan in an IP to be an extremely challenging task. When a Trojan exists in an IP, all the fabricated cores will contain Trojans, and detecting all Trojans in an SoC chip is also impossible.



%At present, industry needs to procure and use the latest Commercial-Off-The-Shelf (COTS) electronic components in order to track the most cutting edge technology while reducing the manufacturing costs. However, the hardware Trojans in these COTS components present high risks of malicious inclusions and data leakage in products \cite{conference:XW2}. In the present study, we ignore the threats posed by software Trojans and only consider the protection of applications from hardware Trojans.


%3PIPs procured from IP vendors are not 100\% trustworthy. There may be a rogue insider in a 3PIP house who may insert malicious logic in 3PIPs coming out of the IP house.

%In Trojaned hardware, the attacker may modify the function, deny service, or create a backdoor to leak confidential information, thereby allowing the task running on the malicious intellectual property (IP) core to either generate additional output and trigger Trojans in other IP cores from the same vendor, or to produce incorrect outputs \cite{article:CL}. To protect applications from these risks, most previous studies have either implemented hardware Trojan detection and prevention, or security-aware system level designs.

%Although hardware Trojans detection methods are implemented in different stages, finding all hardware Trojans cannot be promised even with the most cutting-edge technologies. However, many applications such as banking and military systems have high security requirements, and therefore, design-for-security methodologies that mute the hardware Trojan effects require attention.


\subsection{Threat Model}


Hardware Trojan attacks are intended to affect normal circuit operation, potentially with catastrophic consequences in critical applications in the domains of communications, banking, space and military \cite{article:SB1}. They can also aim to leak secret information from inside a chip through covert channels or affect the reliability of an IC through undesired process changes that cause device ware-out and long-term reliability issues \cite{conference:RC}. In addition, they can be used to assist software attacks by providing hardware back-doors, and make the system operate incorrectly, such as by modifying the scheduling results of a real-time system \cite{article:SM1}. From the perspective of the activation methods, hardware Trojans can be classified as either \textit{always-on} or \textit{conditionally triggered}. An always-on Trojan is inserted in rarely accessed places and its footprint is kept small. Conditionally triggered Trojans hibernate initially, and are activated either by the Trojan implanter or by on-chip triggers \cite{article:CL}.

In this study, we adopt the same threat model in \cite{article:CL, article:YS}, which primarily focuses on detecting (or mitigating) malicious modifications. The Trojan may cause the task running on the malicious 3PIP to either produce incorrect output or generate additional output to trigger Trojans in another 3PIP core from the same vendor. As a result, the following two cases can occur at runtime: 1) due to the insertion of the malicious logic into a 3PIP core, the outputs of the infected cores will be altered at some undetectable points; 2) Trojans that are distributed on multiple cores to reduce the chance of being detected can also form secret communication paths, and a malicious logic in one core can trigger the Trojans in another core using a secret communication channel.


\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=6cm]{figure/tg.png}\label{subfig:tg4}
} &\hspace*{-1.0em}
\subfigure [] {
\includegraphics[width=5.45cm]{figure/constraint_example1.pdf}\label{subfig:asap_schedule_security}
} & \hspace*{-0.5em}
\subfigure [] {
\includegraphics[width=5.75cm]{figure/performance-motivation1.pdf}\label{subfig:performance-motivation}
}
\end{tabular}
\caption{Example of task graph and its schedules. \subref{subfig:tg4} Task graph. \subref{subfig:asap_schedule_security} ASAP schedule with security constraints. \subref{subfig:performance-motivation} Schedule length optimization results.}
\label{fig:security}
\end{figure*}

\subsection{Security Constraints}
\label{subsect:sec}

The security constraints improve the design reliability using untrusted 3PIPs\cite{conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}, and the effectiveness of the security constraints in detecting the deliberate faults caused by Trojans and isolating the triggered Trojans are explained in \cite{article:JR3}. The two types of security constraints that are commonly used are described as follows.% tasks are scheduled under the following two types of security constraints. %\cite{conference:JR2, article:SR, conference:AS, article:YS, article:XC, article:CL, article:NW, conference:NW}.%: \textit{task duplication} and \textit{vendor diversity}.


\subsubsection{Duplication-With-Diversity}

Each task is executed in duplicate on the cores from different vendors, and the outputs of these cores are compared by a trusted component (not designed by the third party) to ensure the trustworthiness of the comparison step \cite{conference:DG}.

Duplication-with-diversity is set based on the fact that the probability of Trojans implanted by different attackers having the same trigger input is quite low, and it is virtually impossible that two cores from different IP vendors will output the same tampered results after the same trigger input \cite{article:NV}.% In the following descriptions, the duplicated task of $v_i$ is denoted as $v_{i'}$.



\subsubsection{Isolation-With-Diversity}

Data-dependent tasks are executed on the cores fabricated from different IP vendors to isolate the triggered hardware Trojans.

%This type of security constraint can be used to isolate the triggered hardware Trojans. Because attackers always distribute Trojans in multiple IP cores and construct secret communications between IP cores to leak information or to trigger the hibernating Trojans, and these secret communications between IP cores from the same vendor cannot be acquired by other vendors \cite{article:JR3}.

To mute Trojan footprints, attackers always distribute Trojans in multiple IP cores and construct secret communications between IP cores to leak information or to trigger the hibernating Trojans. These secret communications between IP cores from the same vendor cannot be acquired by other vendors \cite{article:JR3}. Although redundant execution approaches, including voting architecture \cite{conference:MB}, dual/triple modular redundancy \cite{conference:DG}, and duplication-with-diversity, can detect hardware Trojans by comparing the outputs of cores from different vendors with the same input, they cannot cut off secret communications between multiple IP cores. Therefore, this isolation-with-diversity is also introduced to isolate the triggered hardware Trojans from the rest of the system.

%Thus the vendor diversity constraint which forces the is also introduced to isolate the triggered hardware Trojans from the rest of the system.

%To mute the Trojan footprint, the attacker always distributes Trojans in multiple IP cores and constructs secret communications between cores to leak information or to trigger the hibernating Trojans. In this study, we assume that the secret communication between cores from the same vendor cannot be acquired by other vendors and that the attackers of different vendors plant different hardware Trojans.

%In a task graph with $n$ nodes and $m$ edges, the number of task duplication constraints is $n$, and the number of vendor diversity constraints is $2m$ (both the task graph and the duplicated task graph contain $m$ vendor diversity constraints). Therefore, the number of all security constraints (denoted as $scy$) is $n+2m$.






\subsection{Motivations}




Fulfilling security constraints incurs significant overheads of performance and area, and Fig. \ref{fig:security} shows an example, where 10 tasks are sorted into 4 different types. All intra-core communication delays are ignored, and the computational times of all tasks are assumed to be 1 unit of time (\textit{ut}), which also equals their inter-core communication delays. Fig. \ref{subfig:tg4} and Fig. \ref{subfig:asap_schedule_security} show the task graph and its as-soon-as-possible (ASAP) task schedule with security constraints, where tasks colored white, gray, and pink are assigned to the 1st, 2nd, and 3rd vendors, respectively. The duplicated task of $v_i$ is denoted as $v_{i'}$. Satisfying all security constraints makes the schedule length 7 \textit{ut}, and 6 cores from 3 IP vendors are required.

In this study, we target embedded platforms which execute application-specific tasks and have high security requirements. Such platforms cannot handle tasks that occur suddenly at runtime, and they are widely-used in auto-motive, safety-critical systems, etc. In such systems, designers always have prior knowledge of the application and its runtime constraints, which requires designers to perform security-driven customizations to meet performance and area requirements \cite{article:YS}.

%Researchers have started to explore the possibility of grouping data-dependent tasks into a cluster to reduce the number of IP vendors required \cite{article:XC, article:CL, article:NW} or the system performance \cite{article:CL, article:NW, conference:NW}, which violates the vender diversity constraints. However, a pre-defined maximum permissible security loss is allowed to reduce the overheads of power, area, energy, and performance \cite{article:SR}, so designers also seek the solutions to minimize system security loss with the desired targets.


\subsubsection{Vulnerability Increment in Performance Optimization}

To reduce performance overhead, researchers have imposed loose security constraints during task scheduling and explored the possibility of assigning data-dependent tasks into a single core to hide the inter-core communication delay \cite{article:CL, article:NW, conference:NW}. In this study, clustering the connected data-dependent tasks into one core is denoted as \textbf{edge contraction}, and the edge that represents an inter-core communication is a \textbf{contracted edge}.

Edge contraction leaves the corresponding communication without protection, and this communication is vulnerable to hardware Trojans insertion. Traditional methods that optimize system performance either ignore the consequence security loss \cite{article:CL} or treat every communication with the same security importance \cite{article:NW, conference:NW}. However, communications have different vulnerabilities to hardware Trojan insertions\cite{article:SR, article:XC}, and the vulnerabilities can differ by $\times10^3$ times in the same benchmark \cite{conference:HS}.
 
The example in Fig. \ref{subfig:performance-motivation} shows the necessity of optimizing the system performance with the consideration of vulnerability variation, where the target is to reduce the schedule length in Fig. \ref{subfig:asap_schedule_security} by 1 \textit{ut}. Traditional methods \cite{article:NW, conference:NW} contract the fewest edges, which are $e_{1,4}$ and $e_{2,5}$ (see the 1st schedule length optimization result in Fig. \ref{subfig:performance-motivation}). However, $e_{5,8}$, $e_{6,9}$, and $e_{7,10}$ might be less vulnerable to hardware Trojan insertions if compared to $e_{1,4}$ and $e_{2,5}$, and contracting these edges causes less vulnerability (see the 2nd schedule length optimization result in Fig. \ref{subfig:performance-motivation}), even though this contracts more edges.





\begin{figure}[!h]
\centering
\begin{tabular}{c}
%\hspace{-1em}
\subfigure [] {
\includegraphics[width=7.4cm]{figure/security1.pdf}\label{subfig:resource_req1}
} \\
%\hspace{-1em}
\subfigure [] {
\includegraphics[width=7.4cm]{figure/security2.pdf}\label{subfig:resource_req2}
}
\end{tabular}
\caption{Example of vendor assignments. \subref{subfig:resource_req1} Vendor assignment and its ASAP schedule, which requires 6 cores. \subref{subfig:resource_req2} Vendor assignment and its ASAP schedule, which requires 7 cores.}
\label{fig:resource_req_motivation}
\end{figure}





\subsubsection{Reducing Cores in Vender Assignment}

Traditional methods always start to optimize the number of cores after the vendor assignment stage when the number of cores required can be evaluated \cite{article:YS, article:XC, article:CL, article:NW}. However, the vendor assignment results also determine the number of cores required, and Fig. \ref{fig:resource_req_motivation} gives an example. The performance constraint is assumed to be 7 $ut$, and all security constraints are satisfied, which are represented by the blue (\textit{duplication-with-diversity}) and black (\textit{isolation-with-diversity}) lines between tasks. Fig. \ref{subfig:resource_req1} and Fig. \ref{subfig:resource_req2} give two different vendor assignments and their ASAP schedules. With the vendor assignment given in Fig. \ref{subfig:resource_req1}, the scheduling result requires 6 cores, but 7 cores are required with the vendor assignment shown in Fig. \ref{subfig:resource_req2}.



\subsection{Problem Description}

Clustering data-dependent tasks to reduce schedule length violates \textit{isolation-with-diversity}, leaving the corresponding intra-core communications unprotected. Although incorporating security constraints in the design process cannot guarantee a full protection from all hardware Trojan attacks, the vulnerability to hardware Trojan insertions can be significantly reduced. In this study, the vulnerability of a communication is regarded as the reduced vulnerability after applying security constraints to this communication, and communications with larger vulnerabilities should have higher protection priorities. The vulnerability analysis \cite{conference:HS} can be performed before our method to first determine the vulnerabilities of communications, and the problem considered in this study can be described as follows.

\begin{problem}
The inputs of this problem are the task graph $TG$, vendor and performance constraints, core speeds of vendors, and vulnerability of each communication. The target is to find a schedule with the lowest vulnerability to hardware Trojan insertion, and the number of cores required is also optimized.
\end{problem}


The design's vulnerability $vul_s$ is regarded as the accumulated vulnerabilities of all unprotected communications, which can be calculated as follows:
\begin{equation}
vul_s=\sum \limits_{e\in E_c}vul(e)
\end{equation}

\noindent where $E_c$ is the set of all all unprotected communications, and $vul(e)$ is the vulnerability of $e$. The notations used in this paper are shown in Table \ref{table:notation}.

\begin{table}[!h]
\renewcommand{\arraystretch}{1.06}
\caption{Descriptions of Notations}
\centering
\begin{tabular}{l|p{6cm}}
\hline
\hline

Notation    &Description     \\
\hline
\hline

$v_i$   &The $i$-th task, and its duplicated task is $v_{i'}$.\\

$c$   &The cluster, which consists of a set of tasks.\\

$e_{ij}$  &The communication from task $v_i$ to task $v_j$. \\

$vul(e)$   &The vulnerability of $e$.\\

$vul_s$   &The design's vulnerability.     \\

$dly(e)$   &Inter-core communication delay of $e$.  \\

$w(e)$   &Evaluated weight of contracting $e$.   \\

$prob(v_i,t_j)$   &The probability that task $v_i$ is executed in time $t_j$.   \\

$DG(c,t_j)$   &The number of tasks in cluster $c$ that are executed in time period $t_j$.   \\

$DG_{max}(c)$   &The maximum of all $DG(c,t_j)$, which estimates the number of cores required for cluster $c$. \\

$Merge(c_i,c_j)$   &The number of cores reduced after merging clusters $c_i$ and $c_j$.   \\

\hline
\hline
\end{tabular}
\label{table:notation}
\end{table}




%In this work, the calculation of $risk(e)$ is determined by system designers. All possible reasons for the Trojan attack via $e$ should be considered, such as the types of connected tasks, the importance of information transmitted, and the difficulty of leaking information.

%To simplify the experiments, the core speeds of all vendors are assumed to be the same. If the core speeds of different vendors vary, this proposed method can easily be extended to fit.





\section{Security-Driven Task Scheduling with Performance Constraints}

In this section, a three-step task scheduling method is proposed, and both the design's vulnerability and the number of cores required are optimized under performance constraints. The three steps of the proposed method are performance-constrained task clustering, vendor assignment with core minimization, and task scheduling.




\subsection{Performance-Constrained Task Clustering}
%System performance is one of the key considerations for designers, and they always put several timing-critical tasks into the same core to change the inter-core communication delays into a much smaller intra-core communication delay to reduce the schedule length \cite{article:CL, article:NW, conference:NW}. However, this brings consequence security loss to the system, which must be optimized under performance constraints.

In this stage, we first apply security constraints to all tasks and communications, and then iteratively assign data-dependent tasks into the same core to meet the performance constraints with the design's vulnerability optimized. Typically, the cores produced by different vendors have different speeds, and the exact speed of each core is not yet determined; thus, we assume that tasks are performed with the slowest speed when optimizing the schedule length. In addition, we discuss only the method of contracting edges in $TG$, and schedule length optimization of the duplicated task graph $TG'$ can be performed in the same manner.

Source and sink nodes $s$ and $t$ are added to $TG$, and directed edges that point from $s$ to 0-indegree nodes and from 0-outdegree nodes to $t$ are also added. An example of the task graph from Fig. \ref{subfig:tg4} with $s$ and $t$ added is given in Fig. \ref{subfig:TG1}. The \textbf{timing violated graph} ($TVG=(V_T, E_T)$) is then constructed by all paths from $s$ to $t$ whose lengths exceed the performance constraints, and it is an induced subgraph of $TG$. $V_T$ consists of $s$, $t$ and all tasks with negative slacks, and $E_T=\{(v_i,v_j)\in E, v_i\in V_T \textrm{~and~} v_j\in V_T\}$. Let $slack(v)$ be the slack time of $v$ under the performance constraint, which is calculated as follows:
\begin{equation}
slack(v) = t_{alap}(v)-t_{asap}(v)-exec(v)
\end{equation}

\noindent where $exec(v)$ is the execution time of task $v$, and $t_{asap}(v)$ and $t_{alap}(v)$ are the ASAP and as-late-as-possible (ALAP) schedules, respectively. Fig. \ref{subfig:tvg1-1} shows an example of $TVG$, where the performance constraint is 5 $ut$ and the delay is 1 $ut$ for each edge.





\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1em}
\subfigure [] {
\includegraphics[width=2.3cm]{figure/TG1.pdf}\label{subfig:TG1}
}&\hspace*{-1.6em}
\subfigure [] {
\includegraphics[width=3cm]{figure/tvg.pdf}\label{subfig:tvg1-1}
} &\hspace*{-1.6em}
\subfigure [] {
\includegraphics[width=3.05cm]{figure/tvg1.pdf}\label{subfig:tvg1-2}
}
\end{tabular}
\caption{Example of evaluating the timing violated graph. \subref{subfig:TG1} Task graph with $s$ and $t$. \subref{subfig:tvg1-1} $TVG$ with a timing constraint of 5 $ut$. \subref{subfig:tvg1-2} The evaluation of $w_{dly}(e)$.}
\label{fig:weight_e}
\end{figure}

For application-specific IPs, data-dependent tasks might have to be executed by different IP cores, resulting in the corresponding edge being unable to be contracted. Therefore, we only focus on the edges that can be contracted to reduce the schedule length. In the following discussion, we assume that all edges can be contracted for simplicity.

Let $dly(e_{ij})$ be the inter-core communication delay of $e_{ij}$, and all intra-core communication delays are ignored in this study. Contracting an edge ($e_{ij}$) reduces the lengths of all paths that pass through $e_{ij}$ by $dly(e_{ij})$. Let $w_{dly}(e_{ij})$ be the sum of the reduced schedule lengths of all paths (from $s$ to $t$) in $TVG$ after contracting $e_{ij}$, and it is calculated by the following equation:
\begin{equation}
w_{dly}(e_{ij})=path_{tvg}(e_{ij})*dly(e_{ij})
\end{equation}


\noindent where $path_{tvg}(e_{ij})$ is the number of paths in $TVG$ that pass through $e_{ij}$.



Fig. \ref{subfig:tvg1-2} illustrates the $w_{dly}(e_{ij})$ and $vul(e_{ij})$ in $TVG$, which are indicated next to the edges. The target in the schedule length optimization stage is to contract the edges with larger $w_{dly}(e_{ij})$ and smaller vulnerability $vul(e_{ij})$. Therefore, the total weight that evaluates an edge $e_{ij}$ contraction in $TVG$, which is denoted as $w(e_{ij})$, can be calculated as follows:
\begin{equation}
w(e_{ij}) = \frac{w_{dly}(e_{ij})}{vul(e_{ij})}
\label{equ:weight_e}
\end{equation}

%Fig. \ref{subfig:tvg1-2} illustrates the $w_{dly}(e_{ij})$ and $risk(e_{ij})$ in $TVG$, which are indicated next to the edges.%, and the $dly(e)$ of all edges is 1 $u.t.$.% Choosing the edges with larger $w(e_{ij})$ indicates that less edges will be contracted until the performance constraint is reached.


However, not all edges can be contracted with respect to multicore parallel execution. Let $in\_edge(v)$ be the set of edges that end with $v$, and let $out\_edge(v)$ be the set of edges that start from $v$. Edges in $TG$ that belong to the same $in\_edge(v)$ or $out\_edge(v)$ are called \textbf{brother edges}. If an edge is contracted during performance optimization, all its brother edges can no longer be contracted. The reason is that contracting brother edges means the tasks that once could be executed parallel in different cores now must be executed sequentially in the same core, and this may result in an increased schedule length. For example, contracting brother edges $e_{4,6}$ and $e_{4,7}$ in Fig. \ref{subfig:tvg1-1} makes $v_6$ and $v_7$ need to be conducted sequentially in the same core, but they can be computed once concurrently in different cores.

In addition, two edges belonging to the same path in the $TVG$ should not be contracted simultaneously, and this avoids the over-optimization of the path length, which causes additional vulnerability to hardware Trojan insertions. The following example explains the reason, where the edges $e_{1,4}$ and $e_{4,7}$ belong to the same path in $TVG$ (refer to Fig. \ref{subfig:tvg1-1}). Suppose that contracting either $e_{1,4}$ or $e_{4,7}$ will make the path length smaller than the performance constraint, and therefore, $e_{1,4}$ or $e_{4,7}$ should not contracted at the same time to avoid the additional vulnerability.


Then, a weighted \textbf{edge contraction conflict graph} ($ECCG=(V_E,E_E)$) is constructed to represent whether every pair of edges in $TVG$ can be contracted simultaneously. Each vertex in $V_E$ represents an edge in $TVG$ that can be contracted, and the weight of a vertex in $V_E$ equals the weight of the corresponding edge in $TVG$. Two vertices in $V_E$ are connected when their corresponding edges cannot be contracted simultaneously, under one of the following two situations:
\begin{enumerate}
\item These two edges are brother edges (with respect to the multicore parallel execution);
\item These two edges belong to the same path in $TVG$ (to prevent the over-optimization of the path length).
\end{enumerate}




\begin{algorithm}[!b]
\caption{Task clustering with performance constraint, $task\_cluster(TG, pc)$.}
\label{alg:PCTC}
\begin{flushleft}
{Input:}
task graph, $TG$;\\
\hspace*{2.8em}performance constraint, $pc$.\\
{Output:} performance-constrained clustering result, $TC$.
\end{flushleft}
\begin{algorithmic}[1]
\WHILE{$TG.schedule\_length > pc$}
\STATE Construct $TVG$ from $TG$.
\FOR{each $e$ in $TVG$}
\STATE Calculate $w(e)$;
\ENDFOR
\STATE Construct $ECCG$ from $TVG$;
\FOR{Each node $e$ in $ECCG$}
\STATE $ECCG.node\_weight(e)=w(e)$;
\ENDFOR
\STATE Calculate $MWIS$ in $ECCG$;
\FOR{each node $e$ in $MWIS$}
    \STATE Contract the corresponding edge $e$ in $TG$;
\ENDFOR
\ENDWHILE
\end{algorithmic}
\end{algorithm}

The maximum weight independent set (MWIS) of $ECCG$ is calculated by the method proposed in \cite{conference:LC}, and the target is to find a set of edges with maximum weight that can be contracted simultaneously. Algorithm \ref{alg:PCTC} shows details of the performance-constrained task clustering algorithm with the goal of minimizing the design's vulnerability. In the first step (\textit{Lines 2-5}), $TVG$ is constructed from $TG$, and the weights of all edges in $TVG$ are evaluated. In the second step (\textit{Lines 6-10}), the weighted $ECCG$ is built, and its MWIS is calculated. In the third step (\textit{Lines 11-13}), the MWIS-selected edges in $TG$ are contracted. These three steps are iteratively repeated until the performance constraint is satisfied.


\begin{figure}[!t]
\centering
\begin{tabular}{ccc}
\hspace*{-1.0em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG1.pdf}\label{subfig:EVG1}
} &\hspace*{-1.7em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG2.pdf}\label{subfig:EVG2}
} &\hspace*{-1.7em}
\subfigure [] {
\includegraphics[width=2.8cm]{figure/EVG3.pdf}\label{subfig:EVG3}
}
\end{tabular}
\caption{Example of performance-constrained task clustering procedure. \subref{subfig:EVG1} $TVG$ and its corresponding $ECCG$ before task clustering. \subref{subfig:EVG2} $TVG$ and its corresponding $ECCG$ after 1st iteration of task clustering. \subref{subfig:EVG3} $TVG$ and corresponding $VCG$ after 2nd iteration of task clustering.}
\label{fig:TC}
\end{figure}


With the vulnerabilities of communications given in Fig. \ref{subfig:tvg1-2}, an example of performance-constrained task clustering is shown in Fig. \ref{fig:TC}, where we are about to optimize the schedule length by 2 $ut$. The $TVG$ consists of the nodes and edges with black color, and dashed lines are the contracted edges. $ECCG$ is given beneath the corresponding $TVG$, and the weight of contracting an edge is marked next to the node in $ECCG$. $TVG$ and its corresponding $ECCG$ are constructed (see Fig. \ref{subfig:EVG1}), and its MWIS is $\{e_{5,8}, e_{6,9}, e_{7,10}\}$ which is contracted in the first iteration. Then, both $TVG$ and $ECCG$ are updated as shown in Fig. \ref{subfig:EVG2}, where $e_{5,7}$ and $e_{8,10}$ are not in $ECCG$ because their brother edges $e_{5,8}$ and $e_{7,10}$ are already contracted. The MWIS of the current $ECCG$ is $\{e_{1,4}, e_{2,5}\}$, and after contracting these edges, Fig. \ref{subfig:EVG3} yields the final clustering results, with the performance constraint satisfied.% and the corresponding $ECCG$, and $e_{5,8}$ is contracted in the final iteration.



\subsection{Vendor Assignment with Core Minimization}

%With performance-constrained task clustering results, tasks are then assigned to IP vendors.
The principle of vendor assignment is to iteratively cluster tasks into a number of $v_c$ (vendor constraint) clusters, and assign each cluster with an IP vendor according to its core speed. Different from task clustering in the performance-constrained task clustering stage that violates isolation-with-diversity by clustering date-dependent tasks, clustering (also named as \textbf{cluster merging}) in vendor assignment follows all security constraints.%, and only clusters tasks that can be assigned with the same IP vendor. % The speed variations of cores between different IP vendors are neglected in this paper.

The \textbf{vendor conflict graph} ($VCFG=(V_c, E_{cf})$) is constructed from the performance-constrained clustering results, and it represents whether two clusters must be assigned to different vendors. $V_c$ is the set of all clusters from $TG$ and $TG'$, and a cluster is determined by the following two situations: 1) a task that is not connected by any contracted edge is regarded as a cluster; and 2) tasks that are connected to each other by contracted edges are in the same cluster, and the index of this cluster is decided by the minimum index of the tasks in this cluster. $E_{cf}$ is the edge set in $VCFG$, and if two tasks must be assigned to different IP vendors due to security constraints, the two clusters that contain these two tasks will be connected in $VCFG$.

The \textbf{vendor compatible graph} ($VCPG=(V_c, E_{cp})$) is the complement graph of $VCFG$, and an edge in $E_{cp}$ indicates that the connected clusters can be assigned to the same vendor. Fig. \ref{subfig:vcg_c_1} gives examples of $VCFG$ and $VCPG$, which are constructed from the performance-constrained clustering result shown in Fig. \ref{subfig:EVG3}. Because the edges in $VCPG$ are too numerous to demonstrate, we use dashed lines to represent the remaining edges that are connected to this cluster.

%The principle of vendor assignment is to iteratively cluster tasks into a number of $v_c$ (vendor constraint) clusters, and then assign each cluster with a IP vendor.



\begin{figure}[!t]
\centering
\begin{tabular}{c}
\hspace*{-0.5em}
\subfigure [] {
\includegraphics[width=8.6cm]{figure/vcg_c_1.pdf}\label{subfig:vcg_c_1}
}\\\hspace*{-1.2em}
\subfigure [] {
\includegraphics[width=8.8cm]{figure/vcg_c_2.pdf}\label{subfig:vcg_c_2}
}
\end{tabular}
\caption{Example of evaluating vendor compatible graph. \subref{subfig:vcg_c_1} $VCFG$ and $VCPG$ derived from task clustering results. \subref{subfig:vcg_c_2} Distributions of clusters.}
\label{fig:vc_c}
\end{figure}



\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\subfigure [] {
\hspace*{-1em}
\includegraphics[width=5.8cm]{figure/vcg1.pdf}\label{subfig:assign1}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg2.pdf}\label{subfig:assign2}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg3.pdf}\label{subfig:assign3}
} \\\hspace*{-1em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg4.pdf}\label{subfig:assign4}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg5.pdf}\label{subfig:assign5}
} &\hspace*{-1.5em}
\subfigure [] {
\includegraphics[width=5.8cm]{figure/vcg6.pdf}\label{subfig:assign6}
}
\end{tabular}
\caption{Example of cluster merging procedure. \subref{subfig:assign1} $VCFG$ and $VCPG$ in 2nd iteration of cluster merging. \subref{subfig:assign2} $VCFG$ and $VCPG$ in 3th iteration of cluster merging. \subref{subfig:assign3} $VCFG$ and $VCPG$ in 4th iteration of cluster merging. \subref{subfig:assign4} $VCFG$ and $VCPG$ in 5th iteration of cluster merging. \subref{subfig:assign5} $VCFG$ and $VCPG$ in 6th iteration of cluster merging. \subref{subfig:assign6} $VCFG$ and $VCPG$ in 7th iteration of cluster merging.}
\vspace*{-0.9em}
\label{fig:assign}
\end{figure*}


%Then, the accumulated probability of task concurrency is introduced to estimate the number of cores required during vendor assignment. The \textbf{mobility} of a task $v_{i}$ is denoted as $M(v_i)$ and defined as a set of consecutive time periods $M(v_{i})=[t_{asap}(v_{i}),~t_{alap}(v_{i})]$.% where $t_{asap}(v_i)$ and $t_{alap}(v_i)$ are the ASAP scheduling and ALAP scheduling results, respectively.% Then, the \textit{mobilities} of all tasks are calculated and the \textit{distribution graph} \cite{article:PP} for each cluster is constructed to estimate the number of cores required during vendor assignment.

Then, the accumulated probability of task concurrency is calculated, which is denoted as \textit{distribution graph} (DG). We assume that the probabilities of a task on all its possible scheduling results are the same \cite{article:PP}, and the probability that $v_i$ is executed in time $t_j$ is denoted as $prob(v_i,t_j)$. The summation of the probabilities of all tasks in a cluster $c$ for the time period $t_j$ is denoted as $DG(c, t_j)$ and calculated as follows:
\begin{equation}
DG(c, t_j) = \sum \limits_{v_i\in c} prob(v_i, t_j)
\end{equation}


The maximum of all $DG(c, t_j), ~\forall t_j\in[1, p_c]$ is denoted as $DG_{max}(c)$, which is used to estimate the number of cores required for all tasks in cluster $c$. Fig. \ref{subfig:vcg_c_2} presents the distribution graphs of all clusters, where the width of a task means the probability that this task will be conducted at the corresponding time period.

The number of cores required may be reduced by merging two clusters $c_i$ and $c_j$, which is denoted as $Merge(c_i, c_j)$, and it can be calculated as follows:
\begin{equation}
Merge(c_i, c_j) = DG_{max}(c_i) + DG_{max}(c_j) - DG_{max}(c_i+c_j)
\label{equ:weight_e2}
\end{equation}



A larger $Merge(c_i, c_j)$ indicates a higher probability that tasks in $c_i$ and $c_j$ can share the same cores, and therefore, assigning these tasks to the same IP vendor reduces the number of cores. Examples of calculating $Merge(c_2, c_3)$ and $Merge(c_2, c_7)$ are shown in Fig. \ref{subfig:vcg_c_2}. $Merge(c_2, c_3)=1+0.5-1.5=0$, which means that core reduction cannot be achieved by merging $c_2$ and $c_3$. $Merge(c_2, c_7)=1+1-1=1$, indicating that merging $c_2$ and $c_7$ can reduce one IP core.


$Merge(c_i, c_j)$ is then set as the weight of edge $(c_i, c_j)$ in $VCPG$. The edge with maximum weight is chosen, and the connected clusters are merged into one; this procedure continues until the number of clusters equals the number of vendors available. Because $VCPG$ with $O(n)$ nodes has nearly $O(n^2)$ edges, the maximum weight independent set of $VCPG$ is not introduced to determine the clusters to be merged due to its large time complexity.


\begin{figure}[!t]
\centering
\hspace*{-0.8em}
\includegraphics[width=8.8cm]{figure/vcg_result.pdf}
\caption{Cluster merging results under vendor constraint.}
\label{fig:assign_result}
\end{figure}

An example of the cluster merging procedure is presented in Fig. \ref{fig:assign}, where the initial $VCFG$ and $VCPG$ are shown in Fig. \ref{subfig:vcg_c_1}, and the vendor constraint is 3. The maximum weight of all edges in $VCPG$ is 1, and $c_2$ and $c_6$ in Fig. \ref{subfig:vcg_c_1} are merged into one cluster, named $c_2$. All edges that once connected to $c_2$ and $c_6$ in $VCFG$ now connect to $c_2$ in the updated $VCFG$, and the weights of edges that connect to $c_2$ in $VCPG$ are also updated. Fig. \ref{subfig:assign1} shows $VCFG$ and $VCPG$ after the 1st iteration of merging clusters. Then, $c_2'$ and $c_6'$ are merged in the 2nd iteration because the weight of their connecting edge is 1. Fig. \ref{subfig:assign2} shows the updated $VCFG$ and $VCPG$. With the corresponding $VCFGs$ and $VCPGs$ shown in Fig. \ref{subfig:assign2}-Fig. \ref{subfig:assign6}, the pairs of clusters ($c_1'$, $c_7$), ($c_3'$, $c_7'$), ($c_1$, $c_3$), ($c_2$, $c_3'$) and ($c_1$, $c_2'$) are iteratively merged. This procedure terminates when the number of clusters equals the vendor constraint, and Fig. \ref{fig:assign_result} gives the final results, where the total estimated number of cores is 5.5.



Then, the number of timing-critical tasks in each cluster is countered, and the clusters containing more timing-critical tasks are assigned to the vendor with faster core speeds. Some timing-critical paths may be over-optimized because all tasks are treated with the lowest core speed in the performance-constrained task clustering stage, and we need to adjust the vendor assignment to meet more security constraints. The slacks of tasks are updated with the assigned core speeds, and every intra-core communication is checked in descending order of vulnerabilities $vul(e)$ to determine whether this communication can be reassigned with security constraints. An intra-core communication ($e$) can be reassigned to inter-core communication to satisfy security constraints only when all tasks in the paths that pass through $e$ have slack times no smaller than $dly(e)$, and one of its connected tasks will be assigned to the IP vendor with the least core increment.% This procedure is named as vendor assignment adjustment in the following discussion.

% some data-dependent tasks that once assigned to the same core in performance-constrained task clustering stage can be re-assigned with different IP vendors to meet vendor diversity constraints. The slack time of each tasks is recalculated with the actual processing time, and a intra-core communication ($e$) can be reassigned to inter-core communication with a delay $delay(e)$ only when 1) all tasks in the paths that passing though $e$ have slack times no smaller than $delay(e)$; 2) exist other IP vendors that $source(e)$ or $target(e)$ node can be assigned, and either $source(e)$ or $target(e)$ will be assigned to the IP vendor with the least core increment. All intra-core communications will be checked in the descending order of $risk(e)$.%, and this process is denoted as $vendor\_adjust$ in the following discussion.

% Contracting the maximum weight edge in $VCPG$ means the maximization of cores charing, which can in turn minimize the number of cores required.


\begin{algorithm}[!h]
\caption{Vendor-assignment with core minimization, $vendor\_assign(TC, TC', vc, pc)$.}
\label{alg:VA}
{Input:}
performance-constrained clustering results of task\\
\hspace*{2.4em}  graph and duplicated task graph, $TC$, $TC'$.\\
\hspace*{2.4em} performance and vendor constraints, $pc$, $vc$.\\
%\hspace*{2.4em}  core speeds of vendors.\\
{Output:} vendor assignment, $VA$.
\begin{algorithmic}[1]
%\STATE calculate the mobility of of each task.
\FOR{each cluster $c$}
    \STATE calculate $DG_{max}(c)$.
\ENDFOR
\STATE Construct $VCFG$ and $VCPG$;
\STATE Calculate the weights of edges in $VCPG$
\WHILE{$VCPG.node\_num > vc$}
\STATE Choose the edge $e_{max}=(c_i,c_j)$ with the maximum weight in $VCPG$, and merge $c_i$ and $c_j$ into one cluster.%, denoted as $c_{i}$.
\STATE Update $VCFG$ and weighted $VCPG$,
%\STATE Update the weights of edges that connect $c_i$ in $VCPG$.;
\ENDWHILE
%\STATE Count the number of timing critical tasks in each cluster;
\WHILE {Not all clusters are assigned with IP vendors}
    \STATE assign $c_i$ to vendor $vendor_j$, where $c_i$ is an unassigned cluster with the most timing critical tasks and $vendor_j$ is the available vendor with the fastest core speed.
\ENDWHILE
\STATE Update the distribution graphs of tasks with assigned core speeds;
%\STATE Sort security constraint-violated edges in descending order of security loss;
\STATE $E_{cv}$ is the set consists of all intra-core communications;
\WHILE {$E_{cv}\neq \emptyset$}
\STATE Find $e\in E_{cv}$ with the largest $vul(e)$;
\IF{Assigning $e$ with security constraints does not violate performance constraints}
\STATE Assign either $source(e)$ or $target(e)$ with another IP vendor;
\STATE Update the distribution graphs of tasks;
\ENDIF
\STATE Remove $e$ from $E_{cv}$;
\ENDWHILE
\end{algorithmic}
\end{algorithm}



Algorithm \ref{alg:VA} describes the proposed vendor assignment algorithm. First (\textit{Lines 1-5}), the number of cores required by each cluster is estimated by $DG_{max}(c)$, and $VCFG$ and weighted $VCPG$ are constructed. Second (\textit{Lines 6-9}), the maximum weight edge in $VCPG$ is chosen, and the connected clusters are merged into one cluster. Both $VCFG$ and weighted $VCPG$ are then updated, and this procedure continues until the number of clusters equals the number of IP vendors available. Third (\textit{Lines 10-13}), the cluster containing more timing-critical tasks is assigned to the IP vendor with faster core speed. Finally (\textit{Lines 14-22}), the unprotected edges are checked in descending order of vulnerabilities to hardware Trojan insertions, and the vendor assignments are adjusted under performance constraints to further reduce the design's vulnerability.



%An example of the vendor assignment procedure is illustrated in Fig. \ref{fig:assign}, where the initial $VCFG$ and $VCPG$ are presented in Fig. \ref{subfig:vcg_c_1}, and the vendor constraint is 3. The maximum weight of all edges in $VCPG$ is 1, and $c_2$ and $c_6$ in Fig. \ref{subfig:vcg_c_1} are merged into one cluster, named $c_2$. All edges that once connected to $c_2$ and $c_6$ in $VCFG$ now connect to $c_2$ in the updated $VCFG$, and the weights of edges that connect to $c_2$ in $VCPG$ are also updated. Fig. \ref{subfig:assign1} shows the $VCFG$ and $VCPG$ after the 1st iteration of merging clusters. Then, $c_2'$ and $c_6'$ are merged in the 2nd iteration because the weight of their connecting edge is 1. Fig. \ref{subfig:assign2} presents the updated $VCFG$ and $VCPG$. With the corresponding $VCFG$ and $VCPG$ shown in Fig. \ref{subfig:assign2}-Fig. \ref{subfig:assign6}, the pairs of clusters ($c_1'$, $c_7$), ($c_3'$, $c_7'$), ($c_1$, $c_3$), ($c_2$, $c_3'$) and ($c_1$, $c_2'$) are iteratively merged. This procedure terminates when the number of clusters equals the vendor constraint, and Fig. \ref{fig:assign_result} gives the final results, where the total estimated number of cores is 5.5.
% After the cluster merging procedure, tasks in each cluster are assigned to the same IP vendor.







\subsection{Procedure of the Proposed Task Scheduling Method}

With all security constraints satisfied, the number of IP vendors is always equal to the number of nodes in the maximum clique (denoted as \textit{maximum clique size}) of $VCFG$. However, performance-constrained task clustering and vendor assignment may potentially increase the number of vendors required, and we must check every contracted edge if the resulting maximum clique size exceeds the vendor constraint. Computing the maximum clique size of a graph is NP-complete, and an efficient heuristic approach \cite{article:CL} is introduced. Each time after determining a contracted edge, the impact on the maximum clique size of the corresponding $VCFG$ is evaluated, and the edge is not contracted if the vendor constraint is violated. Instead, the algorithm chooses the second-best solutions.




\begin{algorithm}[!h]
\caption{Security-aware task scheduling with performance constraints, $task\_schedule(TG, pc, vc)$.}
\label{alg:PCTS}
{Input:} task graph, $TG$\\
\hspace*{2.4em} performance and vendor constraints, $pc$, $vc$.\\
%\hspace*{2.4em}  core speeds of vendors.\\
{Output:} scheduling results, $TS$.
\begin{algorithmic}[1]
\STATE $TC=task\_cluster(TG,pc)$;
\STATE $TC'=task\_cluster(TG',pc)$, where $TG'$ is the duplicate of $TG$;
\STATE $VA=vendor\_assign(TC, TC', vc, pc)$;
%\STATE $VA=vendor\_adjust(VA)$;
\FOR{each vendor $vendor_i$}
    \STATE $V_{vendor_i}$ is the set of all tasks assigned to $vendor_i$;
%    \STATE Calculate the mobilities of tasks in $V_{vendor_i}$;
    \STATE $FDS(V_{vendor_i}, pc)$;% using Force-directed scheduling;
\ENDFOR
\end{algorithmic}
\end{algorithm}


After vendor assignment, tasks with the same IP vendor are scheduled together using the force-directed scheduling (FDS) method \cite{article:PP}. FDS schedules tasks evenly across each time period, requiring only a small number of cores. Algorithm \ref{alg:PCTS} gives the whole procedure of the proposed task scheduling algorithm. Tasks in the task graph and duplicated task graph are clustered under the performance constraint $p_c$ (\textit{Lines 1-2}) and then assigned to IP vendors with a minimized number of cores required (\textit{Line 3}). Finally, tasks in each IP vendor are scheduled concurrently by the FDS (\textit{Lines 4-7}).% In this study, two types of security constraints are considered, and when more types of security constraints are introduced, our proposed method can be easily adopted and applied.

Our proposed methods can also be easily adopted in other actual scenarios. In the first scenario, the number of vendors available might be less than the maximum clique size of the corresponding $VCFG$. In this situation, a vendor-constrained task clustering method \cite{article:NW} can be introduced before vendor assignment, so that the vendor constraint can be satisfied with a minimized number of contracted edges. In the second scenario, application-specific IPs might not be able to support every task. For each type of IP, we first build its $VCFG$ and $VCPG$ according to the clustering results of tasks that belong to this type, and then perform the vendor assignment along with task scheduling individually.

\subsection{Time Complexity Analysis}

The time complexity of the proposed method is analyzed as follows, and the input task graph has $n$ nodes and $m$ edges.

In each iteration of the performance-constrained task clustering stage, constructing $ECCG$ from $TVG$ requires $O(m^2)$, and finding the MWIS in $ECCG$ also requires $O(m^2)$ \cite{conference:LC}. Only a constant number of iterations are conducted before reaching the performance constraint, and finding all contracted edges to meet the performance constraint requires $O(m^2)$. In addition, each time before contracting an edge, updating $VCFG$ and evaluating its impact on the maximum clique size requires $O(n^2)$, and only a limited number of edges are contracted, making its computational cost remains at $O(n^2)$. The total time complexity of performance-constrained task clustering is $O(m^2)$ (because $O(n)\leq O(m)$).

In the vendor assignment and task scheduling stage, constructing $VCFG$ and $VCPG$ requires $O(n^2)$. In each iteration of merging clusters, $O(m)$ is required to estimate the maximum clique size, and $O(n)$ is required to update both $VCFG$ and $VCPG$. Vender assignment requires $O(n)$ iterations of merging clusters, and its time complexity is $O(mn)$. Performing the force-directed scheduling method to schedule all tasks requires $O(n^2)$, and the total time complexity of the vendor assignment and task scheduling stage is $O(mn)$.

The sum of $O(m^2)$ and $O(mn)$ is $O(m^2)$, which is the total time complexity of the proposed method.


\section{Experimental Results}

\subsection{Experimental Setups}
All experiments were implemented in C on a Linux Workstation with an E5 2.6-GHz CPU and 32-GB RAM. We tested eight benchmarks from two sources\footnote{https://www.kasahara.cs.waseda.ac.jp/schedule/index.html.}: task graphs modeled from real application programs, including robot control (robot), sparse matrix solver (sparse), and SPEC fpppp (fpppp); and randomly generated task graphs (rnc500, rnc1000, rnc2000, rnc3000 and rnc5000). To simplify the experiments, all intra-core communication delays were ignored, and we set the step of core speed differences equal to 5\% of the fastest core speed.

\begin{table}[!h]
\renewcommand{\arraystretch}{1.1}
\caption{Details of Benchmarks}
\centering
\begin{tabular}{c|c|c|c|c|c}
\hline
\hline

task    &\multicolumn{1}{c|}{\multirow{2}{*}{$n$}}     &\multicolumn{1}{c|}{\multirow{2}{*}{$m$}}     &\multicolumn{1}{c|}{\multirow{2}{*}{Para. }}  &ACC   &\multicolumn{1}{c}{\multirow{2}{*}{\textit{maxClique}}}  \\
graph   &                                            &           &        & ($ut$)          &       \\
\hline
\hline

robot   &88   &131     &4.4 &28.2   &3 \\

sparse  &96   &67    &16.0  &20.2   &3 \\

fpppp   &334   &1145    &6.7  &21.3    &3  \\

rnc500  &500   &1910    &27.7  &10.6    &3  \\

rnc1000  &1000   &3005   &60.2  &7.8  &3 \\

rnc2000   &2000   &3930   &151.9  &10.6  &3 \\

rnc3000   &3000   &39034    &34.2 &13.0   &4  \\

rnc5000   &5000   &55432   &90.8  &11.0  &4 \\

\hline
\hline
\end{tabular}
\label{table:detail}
\end{table}


\begin{table*}[!t]
\renewcommand{\arraystretch}{1.1}
\caption{Performance-Constrained Task Scheduling Results on Real Application Graphs.}
\centering
\begin{tabular}{c|c|c|c|ccc|ccc|ccc}
\hline
\hline
task                                      &\multicolumn{1}{c|}{\multirow{2}{*}{$CCR$}}     &SL       &$pc$      &\multicolumn{3}{c|}{$risk_s~(10^{-3})$}        &\multicolumn{3}{c|}{Num. of cores}    &\multicolumn{3}{c}{average runtime ($s$)}    \\ \cline{5-7} \cline{8-10} \cline{11-13}
graph                                                                               &                                                &($ut$)   &($ut$)    &C-B\cite{article:CL}   &MC-B\cite{article:NW}    &Our   &C-B\cite{article:CL}       &MC-B\cite{article:NW}  &Our    &C-B\cite{article:CL}       &MC-B\cite{article:NW}   &Our  \\

\hline
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{robot}}       &0.5 &839 &671 &353.68    &206.57    &155.35    &14    &12    &11    &3.9     &17.5    &18.7            \\
                                                                             &1.0  &1114  &892           &274.91   &185.62    &147.83    &14    &12    &10    &3.9     &17.6    &18.9             \\
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{sparse}}     &0.5 &179 &143 &146.75   &93.48    &76.07    &21    &18    &16    &5.3     &41.2    &33.8          \\
                                                                                       &1.0 &236  &189 &157.48   &98.47    &83.59    &19    &18    &15    &5.5     &42.3    &34.5            \\

\hline

\multicolumn{1}{c|}{\multirow{2}{*}{fpppp}}        &0.5 &1590  &1272  &15.23    &6.37    &4.52    &13    &12    &10    &7.5     &50.2    &47.6             \\
                                                    &1.0 &2119  &1695  &11.49    &6.85    &4.97    &12    &11    &10    &8.3     &53.5    &49.8            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{avg.}}      &0.5 &      &  &171.89  &102.14      &78.65  & &  &   &   &         \\
                                                &1.0 &     &  &147.96  &96.98      &78.80  & &  &   &   &         \\

\hline
\hline
\end{tabular}
\label{table:PCTS_A}
\end{table*}
%To test the performance of our proposed methods, a set of benchmarks is tested, and

Table \ref{table:detail} lists the details of these benchmarks. Columns $n$ and $m$ give the numbers of tasks and communications in each task graph, respectively. Column Para. shows the parallelism of each task graph, which is the ratio of the total processing time of all tasks to the ASAP schedule length (without communication delays). Column ACC shows the average computational cost of each task. Considering that the maximum clique sizes of most task graphs modeled from real application programs are no larger than 4\cite{article:CL}, the maximum clique sizes (see column \textit{maxClique}) of all randomly generated $TGs$ in Table \ref{table:detail} are 3 or 4, and the IP vendor constraint is set to be the maximum clique size of the benchmark.% The core speeds of different vendors may be different, and we set the step of speed differences equals to 5\% of the fastest core speed in our experiments.
%\begin{enumerate}
%\item Comparing the benchmarks with the same number of nodes, the benchmark with larger maximum clique size always indicates a larger number of edges. Therefore, too many edges have to be contracted to boost the performance, which is not practical in actual.
%\item The maximum clique sizes of most task graphs are no larger than 4\cite{article:CL}.
%\end{enumerate}


%To demonstrate the effectiveness of our proposed methods, the task scheduling results of our methods are compared with a Baseline method \cite{article:CL} which schedules task strictly following the security constraints.



\begin{table*}[!t]
\renewcommand{\arraystretch}{1.1}
\caption{Performance-Constrained Task Scheduling Results on Randomly Generated Task Graphs.}
\centering
\begin{tabular}{c|c|c|c|ccc|ccc|ccc}
\hline
\hline
task                                     &\multicolumn{1}{c|}{\multirow{2}{*}{$CCR$}}     &SL       &$pc$      &\multicolumn{3}{c|}{$risk_s~(10^{-3})$}        &\multicolumn{3}{c|}{Num. of cores}    &\multicolumn{3}{c}{average runtime ($s$)}    \\ \cline{5-7} \cline{8-10} \cline{11-13}
graph                                    &                                                &($ut$)   &($ut$)    &C-B\cite{article:CL}   &MC-B\cite{article:NW}    &Our   &C-B\cite{article:CL}       &MC-B\cite{article:NW}  &Our    &C-B\cite{article:CL}       &MC-B\cite{article:NW}   &Our  \\

\hline
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc500}}      &0.5 &280 &224  &25.13    &15.70    &12.46    &68    &65    &58    &18.9     &113.6    &95.4               \\
                                                  &1.0  &373  &300               &20.41    &16.35    &12.95    &67    &63    &56    &20.3     &121.3    &98.7               \\
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc1000}}     &0.5 &190 &152  &47.92    &33.94    &26.71    &95    &88    &78    &38.8     &259.3    &183.5             \\
                                                  &1.0 &254  &203     &48.73    &31.95    &23.69    &87    &81    &74    &42.1     &273.3    &189.7              \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc2000}}     &0.5 &199  &159  &20.61    &16.53    &12.37    &217    &184    &167    &57.5     &715.7    &553.6             \\
                                                  &1.0 &268  &214  &21.47    &14.51    &10.62    &206    &180    &164    &59.1     &748.2    &572.9            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{rnc3000}}     &0.5 &1336  &1069  &56.41    &43.27    &35.58    &73    &67    &62    &182.5     &3582.6    &3014.9             \\
                                                  &1.0 &1779  &1423  &53.49    &37.74    &31.18    &68    &62    &56    &192.2     &3715.3    &3253.4            \\
\hline

\multicolumn{1}{c|}{\multirow{2}{*}{rnc5000}}       &0.5 &850  &680  &48.13    &43.17    &34.52    &142    &132    &122    &384.9     &9004.5    &6764.2             \\
                                                    &1.0 &1146 &917  &54.84    &47.25    &36.55    &137    &125    &115    &395.4     &9528.3    &6816.1            \\

\hline
\multicolumn{1}{c|}{\multirow{2}{*}{avg.}}       &0.5 &      &  &39.64  &30.52      &24.33   &   &  &   &   &         \\
                                                 &1.0 &     &  &39.79  &29.56      &23.01  & &  &   &   &         \\
\hline
\hline
\end{tabular}
\label{table:PCTS_R}
\end{table*}




\textbf{Our} proposed method is then compared with two other methods to demonstrate its effectiveness. The first approach is the ``\textit{cluster-based approach}'' (\textbf{C-B} for short) \cite{article:CL}. This approach optimizes the schedule length by placing critical tasks on a single core, and then colors the performance-driven schedule to fulfill security constraints. The second approach is the ``\textit{min-cut-based approach}'' (\textbf{MC-B} for short) \cite{article:NW}. This approach boosts performance by iteratively contracting the edges selected by the max-flow min-cut algorithm, then assigns tasks to the IP vendor with the traditional graph coloring method, and finally schedules tasks with the force-directed scheduling-based method.

%The \textbf{PSO-B} method \cite{article:SR} uses a PSO-based method to find a solution with minimized resource requirements. The \textbf{C-B} method \cite{article:CL} optimizes the schedule length by placing critical tasks on a single core, and conducts IP vendor assignment using the traditional graph coloring method. The \textbf{MC-B} method \cite{article:NW} boosts performance by iteratively contracting the edges selected by the max-flow min-cut algorithm and schedules tasks with the force-directed scheduling-based method.% and assigns tasks% with IP vendors while considering% the core speed variation.



\subsection{Performance-Constrained Task Scheduling Results}

The performance-constrained task scheduling results are shown in Tables \ref{table:PCTS_A} and \ref{table:PCTS_R}. The communication-to-computation ratio ($CCR$) is the ratio of the inter-core communication delay to the computational cost of the task, and two $CCRs$ (0.5 and 1.0) are tested. The performance constraint is set to \textit{pc}=0.8\textit{SL}, where $SL$ is the ASAP schedule length with all security constraints satisfied. In this set of experiments, the communications have different vulnerabilities to hardware Trojan insertions, and to simplify our experiments, we set the vulnerability of $e_{ij}$ in $TG$ or $TG'$ as follows:

\begin{equation}
 vul(e_{ij})=\frac{2*dist(e_{ij})*pte}{SL*m}
\label{equ:risk_set1}
\end{equation}

\noindent where $dist(e_{ij})$ is the distance from $s$ to $v_i$. $pte$ is the \textit{possible Trojan entries} \cite{article:SR}, and we set $pte$ equal to 3 for all benchmarks.

Table \ref{table:PCTS_A} compares the task scheduling results of these methods on three real application graphs. The results show that our proposed method obtained the lowest $risk_s$ for all benchmarks. MC-B optimized the system risk by reducing the number of unprotected communications but ignored the security risk variation of communications. MC-B might also choose brother edges to contract, resulting in a $risk_s$ larger than that of our proposed method. Furthermore, MC-B forgot to optimize the number of cores in the vendor assignment stage, and it required more cores than our method. Regarding method C-B, it ignored both the system risk and the number of cores required during task scheduling, and both the $risk_s$ and number of cores are the largest among the compared methods.

The comparison results of five randomly generated task graphs are shown in Table \ref{table:PCTS_R}. The number of edges in these task graphs is much larger than the edges of \textit{robot}, \textit{sparse}, and \textit{fpppp}, and therefore, the risk of each communication is relatively much smaller (refer to Equ. (\ref{equ:risk_set1})). The comparison results show that our proposed method also obtained the best results in reducing both the $risk_s$ and the number of cores.

In terms of algorithm runtime, all of the algorithms can produce solutions within 1 min for the benchmarks modeled from real applications (see Table \ref{table:PCTS_A}). For benchmarks that contain many nodes and edges, such as \textit{rnc5000} which has 5000 nodes and 55432 edges (see Table \ref{table:PCTS_R}), our proposed method can output a solution within approximately 10 minutes, which indicates that our proposed method is applicable for most benchmarks in real practice.

%and $ratio$ is the ratio of $scy_v$ to $scy$. The column $core$ gives the numbers of cores required by the scheduling results, and column $redu_{c}$ shows the percentage of reduced cores compared to the C-B method.







%%The comparison results show that our proposed method maintains most of the security constraints and requires the lowest number of cores. When \textit{CCR}=0.5, our method reduces $scy_v$ by $0.72\%$ compared to the C-B method, and the number of cores required is $19.14\%$ lower. When \textit{CCR}=1.0, $scy_v$ and $core$ of our method are 0.61\% and 18.97\% lower than those of the C-B method, respectively.

%\begin{figure}[!h]
%\centering
%\hspace*{-1.2em}
%\includegraphics[width=8.0cm]{figure/cpu_runtime.eps}
%\caption{CPU runtimes when performing 20 randomly generated task graphs.}
%\label{fig:cpu_runtime}
%\end{figure}



%In addition, we tested the runtimes of these three methods by conducting 20 randomly generated task graphs, and Fig. \ref{fig:cpu_runtime} gives the results. All of these task graphs have 1000 nodes, but their numbers of edges range from 5000 to 100000. The results show that the runtimes of MC-B and our methods increase exponentially with the increment of edges, but the runtimes of our method are still acceptable when conducting the task graphs whose maximum clique sizes are no larger than 4. This indicates the efficiency of our method in dealing with the task graphs modeled from actual application programs.



\subsection{Comparison of Security Risk Optimization Results}

Then, the effectiveness of our method in reducing the system security risk is tested. $CCR$ is set to \textit{CCR}=1.0 for all benchmarks, and the performance constraint is set to $pc=0.9*SL$. Fig. \ref{fig:system_risk} shows the comparative results of security risks among C-B, MC-B, and our methods, with the following three sets of risk configurations:



\begin{figure*}[!t]
\centering
\begin{tabular}{ccc}
\subfigure [] {
\hspace*{-1.5em}
\includegraphics[width=6.4cm]{figure/randomly_set.eps}\label{subfig:rand_risk}
} &\hspace*{-2.8em}
\subfigure [] {
\includegraphics[width=6.4cm]{figure/equally_set.eps}\label{subfig:equ_risk}
} &\hspace*{-2.8em}
\subfigure [] {
\includegraphics[width=6.4cm]{figure/linearly_set.eps}\label{subfig:linear_risk}
}
\end{tabular}
\caption{Comparison of system security risks. \subref{subfig:rand_risk} System security risk evaluations with risks \textit{randomly set}. \subref{subfig:equ_risk} System security risk evaluations with risks \textit{equally set}. \subref{subfig:linear_risk} System security risk evaluations with risks \textit{linearly set}.}
\vspace*{-0.9em}
\label{fig:system_risk}
\end{figure*}


\begin{enumerate}
\item \textbf{Randomly Set}: the risk of each communication is randomly set with the value among [0, $\frac{2*pte}{m}$];
\item \textbf{Equally Set}: the risks of all communications are the same, with the value of $\frac{pte}{m}$;
\item \textbf{Linearly Set}: The communication closer to the source has higher security risk, and the risk of $e_{ij}$ is set as $risk(e_{ij})=\frac{2*(SL-dist(e_{ij}))*pte}{SL*m}$;
\end{enumerate}



%Since both the C-B and MC-B methods ignore the security risk variation, the security risks of all unprotected communications are assumed to be the same in this set of experiments. Therefore, minimizing the system security risk is equivalent to minimizing the number of communications that are not protected by security constraints (denoted as $scy_v$). The \textit{communication-to-computation ratio} ($CCR$) is the ratio of the inter-core communication delay to the computational cost of the task, and it is set to \textit{CCR}=1.0.



%Table \ref{table:VPCTC} gives the experimental results, and the ratio of $scy_v$ to $scy$ (see column $ratio$) is used to evaluate the system security risk. The performance constraint $pc$ is set as $pc=\delta*\textit{SL}$, where $\textit{SL}$ is the ASAP schedule length with all security constraints satisfied. Two performance constraints are tested for each benchmark, with $\delta \in \{0.9, ~0.8\}$. The results show that the C-B method fails the $0.79\%$ and $1.98\%$ security constraints when $\delta$ is set to 0.9 and 0.8, respectively. The $scy_v$ optimization results of MC-B and our methods are almost the same for all benchmarks, and the ratios of $scy_v$ to $scy$ are $0.45\%$ and $1.36\%$ when $\delta$ is set to 0.9 and 0.8, respectively.

%The above results indicate that the number of unprotected communications is very limited if the schedule length is optimized to 0.9\textit{SL}, and this number significantly increases if the schedule length is further reduced from 0.9\textit{SL} to 0.8\textit{SL}. Therefore, the schedule length should not be over optimized; otherwise, the system will face large security risks.








\begin{table*}[t]
\renewcommand{\arraystretch}{1.1}
\caption{Comparisons of Cores Required.}
\centering
\begin{tabular}{c|c|cccc|ccccccc}
\hline
\hline
\multicolumn{1}{c|}{\multirow{2}{*}{task}}        &\multicolumn{1}{c|}{\multirow{2}{*}{\textit{SL}}}           & \multicolumn{4}{c|}{Loose vendor constraints}        & \multicolumn{7}{c}{Tight vendor constraints}         \\  \cline{3-6} \cline{7-13}

\multicolumn{1}{c|}{\multirow{2}{*}{graph}}       &\multicolumn{1}{c|}{\multirow{2}{*}{($ut$)}}     &\multicolumn{1}{c}{\multirow{2}{*}{$vc$}}   & \multicolumn{3}{|c|}{Num. of cores}  &\multicolumn{1}{c}{\multirow{2}{*}{$vc$}}   & \multicolumn{3}{|c}{Num. of cores}    & \multicolumn{3}{|c}{Proportion of unprotected edges}    \\ \cline{4-6} \cline{8-10}  \cline{11-13}

                           &    &    & \multicolumn{1}{|c}{\multirow{1}{*}{C-B\cite{article:CL}}}         &MC-B\cite{article:NW}   &~~Our~~  &     &\multicolumn{1}{|c}{\multirow{1}{*}{C-B\cite{article:CL}}}        &MC-B\cite{article:NW}   &~~Our~~    &\multicolumn{1}{|c}{\multirow{1}{*}{C-B\cite{article:CL}}}        &MC-B\cite{article:NW}   &~~Our~~     \\
\hline
\hline

robot              &1114  &3 &10 &9 &8        &2     &10     &8     &7       &2.29\%     &1.53\%     &1.53\%  \\

sparse              &236  &3  &14 &12 &12     &2     &14     &11     &10     &8.96\%     &5.97\%     &5.97\%  \\

fpppp              &2119  &3   &10 &9 &8      &2     &9     &7     &6      &1.57\%     &0.96\%     &0.96\% \\

rnc500            &373    &3  &47 &45 &39     &2     &42     &38     &35      &4.50\%     &3.72\%     &3.72\% \\

rnc1000            &254   &3   &68 &63 &56    &2     &58     &51     &47       &1.73\%     &1.30\%     &1.30\%  \\

rnc2000           &268    &3  &156 &148 &130     &2     &139     &127     &116     &0.74\%     &0.46\%     &0.46\% \\

rnc3000           &1779   &4   &56 &51 &48       &2     &52     &48     &45     &58.52\%     &53.15\%     &53.15\% \\

rnc5000           &1146   &4   &106 &98 &88      &2     &97     &91     &83     &70.24\%     &67.89\%     &67.89\%  \\

\hline
\hline
\end{tabular}
\label{table:core_usage}
\end{table*}




The $pte$ is set to 3 in this set of experiments. Because both C-B and MC-B ignore the security risk variation among communications, they produced the same task scheduling result with different risk configurations, and system security risks of the same task schedule are not the same with different risk configurations. Our proposed method seeks the task schedule with the lowest system security risk, and produces different task scheduling results for different risk configurations.


Figs. \ref{subfig:rand_risk}, \ref{subfig:equ_risk}, and \ref{subfig:linear_risk} show the system security risks with the risk of each communication \textit{randomly set}, \textit{equally set}, and \textit{linearly set}, respectively. For each tested benchmark, our proposed method outperforms both C-B and MC-B with different risk configurations, and detailed comparisons are given as follows:


\begin{enumerate}
    \item When the risks are \textit{randomly set}, the averaged system security risks of C-B and MC-B are 36.72*$10^{-3}$, and 23.02*$10^{-3}$, respectively, and our proposed method obtains the lowest security risk, which is only 18.11*$10^{-3}$.
    \item If the risks are \textit{equally set}, our method and MC-B obtain nearly equivalent results because MC-B treats each communication equally when optimizing system performance. The average system security risks of C-B, MC-B and our methods are 37.47*$10^{-3}$, 22.27*$10^{-3}$, and 20.94*$10^{-3}$, respectively.
    \item If the risks are \textit{linearly set}, our proposed method still demonstrate its advantage when reducing system risks: its average system risk is 18.68*$10^{-3}$, while the average system risks of C-B and MC-B are 41.08*$10^{-3}$ and 26.03*$10^{-3}$, respectively.
    \item For some benchmarks (\textit{robot} and \textit{sparse}), their system security risks are relatively high because the risks of communications are also determined by the number of edges in task graphs. These task graphs have much fewer edges, making the risks of communications in \textit{robot} and \textit{sparse} much larger than that in the other task graphs.
\end{enumerate}



%When the risks are \textit{randomly set}, the averaged system security risk of C-B and MC-B are 36.72*$10^{-3}$, and 23.02*$10^{-3}$, respectively, and our proposed method obtained the lowest security risk, which is only 18.11*$10^{-3}$.

%If the risks are \textit{equally set}, our method and MC-B obtains almost equivalent results, and it is because that MC-B treats each communication equally when optimizing the system performance. The averaged system security risks of C-B, MC-B and our methods are 37.47*$10^{-3}$, 22.27*$10^{-3}$, and 20.94*$10^{-3}$, respectively.

%If the risks are \textit{linearly set}, our proposed method still show its advantage in reducing the system risks, and its average system risk is 18.68*$10^{-3}$, while the averaged system risk of C-B and MC-B are 41.08*$10^{-3}$ and 26.03*$10^{-3}$, respectively.

%For some benchmarks (robot, sparse), their system security risks are relatively high, and this is because the risks communications are also determined by the number of edges in tasks graphs. These task graphs have much less edges, making the risks of communications in \textit{robot} and \textit{sparse} much larger than that in the other task graphs.



%\subsection{Performance Optimization Results With Security Risk Variation}

%Next, the security risk variation among communications is counted. We assume that the task outputs may contain more confidential information and that the system damage caused by triggered hardware trojans becomes more serious when the application proceeds. Therefore, the security risk of $e_{ij}$ in $TG$ or $TG'$ is set to be $risk(e_{ij})=dis(e_{ij})/m$, where $dis(e_{ij})$ is the distance from $s$ to $v_i$, and the performance constraint $p_c$ is set to 0.9\textit{SL}.


%Fig. \ref{fig:System_risk} shows the comparison results of system security risks. Because both C-B and MC-B ignore security risk variation, their task clustering results are the same as shown in Table \ref{table:VPCTC}. The averaged system security risks of C-B, MC-B, and our methods are 26.35*$10^{-3}$, 18.39*$10^{-3}$, and 14.84*$10^{-3}$, respectively, which indicates that our method maintains the highest security level among all three methods.





\subsection{Comparison of Cores Required}

To demonstrate the effectiveness of our method in reducing the number of cores required, the performance constraint is set to \textit{SL} so that the performance-constrained task clustering stage can be skipped. Table \ref{table:core_usage} shows the numbers of cores required, where two sets of vendor constraints are tested. The loose vendor constraints are first set for all benchmarks, and the vendor constraint is set to be the maximum clique size of the corresponding $TG$. C-B ignores core optimization, and MC-B only minimizes the number of cores when scheduling tasks. In our proposed method, reducing the number of cores is considered in both vendor assignment and task scheduling, which enlarges the optimization space for saving cores. The results indicate that our proposed method needs the fewest numbers of cores in all benchmarks, and MC-B and our proposed method reduce the numbers of cores by 8.44\% and 17.11\%, respectively, compared to the C-B method.


Then, the tight vendor constraints are set because there might not be sufficient vendors for some specific IPs, and the vendor constraints of all benchmarks are set to 2. To meet the tight vendor constraints, the vendor-constrained task clustering method proposed in \cite{article:NW} is used to remove some security constraints from communications and allow the adjacent tasks to be executed on the cores from the same IP vendor. Therefore, more communications become unprotected, and the proportions of the number of unprotected edges to the number of all edges are given in the last column of Table \ref{table:core_usage}. Because MC-B and our method use the same vendor-constrained task clustering, the proportions of their unprotected edges are the same. C-B only ignored reducing the number of unprotected edges to meet vendor constraints, and its numbers of unprotected edges are larger. For the benchmarks \textit{rnc3000} and \textit{rnc5000}, whose task graphs contain many 4-cliques, many edges become unprotected to satisfy the vendor constraint. The number of cores required shows that our proposed method also obtained the fewest cores among these three methods, and the average numbers of cores required by MC-B and our proposed method are 13.47\% and 21.49\% less than that of C-B, respectively.



%When set with the loose vendor constraints, our proposed method needs the least numbers of cores in all benchmarks. MC-B, PSO-B and our methods reduce the numbers of cores by 7.55\%, 17.11\% and 17.92\%, respectively, if compared to the C-B method.%, and our proposed \textit{MWIS-based} needs the least number of cores.

%The runtimes of C-B, MC-B, PSO-B and our methods are also compared. In the benchmarks shown in Table I, $m$ can be regarded as \textit{m=cn}, where $c$ is a constant, and the time complexity of our method can be regarded as $O(n^2)$. The averaged comparison results show that the runtimes of MC-B, PSO-B and our methods are $11.12$, $115.35$ and $9.29$ times longer than the C-B method, respectively.





\section{Conclusions}

In this study, a security-driven task scheduling method is proposed to reduce the performance and area overheads of implementing security constraints in the design process, and the desired performance is set as a constraint. Communications are treated with different security importance due to the security risk variation, and a maximum weight independent set-based task clustering method is proposed to reduce the schedule length while maintaining a high security level. In addition, the numbers of cores required are optimized in both vendor assignment and task scheduling stages by assigning tasks that can share most cores to the same vendor and scheduling them evenly in each time period, which enlarges the optimization space for reducing cores. Experimental results demonstrate that our proposed method obtains the highest system security and the fewest cores among all compared methods.

%\bibliographystyle{ieicetr}% bib style
%\bibliography{}% your bib database

\begin{thebibliography}{99}% more than 9 --> 99 / less than 10 --> 9
\bibitem{conference:XW}
X. Wang and R. Karri, ``NumChecker: detecting kernel control-flow modifying rootkits by using hardware performance counters,'' \textit{Proc. Design Automation Conference}, pp. 1-7, May 2013.

%\bibitem{conference:XTN}
%X.T. Ngo, J.-L. Danger, S. Guilley, Z. Najm, and O. Emery, ``Hardware property checker for run-time hardware Trojan detection,'' \textit{Proc. European Conference on Circuit Theory and Design}, pp. 1-4, 2015.

\bibitem{article:SB}
S. Bhunia, M.S. Hsiao, M. Banga, and S. Narasimhan, ``Hardware Trojan attacks: threat analysis and countermeasures,'' \textit{Proceedings of the IEEE}, vol. 102, no. 8, pp. 1229-1247, Aug. 2014.

\bibitem{conference:MH}
M. Hussain, A. Malekpour, H. Guo, and S. Parameswaran, ``EETD: an energy efficient design for runtime hardware Trojan detection in untrusted network-on-chip,'' \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 345-350, 2018.


\bibitem{conference:AM1}
A. Malekpour, R. Ragel, A. Ignjatovic, and S. Parameswaran, ``DosGuard: protecting pipelined MPSoCs against hardware Trojan based DoS attacks,'' \textit{Proc. International Conference on Applications-specific Systems, Architectures and Processors}, pp. 45-52, 2017

\bibitem{conference:FK}
F. Kounelis, N. Sklavos, and P. Kitsos, ``Run-time effect by inserting hardware Trojans in combinational circuits,'' \textit{Euromicro Conference on Digital System Design}, pp. 287-290, 2017.




\bibitem{network:SS}
S. Swapp, \emph{Scanning Electron Microscopy (SEM)},\hskip 1em University of Wyoming.

%\bibitem{conference:MM}
%M. Banga and M.S. Hsiao, ``A novel sustained vector technique for the detection of hardware Trojans,'' \textit{Proc. International Conference of VLSI Design}, pp. 327-332, 2009.

\bibitem{conference:BB}
B. Bilgic and S. Ozev, ``Guaranteed activation of capacitive Trojan triggers during post production test via supply pulsing,'' \textit{Proc. Design, Automation \& Test in Europe Conference}, pp. 993-998, 2022.

%\bibitem{conference:KX}
%K. Xiao and M. Tehranipoor, ``BISA: Built-in self-authentication for preventing hardware Trojan insertion,'' \textit{Proc. International Symposium on Hardware-Oriented Security and Trust}, pp. 45-50, 2013.

\bibitem{article:DD}
D. Deng, Y. Wang, and Y. Guo, ``Novel design strategy toward A2 Trojan detection based on built-in acceleration structure,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 12, pp. 4496-4509, Feb. 2020.

\bibitem{article:YH1}
Y. Huang, S. Bhunia, and P. Mishra, ``Scalable test generation for Trojan detection using side channel analysis,'' \textit{IEEE Transactions on Information Forensics and Security}, vol. 13, no. 11, pp. 2746-2760, Nov. 2018.

%\bibitem{article:LN}
%L. Nguyen, C. Cheng, M. Prvulovic, and A. Zaji\'{c}, ``Creating a backscattering side channel to enable detection of dormant hardware Trojans,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 27, no. 7, pp. 1561-1574, Apr. 2019.


%\bibitem{article:SY}
%S. Yang, T. Hoque, P. Chakraborty, and S. Bhunia, ``Golden-free hardware Trojan detection using self-referencing,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 30, no. 3, pp. 325-338, Mar. 2022.




\bibitem{conference:YH}
Y. Hou, H. He, K. Shamsi, Y. Jin, D. Wu, H. Wu, ``R2D2: runtime reassurance and detection of A2 Trojan,'' \textit{Proc. International Symposium on Hardware-Oriented Security and Trust}, pp. 195-200, 2018.

%\bibitem{article:SB}
%S. Bhunia, M. Abramovici, D. Agrawal, P. Bradly, M.S. Hsiao, J. Plusquellic, and M. Tehranipoor, \textit{IEEE Design \& Test}, vol. 30, no. 3, pp. 6-17, May 2013.


\bibitem{conference:JH}
J. He, X. Guo, H. Ma, Y. Liu, Y. Zhao, and Y. Jin, ``Runtime trust evaluation and hardware Trojan detection using on-chip EM sensors,'' \textit{Proc. Design Automation Conference}, pp. 1-6, Jun. 2020.

\bibitem{article:YH}
Y. Hou, H. He, K. Shamsi, Y. Jin, D. Wu and H. Wu, ``On-chip analog Trojan detection framework for microprocessor trustworthiness,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 38, no. 10, pp. 1820-1830, Oct. 2019.

%\bibitem{conference:AK}
%A. Kulkarni, Y. Pino, and T. Mohsenin, ``SVM-based real-time hardware Trojan detection for many-core platform,'' \textit{Proc. International Symposium on Quality Electronic Design}, pp. 362-367, 2016.

%\bibitem{article:AK}
%A. Kulkarni, Y. Pino, M. French, and T. Mohsenin, ``Real-time anomaly detection framework for many-core router through machine learning techniques,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 13, no. 1, pp. 10-22, Jan. 2017.

%\bibitem{article:HZ}
%H. Zhao, L. Kwiat, K.A. Kwiat, C.A. Kamhoua, and L. Njilla, ``Applying chaos theory for runtime hardware Trojan monitoring and detection,'' \textit{IEEE Transactions on Dependable and Secure Computing}, vol. 17, no. 4, pp. 716-729, Jul. 2020.

%\bibitem{conference:AM}
%A. Malekpour, R. Ragel, D. Murphy, A. Ignjatovic, and S. Parameswaran, ``Hardware Trojan detection and recovery in MPSoCs via on-line application specific testing,'' \textit{ACM Journal of Emerging Technologies in Computing Systems}, vol. 13, no. 1, pp. 10-22, Jan. 2017.

%\bibitem{article:BM}
%B.J. Mohd, S. Abed, T. Hayajneh, and M.H. Alshayeji, ``Run-time monitoring and validation using reverse funciton (RMVRF) for hardware Trojans detection,'' \textit{IEEE Transactions on Dependable and Secure Computing}, vol. 18, no. 6, pp. 2689-2704, Nov. 2021.

%\bibitem{article:CB}
%C. Bao, D. Forte, and A. Srivastava, ``Temperature tracking: toward robust run-time detection of hardware Trojans,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 34, no. 10, pp. 1577-1585, Oct. 2015.

\bibitem{article:JZ}
J. Zhu \textit{et al.}, ``Jintide: utilizing low-cost reconfigurable external monitors to substantially enhance hardware security of large-scale CPU clusters,'' \textit{IEEE Journal of Solid-State Circuits}, vol. 56, no. 8, pp. 2585-2601, Aug. 2021.

%\bibitem{article:FK}
%F. Khalid, S.R. Hasan, S. Zia, O. Hasan, F. Awwad, and M. Shafique, ``MacLeR: machine learning-based runtime hardware Trojan detection in resource-constrained IoT edge devices,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 11, pp. 3748-3761, Nov. 2020.




\bibitem{article:JR3}
J. Rajendran, O. Sinanoglu, and R. Karri, ``Building trustworthy systems using untrusted components: a high-level synthesis approach,'' \textit{IEEE Transactions on Very Large Scale Integration (VLSI) Systems}, vol. 24, no. 9, pp. 2946-2959, Apr. 2016.

%\bibitem{article:SS}
%S. Sethumadhavan, A. Waksman, M. Suozzo, Y. Huang, and J. Eum, ``Trustworthy hardware from untrusted components,'' \textit{Communications of the ACM}, vol. 58, no. 9, pp. 60-71, Sep. 2015.

\bibitem{article:TR}
T. Reece and W. H. Robinson, ``Detection of hardware Trojan in third-party intellectual property using untrusted modules,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 35, no. 3, pp. 357-366, Jul. 2015.

\bibitem{conference:MB}
M. Beaumont, B. Hopkins, and T. Newby, ``SAFER PATH: security architecture using fragmented execution and replication for protection against Trojaned hardware,'' \textit{Proc. Design, Automation \& Test in Europe Conference}, pp. 1000-1005, Mar. 2012.

\bibitem{conference:XC}
X. Cui et al., ``High-level synthesis for run-time hardware Trojan detection and recovery,'' \textit{Proc. Design Automation Conference}, pp. 1-6, Jun. 2014.

\bibitem{conference:MS}
M. Shatta, I. adly, H. Amer, G. Alkady, R. Daoud, S. Hamed, and S. Hatem, ``FPGA-based architectures to recover from hardware Trojan horses, single event upsets and hard failures,'' \textit{Proc. International Conference on Microelectronics}, pp. 1-4, 2020.

\bibitem{conference:JR2}
J. Rajendren, H. Zhang, O. Sinanoglu, and R. Karri, ``High-level Synthesis for Security and Trust,'' \textit{Proc. International On-Line Testing Symposium}, pp. 232-233, 2013.

\bibitem{article:SR}
S. Rajmohan, N. Ramasubramanian, and N. Naganathan, ``Hybrid evolutionary design space exploration algorithm with defence against third party IP vulnerabilities,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 39, no. 10, pp. 2602-2614, May 2022.

\bibitem{conference:AS}
A. Sengupta and S. Bhadauria, ``Untrusted third party digital IP cores: power-delay trade-off driven exploration of hardware Trojan secuired datapath during high level synthesis,'' \textit{Proc. Great Lakes Symposium on VLSI}, pp. 167-172, May 2015.

\bibitem{article:YS}
Y. Sun, G. Jiang, S.-K. Lam, and F. Ning, ``Designing energy-efficient MPSoC with untrustworthy 3PIP cores,'' \textit{IEEE Transactions on Parallel and Distributed Systems}, vol. 31, no. 1, pp. 51-63, Jan. 2020.

\bibitem{conference:HS}
H. Salmani and M. Tehranipoor, ``Analyzing circuit vulnerability to hardware Trojan insertion at the behavioral level,'' \textit{IEEE International Symposium on Defect and Fault Tolerance in VLSI and Nanotechnology Systems}, pp. 190-195, 2013.

\bibitem{article:XC}
X. Cui, X. Zhang, H. Yan, L. Zhang, K. Cheng, Y. Wu, and K. Wu, ``Toward building and optimizing trustworthy systems using untrusted components: a graph-theoretic perspective,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 41, no. 5, pp. 1386-1399, Oct. 2020.


\bibitem{article:CL}
C. Liu, J. Rajendran, C. Yang, and R. Karri, ``Shielding heterogeneous MPSoCs from untrustworthy 3PIPs through security-driven task scheduling,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 2, no. 4, pp. 461-472, Aug. 2014.

\bibitem{article:NW}
N. Wang, S. Chen, J. Ni, X. Ling, and Y. Zhu, ``Security-aware task scheduling using untrusted components in high-level synthesis,'' \textit{IEEE Access}, vol. 6, pp. 15663-15678, Jan. 2018.

\bibitem{conference:NW}
N. Wang, M. Yao, D. Jiang, S. Chen, and Y. Zhu, ``Security-driven task scheduling for multiprocessor system-on-chips with performance constraints,'' \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 545-550, 2018.







\bibitem{article:WH}
W. Hu, C.-H. Chang, A. Sengupta, S. Bhunia, R. Kastner, H. Li, ``An overview of hardware security and trust: threats, countermeasures, and design tools,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 40, no. 6, pp. 1010-1038, Jun. 2021.


%\bibitem{article:YC}
%Y. Cao, C.Q. Liu, and C.-H. Chang, ``A low power diode-clamped inverter-based strong physical unclonable function for robust and lightweight authentication,'' \textit{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol. 65, no. 11, pp. 3864-3873, Nov. 2018.

%\bibitem{article:FP}
%F. Pareschi, G. Setti, and R. Rovatti, ``Implementation and testing of high-speed CMOS true random number generators based on chaotic systems,'' \textit{IEEE Transactions on Circuits and Systems I: Regular Papers}, vol. 57, no. 10, pp. 3124-3137, Dec. 2010.





%\bibitem{article:QS}
%Q. Shi, M.M. Tehranipoor, and D. Forte, ``Obfuscated built-in self-authentication with secure and efficient wire-lifting,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 38, no. 11, pp. 1981-1994, Nov. 2019.

\bibitem{article:DM}
D. Meng, R. Hou, G. Shi, B. Tu, A. Yu, Z. Zhu, X. Jia, Y. Wen, and Y. Yang, ``Built-in security computer: deploying security-first architecture using active security processor,'' \textit{IEEE Transactions on Computers}, vol. 69, no. 11, pp. 1571-1583, Nov. 2020.

\bibitem{conference:AA}
A. Ardeshiricham, Y. Takashima, S. Gao, and R. Kastner, ``VeriSketch: Synthesizing secure hardware designs with timing sensitive information flow properties,'' \textit{Proc. ACM SIGSAC Conference on Computer and Communications Security}, pp. 1623-1638, 2019.

%\bibitem{book:TA}
%T. Alves and D. Felton, TrustZone: Integrated hardware and soft ware security-enabling trusted computing in embedded systems, ARM, Cambridge, U.K., White Paper, 2014.


\bibitem{conference:HK}
H. Kim, S. Hong, B. Preneel, and I. Verbauwhede, ``STBC: Side channel attack tolerant balanced circuit with reduced propagation delay, \textit{Proc. IEEE Computer Society Annual Symposium on VLSI}, pp. 74-79, 2017.

%\bibitem{article:SP}
%S. Patranabis, A. Chakraborty, D. Mukhopadhyay, and P.P. Chakrabarti, ``Fault space transformation: a generic approach to counter differential fault analysis and differential fault intensity analysis on AES-like block ciphers,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 12, no. 5, pp. 1092-1102, May 2017.

%\bibitem{article:AS0}
%A. Sengupta, D. Roy, and S.P. Mohanty, ``Triple-phase watermarking for reusable IP core protection during architecture synthesis,'' \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 37, no. 4, pp. 1092-1102, Apr. 2018.

\bibitem{article:AS1}
A. Sengupta and M.Rathor, ``IP core steganography for protecting DSP kernels used in CE systems,'' \textit{IEEE Transactions on Consumer Electronics}, vol. 65, no. 4, pp. 506-515, Nov. 2019.

\bibitem{conference:KH}
K. Hasegawa, M. Yanagisawa, N. Togawa, ``Trojan-feature extraction at gate-level netlists and its application to hardware-Trojan detection using random forest classifer,'' \textit{Proc. IEEE Symposium on Circuits and Systems}, pp. 74-79, 2017.

%\bibitem{article:WS}
%W. Shan, S. Zhang, J. Xu, M. Lu, L. Shi, and J. Yang, ``Machine learning assisted side-channel-attack countermeasure and its application on a 28-nm AES circuit,'' IEEE Journal of Solid-State Circuits, vol. 55, no. 33, pp. 794-804, Mar. 2020.


\bibitem{conference:XZ}
X. Zhang and M. Tehranipoor, ``Case study: detecting hardware Trojans in third-party deigital IP cores,'' \textit{International Symposium on Hardware-Oritented Security and Trust}, pp. 67-70, 2011.

\bibitem{article:KX}
K. Xiao, D. Forte, Y. Jin, R. Karri, S. Bhunia, and M. Tehranipoor, ``Hardware Trojans: lessons learned after one decade of research,'' \textit{ACM Transactions on Design Automation of Electronic Systems}, vol. 22, no. 1, pp. 6-29, May 2016.








\bibitem{article:SB1}
S. Bhunia, M. Abramovici, D. Agrawal, P. Bradley, M.S. Hsiao, J. Plusquellic, M. Tehranipoor, ``Protection against hardware Trojan attacks: towards a comprehensive solution,'' \textit{IEEE Design \& Test}, vol. 30, no. 3,  pp. 6-17, Jun. 2013.

\bibitem{conference:RC}
R.S. Chakraborty, S. Narasimhan, and S. Bhunia, ``Hardware Trojan: threats and emerging solutions,'' \textit{Proc. IEEE International High Level Design Validation and Test Workshop}, pp. 166-171, 2009.











%\bibitem{conference:SM}
%S. Moulik, R. Devaraj, A. Sarkar, and A. Shaw,  ``A deadline-partition oritented heterogeneous multi-core schedule for periodic tasks,'' \textit{Proc. International Conference on Parallel and Distributed Computing, Applications and Technologies}, pp. 204-210, 2017.

%\bibitem{conference:SM-SMC}
%S. Moulik, Z. Das, and G. Saikia,  ``CEAT: A cluster based energy aware scheduler for real-time heterogeneous systems,'' \textit{Proc. International Conference on Systems, Man, and Cybernetics}, pp. 1815-1821, 2017.

%\bibitem{conference:YS}
%Y. Sharma and S. Moulik,  ``CETAS: A cluster based energy and temperature efficient real-time scheduler for heterogeneous platforms,'' \textit{Proc. The ACM/SIGAPP Symposium on Applied Computing}, pp. 501-509, 2017.

%\bibitem{article:YS1}
%Y. Sharma, S. Chakraborty, and S. Moulik,  ``ETA-HP: An energy and temperature-aware real-time scheduler for heterogeneous platforms,'' \textit{The Journal of Supercomputing}, vol. 78, pp. 10595-10619, 2022.

%\bibitem{article:YS2}
%Y. Sharma and S. Moulik, ``FATS-2TC: A fault tolerant real-time scheduler for energy and temperature aware heterogeneous paltforms with two types of cores,'' \textit{Microprocessors and Microsystems}, vol. 96, pp. 104744-104744, 2022.

\bibitem{article:SM1}
S. Moulik, ``RESET: a real-time scheduler for energy and temperature aware heterogeneous multi-core systems,'' \textit{Integration, the VLSI Journal}, vol. 77, pp. 59-69, 2021.

%\bibitem{article:SM2}
%S. Moulik, Z. Das, R. Devaraj, and S. Chakraborty, ``SEAMERS: A semi-partitioned energy-aware scheduler for heterogeneous multicore real-time systems,'' \textit{Journal of Systems Architecture}, vol. 114, pp. 101953-101953, 2021.







\bibitem{conference:DG}
D. Gizopoulos \textit{et al.}, ``Architectures for online error detection and recovery in multicore processors,'' \textit{Proc. Design, Automation and Test in Europe Conference}, pp. 533-538, 2011.

\bibitem{article:NV}
N. Veeranna and B.C. Schafer, ``Hardware Trojan detection in behavioral intellectual properties (IP's) using property checking techniques,'' \textit{IEEE Transactions on Emerging Topics in Computing}, vol. 5, no. 4, pp. 576-585, Oct. 2017.


\bibitem{article:PP}
P.G. Paulin and J.P. Knight, ``Force-directed scheduling for the behavioral synthesis of ASIC's,''  \textit{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol. 8, no. 6, pp. 661-679, Jun. 1989.

\bibitem{conference:LC}
L. Chang, W. Li, and W. Zhang,  ``Computing a near-maximum independent set in linear time by reducing-peeling,'' \textit{Proc. ACM International Conference on Management of Data}, pp. 1181-1196, 2017.



\end{thebibliography}

% biography section
%
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:

\begin{IEEEbiography}{Nan Wang}
received a B.E. degree in computer science from Nanjing University, Nanjing, China, in 2009, and M.S and Ph.D. degrees from the Graduate School of IPS, Waseda University, Japan, in 2011, and 2014, respectively. He is currently an associate professor in School of Information Science and Engineering, East China University of Science and Technology, Shanghai, China. His current research interests include VLSI design automation, low power design techniques, network-on-chip and reconfigurable architectures. Dr. Wang is a member of IEEE and IEICE.
\end{IEEEbiography}

% if you will not have a photo at all:
\begin{IEEEbiography}{Song Chen}
received a B.S. degree in computer science from Xi'an Jiaotong University, Xi'an, China, in 2000, and M.S. and Ph.D. degrees in computer science from Tsinghua University, Beijing, China, in 2003 and 2005, respectively. From August 2005 to March 2009, he served as a research associate at the Graduate School of IPS, Waseda University, Japan, and from April 2009 to August 2012, he served the same university as an assistant professor. He is currently an associate professor at the Dept. of Electronic Sci. and Tech., University of Science and Technology of China (USTC). His current research interests include several aspects of VLSI physical design automation, on-chip communication system, and computer-aided design for emerging technologies. Dr. Chen is a member of IEEE and IEICE.
\end{IEEEbiography}

%\begin{IEEEbiography}{Hongqing Zhu}
%received the ph.D. degree from Shanghai Jiao Tong University, Shanghai, China, in 2000. From 2003 to 2005, she was a Post-Doctoral Fellow with the Department of Biology and Medical Engineering, Southeast University, Nanjing, China. She is currently a Professor at the East China University of Science and Technology, Shanghai. Her current research interests include deep learning, pattern recognition, and information security. She is a member of IEEE and IEICE.
%\end{IEEEbiography}

\begin{IEEEbiography}{Yu Zhu}
received the B.S. and Ph.D. degrees in electronics and communication engineering from Nanjing University of Science and Technology, Nanjing, China, in 1995 and 1999 respectively. She is currently a professor of electronics and communication engineering in East China University of Science and Technology, Shanghai, P.R. China. In 2005, she was a research scholar in UIUC. Her current research interests include computer design automation, pattern recognition and machine learning.
\end{IEEEbiography}

% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

%\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}




% that's all folks
\end{document}


